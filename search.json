[{"title":"早课太困，咖啡续命","path":"/posts/50562.html","content":"# 困😴\n\n最近博主已经高三了，晚上作息调整为11点20熄灯，但是由于博主睡眠的前摇比较长，每次睡着可能都已经11点50左右了而第二天早上6点30分亮灯，因此每天下来的夜间睡眠时长平均只有6.5h左右。但是早上起床的时候并没有很困，甚至可以说很清醒，但到了教室，早读一结束，就真的恹恹欲睡。不是说睁不开眼的那种困，而是那种整个人很昏沉的困，如果第一二节是语文那更是雪上加霜，大脑可能直接彻底宕机，一方面听课效率很低，另一方面对我的意志力也是一个不小的挑战。\n\n# 咖啡续命\n\n此前很长一段时间尝试过用薄荷糖来提神，但是薄荷糖的作用效果真的太短了，而且个人感觉有点分神。嘴巴里面含着薄荷糖感觉精力也会受到一定的牵扯。于是我把目光转向了咖啡因。\n\n## 三顿半快饮系列（mix）\n\n选择的第一款咖啡是**三顿半的快饮系列**。三顿半在速溶咖啡行业可谓是鼎鼎有名，一直宣传的是“精品咖啡”，价格一点也不便宜，即便打折下来也是**3元/颗**。因此，我选择先买它，尝尝速溶咖啡的天花板，方便我后续评判其他的速溶咖啡。\n\n先说优点，首先是超细的咖啡粉，溶解性很好，冷水也能轻松泡开；而且咖啡粉是一颗一颗的，每颗2g，很好控制量也不容易坏掉。其次咖啡香气很浓，这点给人的印象很好。\n\n但是我个人还是不太喜欢，原因可能就在于它太“精品”了。首先是价格太贵，不适合天天喝，其次太过有特点的咖啡风味（苦/酸），其实不太符合我个人的喜好。\n\n**结论**：贵，有咖啡香气，但拿铁风味有点苦，美式风味有点酸，属于特点分明的那类\n\n## 雀巢金标深烘\n\n这是一款冻干咖啡，感觉比咖啡粉可能要高级一点，但是溶解性可能会稍逊一些（冷水条件下）。博主亲测的话，用冷牛奶大概率是泡不开的，第一口会明显比剩下的浓郁很多。\n\n博主买成25元/75g，价格上比三顿半便宜很多，风味的话不苦也不酸，有一股淡淡的咖啡香气。但我说实话确实有些太淡了，兑了牛奶以后就像在喝咖啡味牛奶一样，喝完回味的甚至都是甜味（但我实际一勺糖也没放）\n\n但雀巢口碑更好的实际上是它的金牌系列，包括瑞士进口，日本进口等。所以我下一瓶冻干咖啡大概会选择雀巢的金牌（100%阿拉卡比咖啡豆那款），等喝完这瓶金标我就下单（顺便把图片补了doge）\n\n# 两难\n\n我喝咖啡本来是为了解困，但是早上喝咖啡并不能让我的早课清醒，但会让我睡不着午觉，反而影响一整天的状态。但是完全不喝咖啡吧，上午第二三节课真的会睡着...喝了吧，午觉睡不着，又很难受...\n\n看来最好的办法应该是多睡觉，但如果我能多睡会儿的话也没咖啡的事了。","tags":["咖啡","学习"],"categories":["日常"]},{"title":"如何在诺基亚上愉快的使用DeepSeek","path":"/posts/250913.html","content":"由于nokia的浏览器只能访问静态网页，无法加载js，所以我们用Cloudflare worker代理向api发送请求，再渲染为静态页面返回给浏览器即可。\n\n下面是Cloudflare worker的代码实现。\n注意要绑定KV，名字为CACHE，你也可以自己更改\n\n注：\n1. 可能存在部分网络情况下无法访问Cloudflare的情况，对此我的办法是走vercel反代，当然会有1min限时的问题但我也没想出别的办法。\n2. 连续对话功能没有实现，以后再做吧\n3. deepseek可能会花过多时间思考，导致请求超时。这属于是硬伤，可能只有换成别的轻量模型会好点\n\n```javascript\nconst CACHE_TTL = 864000; // 缓存有效期24小时（单位：秒）\n\nfunction createHTML(title, content) {\n  return `<!DOCTYPE html>\n<html>\n<head>\n  <title>${title}</title>\n  <meta charset=\"UTF-8\">\n  <style>\n    body { \n      font-family: -apple-system, system-ui, sans-serif;\n      max-width: 800px;\n      margin: 1rem auto;\n      padding: 0 1rem;\n      line-height: 1.5\n    }\n    .box { \n      background: #f8f9fa;\n      padding: 1rem;\n      margin: 1rem 0;\n      border-radius: 4px;\n      border: 1px solid #dee2e6\n    }\n    .cache-link { \n      color: #0d6efd;\n      word-break: break-all\n    }\n  </style>\n</head>\n<body>\n  ${content}\n</body>\n</html>`;\n}\n\n// 转义HTML特殊字符\nfunction escapeHTML(str) {\n  return str.replace(/[&<>\"']/g, m => \n    ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '\"': '&quot;', \"'\": '&#39;' })[m]\n  );\n}\n/* * * * * * * * * * * *\n *  micromarkdown .js  *\n *    Version 0.3.4    *\n *    License:  MIT    *\n *   Simon  Waldherr   *\n * * * * * * * * * * * */\nfunction markdownToHtml(markdown) {\n  const lines = markdown.split('\\n');\n  let html = [];\n  let inList = false;\n  let currentParagraph = [];\n\n  const flushParagraph = () => {\n    if (currentParagraph.length > 0) {\n      html.push(`<p>${processInline(currentParagraph.join('<br>'))}</p>`);\n      currentParagraph = [];\n    }\n  };\n\n  const flushList = () => {\n    if (inList) {\n      html.push('</ul>');\n      inList = false;\n    }\n  };\n\n  const processInline = (text) => {\n    return text\n      .replace(/!\\[([^\\]]*)\\]\\(([^)]+)\\)/g, '<img src=\"$2\" alt=\"$1\">')\n      .replace(/\\[([^\\]]+)\\]\\(([^)]+)\\)/g, '<a href=\"$2\">$1</a>')\n      .replace(/\\*\\*(.*?)\\*\\*/g, '<strong>$1</strong>')\n      .replace(/\\*(.*?)\\*/g, '<em>$1</em>');\n  };\n\n  for (const line of lines) {\n    // 处理标题\n    const headingMatch = line.match(/^(#+)\\s+(.*)/);\n    if (headingMatch) {\n      flushParagraph();\n      flushList();\n      const level = Math.min(headingMatch[1].length, 6);\n      html.push(`<h${level}>${processInline(headingMatch[2])}</h${level}>`);\n      continue;\n    }\n\n    // 处理列表\n    const listItemMatch = line.match(/^[*\\-]\\s+(.*)/);\n    if (listItemMatch) {\n      flushParagraph();\n      if (!inList) {\n        html.push('<ul>');\n        inList = true;\n      }\n      html.push(`<li>${processInline(listItemMatch[1])}</li>`);\n      continue;\n    } else if (inList) {\n      flushList();\n    }\n\n    // 处理空行\n    if (line.trim() === '') {\n      flushParagraph();\n      continue;\n    }\n\n    // 收集段落内容\n    currentParagraph.push(line.trim());\n  }\n\n  // 处理剩余内容\n  flushParagraph();\n  flushList();\n\n  return html.join('\\n');\n}\n\n\n/* /micromarkdown */\nasync function handleRequest(request,env) {\n  const url = new URL(request.url);\n  const params = url.searchParams;\n  \n  // 优先检查缓存请求\n  const id = params.get('id');\n  let cacheId = params.get('cache_id');\n  if (cacheId) {\n    const cachedData = await env.CACHE.get(cacheId);\n    if (cachedData) {\n      const { question, convertedAnswer } = JSON.parse(cachedData);\n      return new Response(createHTML(\n        `缓存内容 #${cacheId}`,\n        `<h1>缓存内容</h1>\n        <div class=\"box\">\n          <h3>原始问题：</h3>\n          <div>${question}</div>\n          <h3>AI回复：</h3>\n          <div>${convertedAnswer}</div>\n        </div>\n        <p><a href=\"${url.origin}\">返回新提问</a></p>`\n      ), { headers: { 'Content-Type': 'text/html' } });\n    }\n    return new Response(createHTML(\n      '缓存不存在',\n      '<h1>缓存不存在或已过期</h1><p><a href=\"/\">返回</a></p>'\n    ), { status: 404, headers: { 'Content-Type': 'text/html' } });\n  }\n  if (id) {\n    cacheId = id;\n    const cachedData = await env.CACHE.get(cacheId);\n    if (cachedData) {\n      const { question, convertedAnswer } = JSON.parse(cachedData);\n      return new Response(createHTML(\n        `#${cacheId} ${question}`,\n        `<h1>缓存内容</h1>\n        <div class=\"box\">\n          <h3>原始问题：</h3>\n          <div>${question}</div>\n          <h3>AI回复：</h3>\n          <div>${convertedAnswer}</div>\n        </div>\n        <p><a href=\"${url.origin}\">返回新提问</a></p>`\n      ), { headers: { 'Content-Type': 'text/html' } });\n    }\n  }\n  // 处理新请求\n  const question = params.get('content');\n  if (!question) {\n    return new Response(createHTML('JavaScript-free DeepSeek','<h2>我是 DeepSeek-R1，不该问的别问</h2><p>我有可能可以帮你写代码、读文件、写作各种创意内容，请把你的任务交给我吧~</p><p>提示：上为content，下为id，注意区分</p><form method=\"GET\" action=\"/\"><input type=\"text\" name=\"content\" placeholder=\"向 DeepSeek-R1 询问任何问题\"><input type=\"text\" name=\"id\" placeholder=\"请输入ID\"><button type=\"submit\">发送</button></form><p>Created by Keee</p>'), { status: 400, headers: { 'Content-Type': 'text/html' } });\n  }\n  try {\n    // 调用OpenAI API\n    const response = await fetch('https://integrate.api.nvidia.com/v1/chat/completions', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ***`\n      },\n      body: JSON.stringify({\n        model: \"deepseek-ai/deepseek-r1\",\n        messages: [{ role: \"user\", content: question }],\n        temperature:0.6,\n        top_p:0.7,\n        stream:false\n      })\n    });\n\n    const data = await response.json();\n    const answer = data.choices[0].message.content;\n    const convertedAnswer = markdownToHtml(answer);\n    // 生成缓存ID并存储\n    \n    let cacheId = Date.now().toString(36) + Math.random().toString(36).substr(2, 5)\n    if(id) cacheId = id\n    await env.CACHE.put(cacheId, JSON.stringify({ question, convertedAnswer }), {\n      expirationTtl: CACHE_TTL\n    });\n\n    return new Response(createHTML(\n      question,\n      `<h1>Deepseek-R1</h1>\n      <div class=\"box\">\n        <h3>问题：</h3>\n        <div>${escapeHTML(question)}</div>\n        <h3>AI回复：</h3>\n        <div>${convertedAnswer}</div>\n      </div>\n      <p>缓存链接：<br>\n        <a class=\"cache-link\" href=\"?cache_id=${cacheId}\">${url.origin}/?cache_id=${cacheId}</a>\n      </p>`\n    ), { headers: { 'Content-Type': 'text/html' } });\n\n  } catch (error) {\n    return new Response(createHTML(\n      '发生错误',\n      `<h1>请求处理失败</h1>\n      <div class=\"box\">${escapeHTML(error.message)}</div>`\n    ), { status: 500, headers: { 'Content-Type': 'text/html' } });\n  }\n}\n\nexport default {\n  async fetch(request, env) {\n    try {\n      return await handleRequest(request, env);\n    } catch (err) {\n      return new Response(createHTML(\n        '服务器错误',\n        `<h1>服务器内部错误</h1><div class=\"box\">${escapeHTML(err.message)}</div>`\n      ), { status: 500, headers: { 'Content-Type': 'text/html' } });\n    }\n  }\n};\n```","tags":["deepseek","诺基亚"],"categories":["水文"]},{"title":"化学碎思","path":"/posts/50561.html","content":"# Ka2为什么小于Ka1\n\n这一点根据笔记记载，\n\n> 一级电离产生的大量H+抑制了二级电离\n\n这个说法乍一听似乎很有道理，但稍加思考，一个可逆反应的化学平衡常数与反应物或生成物浓度无关，那ka2跟一级电离的H+理论上也并无表面关系。\n至于普通化学原理上提到的 *“从浓度对于电离平衡的影响来看，第一步电离出的H3O+能抑制第二，第三步的电离，因此从数量上看，由第二，第三步电离出的H3O+与第一步电离的相比也是微不足道的”*\n对于这段话，我个人认为作者表达的是由于一级电离产生的H3O+的抑制作用，弱酸的后续电离的**电离度**低于一级电离，而非导致后续电离的电离常数低于一级电离。\n![](https://pic1.imgdb.cn/item/68b3b86758cb8da5c8657b78.webp)\n\n\n# 四氨合铜离子不该是dsp2杂化\n\n此处根据笔记和常见辅导资料，对于Cu2+的杂化类型都描述为dsp2杂化，但这一观点实际上在普通化学原理上有直接的驳斥\n![](https://pic1.imgdb.cn/item/68b3b89d58cb8da5c8657b7e.webp)\n\n> 然而平面四方形的Cu(NH3)42+离子，也有一个未成对的电子位于较高能级上，但(Cu(NH3)42+离子却是很稳定的，并不具有还原性。**这一点与实验事实是相互矛盾的**。\n\n很明显，Cu2+并非dsp2杂化，其具体结构无法用传统的杂化轨道解释\n\nhttps://www.zhihu.com/question/325449174/answer/2106341904?utm_psn=1868681618203471872","tags":["水文"],"categories":["胡扯区"]},{"title":"2024-summary","path":"/posts/43278.html","content":"# 博客琐事\n## 主题又换新\n由于学业繁忙，博主太懒，这个博客实际上有好几月无人维护 XD。但我还一直惦记这个事情，觉得先前使用的 butterfly 太臃肿，想换个主题。直到 3 月末，一是在学校忽然有了想法，二是刚好有难得的清明节 3 天小长假，将博客主题从 butterfly 更换成了 Stellar。Stellar 主题简洁大方，而且有非常丰富的标签组件和社区支持，很是得我心。于是用了一天时间给主题添加了 pjax 支持（并不完善）并完成了博客迁移工作\n\n后来一直用到了大概七月左右，偶然间在开往里发现了 Astro 框架。首先，Astro 的动画效果真的非常流畅，与平常的 wowjs 动画效果真的大有不同（其实感觉有点像 PowerPoint 的平滑效果，当然实际效果因站而异）于是就二度生发了迁移的想法。当时我选择了 fuwari 主题，我想要的效果 fuwari 基本都能实现，流畅的动画，简洁的布局...但是吧，这个主题实际使用起来和配合成熟框架 hexo 的 stellar 感觉还是有点不一样，我想要的评论组件，toc 组件都不齐全，至于 stellar 的标签组件之类的更不用说，但最重要的是，二次开发体验并不是很好并且完全没有办法像 hexo 那样快速跟进主题更新...\n\n几经周折，还是决定继续抱着我的 hexo 用。但是如上文所述，我自己二改的 stellar 实际上还很不完善，在实际体验上（尤其是访问速度上）甚至还比不上原先的 butterfly😂 一整个蚌不住\n还是在偶然间，看见了 Stellaris（一个基于 Stellar 二改的主题）。当时看见的时候真的很惊艳，设计风格仿照 Stellar，Stellar 的特性基本保留，而且整个主题用 react 重构还有用 InstantClick 实现的 Pjax。有什么好说的？直接 star+clone😉\n\n## 域名更换\nkeee.top 这个域名是我今年才拿下的。与我的名字有一定关联（而又不像之前的域名那样直白，实名上网既视感），唯一美中不足的就是与某个搞 ai 的公司重名了，导致 seo 特别差。以前我并没有向 Google 和 bing 报备域名，它们就已经主动收录而且还有一定的权重，所以当时我的博客主要流量来源就是搜索引擎。但现在我主动请求收录却爱答不理，用关键词搜索发现我的网站排在很后面，几乎处于不可见状态，因而网站访客量一落千丈。\n## 加入开往\n为了改变这一状况，我决定打破自己博客的闭关现状，申请加入了开往。虽然日访问量仍不如以前，但开往带来的访客质量很高，我也很满意了，遂不再瞎折腾。\n# 学校生活\n## 平淡\n倘若让我用一个词描述我的 2024 年，我愿意选择“平淡”。为何平淡？还记得去年的此时此刻，我为自己立下的 flag，如今看来只是空谈。在过去的一年里，我依旧坚持着我的被动社交，消极改变，我的六科成绩分布依然如此——语数外差，物化生还行。每周也都浑浑噩噩地度过，周中听课，勉强做完作业，睡觉；周末回家，打开电脑，刷知乎，刷 b 站，倒腾下 blog，一个周末就过去了。周周如此，月月如此，似乎确实有些平淡。\n\n如果又换句话说，2024 年也并非如静水般的平淡。每一天也都并不一样，数学每一天都能给我带来新的恐惧，语文每一天也都能给我带来新的崩溃，每一天都会遇见一样的人说着不同的话，甚至碰见一些小小的惊喜。每天似乎都在做一样的事，但实际上都能给我来不一样的体验。每周都上一样的体育课，但我对羽毛球经历了喜爱到摆烂的转变。我的数学曾一点一点培养起了自信心，然后又被无情击碎。只不过学习生活的形式依旧，变化太小让我觉得它很平淡。\n\n## 有趣\n\n如上所述，2024 还是有很多有趣的事情发生。首先，我第一次参与了班级的大型活动筹备。学校在高二上学期组织了一次课本剧大赛，本来我并没有报名参加任何环节。但是在一个稀疏平常的早读，一个《变形记》灯光剧本赫然摆在我的课桌上改变了这一切。不一会儿，导演就来告知我说灯光组是做什么的，我当时确实是非常的困惑？？后来才知道有人给剧组推荐我去负责灯光，说我擅长这些事情（笑。但是实际上，灯光组并不能自己控制灯光，实际上我们做的是和学校的灯光老师沟通，做那个指令的翻译员。于是实际上这又成了我最不擅长的事情了。\n\n后面，我还去报了化学课代表。这个事情在我现在看来是很高兴的，我很早就想找个机会接近我喜欢的事，同时改变我自己在班级上小透明的现状。但我负责的又是化学的基础题编写，这个事情并不像收发作业那样简单，出题对我来说压力还是相当的大，更何况我之前也从未负责过相关板块。所以，过个一学期我又会怎么想也说不定了。\n\n还有很多事情，留着以后再讲（ε=ε=ε=┏(゜ロ゜;)┛\n\n# 出游\n今年并无过多出游经历，不像 2023 年，每逢大考结束我都会带着自己的相机去公园，去山上拍照。但在 7 月短暂的暑假里，家里还是组织了一次旅游——西北大环线\n## 初体验\n### 山脉 の 气势 ⛰\n\n数月未曾出重庆，对蓝天白云与晚霞都感到陌生。当时刚穿出秦岭，常绿阔叶林骤变为黄土高原，灰蒙蒙的“白天”变为蓝天，说实话还真有点小小的震撼。都说重庆是山城，但那山充其量就是些丘陵，而黄土高原的山才真的是气势雄伟，有一种扑面而来的震慑力。\n\n![](https://pic1.imgdb.cn/item/68b3b74c58cb8da5c8657b49.webp)\n\n### 美食 の 诱惑\n\n大西北杀器，廉价羊肉！具体多廉价我已忘了，但是一定比重庆便宜了不知道多少。每天赶路到达住宿地，少不了的就是羊肉串环节（如图）\n\n![🐏 羊肉串](https://pic1.imgdb.cn/item/68b3b69258cb8da5c8657b04.webp)\n\n当然，如果有经过兰州，也强烈建议去柏林巷尝尝手抓羊肉。三十多元钱一斤的手抓羊肉，吃个爽还是没问题的。\n\n## 沙漠行\n要我说，西北大环线唯一能吸引我的便只有沙漠。那沙丘远看不是很大，但那爬起来真的有一种深深的无助感。攀爬沙丘堪称最诚实的体能测试：前 30 步的轻盈如沙漠之舟，后 30 步的陷落似时间陷阱，拼尽全力无法战胜。不过，等到爬上了沙丘顶，在温热的沙子上躺平，看头顶星空，认真地找一次北斗七星，也有一种别样的体验。当然如果在沙丘留到了深夜，趁游客都走了，自己体验一次沙丘速降。那种高速旋转，肆意跳跃，纵情翻滚的爽感绝对令人印象深刻\n（注：星空音乐节，我认为有辱音乐节，那音响质量说实话不如广场舞的音响）\n\n![](https://pic1.imgdb.cn/item/68b3b62458cb8da5c8657af5.webp)\n\n![](https://pic1.imgdb.cn/item/68b3b69158cb8da5c8657b03.webp)\n\n\n## 盐湖与自然奇观\n\n![芒崖翡翠湖](https://pic1.imgdb.cn/item/68b3b62258cb8da5c8657af4.webp)\n\n![水上丹霞](https://pic1.imgdb.cn/item/68b3b74d58cb8da5c8657b4a.webp)\n\n![西台盐湖](https://pic1.imgdb.cn/item/68b3b62458cb8da5c8657af7.webp)\n\n非常喜欢这几个自然景点，出片率极高！！随手一拍即是大片\n\n不过注意图 1 的芒崖地理位置非常偏远，开车可能要穿越 300 公里以上的无人区（也无信号），全程断网而且两侧全是沙漠生态系统。如果你要去，相当于会直接多出数百公里行程并且只能看这一个景点，最多还有一个冷湖石油小镇（死城）可以浏览一下而已。因此如果旅行时间不甚充足，建议不用去。\n\n其中西台、东台还是野生景点，不收门票（貌似其中一个还有矿业公司在开发）","tags":["年度总结"],"categories":["随笔"]},{"title":"流水账：作业、八卦与表现欲","path":"/posts/50842.html","content":"迷惑的数学作业我很早就想吐槽这一点了。由于我们的数学老师比较有特色，在教高中，但是鼓吹着大学的学习理念（自学），还声称教室不该叫“教室”，而该叫”学室”。这一点得到了他很好的践行，即是每节数学课都要迟到 2 分钟以上，作业长期是“复习已学”。如果仅此而已，那也罢了。更逆天的是他的”预习新知”，一天预习一个课时，要求做完讲义和练习，并且自己对完答案批改。这两样加起来统共有 10 页，而他一天就布置下来了！！？？然后，他可能会花 2~3 天来讲 1 个课时，然后这几天作业又只有“复习已学”。所以，我们的作业量就是”多、没有、没有、没有、爆炸多、没有、没有”...属实让人难以理解。八卦风云与情报网我们语文老师有过这么一句箴言：{% quot  如果没有八卦，这个世界相当无聊；如果只有八卦，那这个世界也很无趣%}可以说没有人不爱听八卦，更何况是身边的同学？然而八卦消息并不能想报纸一样流通，而更像一个半去中心化的网络“去中心化”在于这个八卦一旦说出口，是很难制止其传播的，直接就一生二，二生三，三生万物（？）而”半 \"在于这个网络存在一个\" 中心 \"，他往往是各大小社交团体的交集与核心，可以自如地穿梭于两性群体，并且掌握大把的人脉资源，因而知晓最多的八卦。但他又肯定不会直接大肆宣传，每天都在寝室里面说谜语，跟一些知道的人打哑谜。我在旁边听着是真的难受啊😭😭。。。有点希望自己也能知道这么多的八卦表现欲10月1日，既是国庆节，也是我班班主任的生日 真·于国同庆了庆祝节目中有一个帅气的同学上来弹唱了吉他，技术很好而且真的很酷的说！而我又想起了他年初的时候做的一个New Year Resolution里面就提到了他希望能表演一下他的吉他。重新审视一下自己，发现自己却真的没有什么可以拿出来“表演”每次看到同学画画，唱歌，谈自己打架子鼓，自己都只能点点头，赞美几句，然后回过头来想高考后一定要学门特长...从某种程度上说，这个blog最初是一个表现我自己的门户，但后来证明它并没有这个功能。","tags":["生活","学校"],"categories":["流水账"]},{"title":"Pjax逆天默认属性：自动向Url添加时间戳","path":"/posts/25797.html","content":"## 前情提要\n\n突然来了兴致将网站的 Service Worker 更换成了 Google Chrome 团队的 Workbox，结果在缓存控制方面遇到个大问题：\n\n​\t**每刷新一次缓存就增长 20MB，几次访问下来缓存高达 400MB**\n\n但我整个网站包括图片、字体资源加起来也没有 50MB 啊？？（迷惑）\n\n结果发现 Workbox 会将 Url 参数不同的请求分别缓存一份...\n\n## 解决办法\n\n这里省略漫长的 Debug 过程（博主一直在找 Workbox 的问题），根本祸根在于 Pjax 的一个默认参数 [cachebust-boolean-default-true](https://github.com/MoOx/pjax/blob/master/README.md#cachebust-boolean-default-true)\n\n`cacheBust` (Boolean, default: `true`)\n\nWhen set to , Pjax appends a timestamp query string segment to the requested URL in order to skip the browser cache.`true`\n\n所以在创建 pjax 实例的代码里面加一条”cacheBust: false”即可","tags":["pjax"],"categories":["网站"]},{"title":"情绪迁移","path":"/posts/2612.html","content":"# 迁移你的情绪\n\n你可能经历过这样一些场景：因为看过某工作室的一部作品觉得优秀，于是对下一部作品充满期待。\n\n我们不妨从另一个角度来理解这种现象，我们实际上是将对工作室前作的喜爱转移到了尚且未知的新作上，而其中传输的通道正是他们的逻辑关系——源自同一工作室。对此，中国古代就早已有相关的成语，如“爱屋及乌”，因为喜爱一个男子，所以连带着他房子上的乌鸦也喜欢。如果把乌鸦单拎出来，它的下场多半是被人厌恶；但因为它现在站在了那个男人的屋檐上，所以又受人喜欢。同样的，我因为“Forza Horizons 4”才喜欢《A Moment Apart》这首作品，但两者实际上并无内在联系。倘若我先听闻了后者，可能对后者并不感冒；但因为我先知晓了前者，于是后者便被捧上了神坛。\n\n**事物没变，但是人们对它的情感态度却发生了极大的转变。**\n\n究其原因，不过是因为改变了对事物的认知途径。\n\n但这种传递它可靠吗？\n\n如果你试图用它来**预测未来**，很显然它并不可靠，且有被操纵决定的风险。在这种心理的影响下，人很容易被利用甚至被操纵。广告商或商家经常利用消费者对品牌的情感联结来推广新产品，即便这些新产品未必满足消费者的实际需求。这种情感引导可能让个体的判断不再基于理性分析，而是基于情感上的依赖，从而陷入消费陷阱。\n\n如果你试图用它来**服务现在**，它的逻辑可能依旧不可靠，它却可以成为积极心理状态的助燃剂。陈铭也曾举过一个背单词的例子，其大意为想象自己在跟自己的偶像用英语对话。听起来很荒谬，但其中恰好就利用了这个原理，背单词令人厌烦，但试图将其与自己喜爱的偶像结合起来后，背单词的枯燥乏味就被冲淡了。从外看，消极悲观背单词与积极主动背单词表现是一样的；但从内看，却大相径庭。\n\n在日常生活中，我们可能会遇到许多明明令人厌恶却不可不做的事情，有人也许会选择捏着鼻子消极应对，但有人会选择改变自己的认知，将”厌恶”扭转为”喜爱”，而情感迁移就是其中的一个办法。我有个朋友，他对于数学一直缺乏热情与信心，但是他恰好碰到了一个非常优秀的数学老师。无需任何附加操作，对数学老师的个人喜爱，逐渐迁移至数学本身，于是对老师的尊敬就化为了驱动自身学习的强劲动力，从而增强了当下的学习动力。\n\n有人可能会说，这是一种自我欺骗与麻痹，它损害了真正的内驱力的建立而后者才是源源不断前进动力。但是，内驱力并非生来就有，它是一点一点建立而成。而由A及B的情感迁移，正是建立内驱力的一种途径，它并不依赖外力，仅仅是改变自己对事物的认知途径，就推动了在现实世界中对指令的执行。何乐而不为呢？建立内驱力不是一种苦行，而是一种追求达到做事从心的状态。","tags":["心理"],"categories":["感想"]},{"title":"暑假回顾","path":"/posts/45501.html","content":"# 碎碎念\n\n## 一些话\n\n其实这篇博文本应该是 7 月小结，而且在 8 月初就该动笔，但因为博主实在是太懒，把 7 月小结硬生生拖成了暑假小结 XD\n\n## 期末考\n\n月初当然是是期末考试。分考室的时候很不幸被分到了 4 考室（我们学校分考室是根据上一次考试成绩排名来分的，考得越好考室就越靠前），空调是用的中央空调，效果很不好。而且可能是由于周围种的树太过于高大，枝叶把好几层教学楼都盖在阴影下，考试的时候我坐在里面总感觉很压抑。当然，我觉得考试带来的压迫感占的因素应该更大\n\n不过所幸的我所在的考室还是有几个熟人的，甚至我的前排就是一个同班同学（这非常的巧，因为我觉得 ta 不应该出现在这个考室的说）。但是我也不敢找他们说话，就每次进考场的时候瞪瞪眼睛，做出一副吃惊的表情来打招呼。其实不知道为什么，我和关系好的打招呼经常都是这种无声的打招呼，虽然旁人看上去可能很怪异，但本社恐感觉非常好(*^_^*)\n\n还是说回考试，我自我感觉良好。但是我们班的总体发挥上升空间较大，这让班主任大为恼火，害得我们放假那天的晚上直接给我们留到很晚...\n\n## 羟基补习\n\n怎么说呢，在补习开始之前，我们班主任告诉我们，他指定了一名 **特别优秀的数学老师** 来教我们，另外那几个肯定也很优秀但他不知道。然而，他指定的那个“特别优秀的数学老师”貌似去教历史班了（笑\n\n第一位数学老师很专业，讲课时总不忘 diss 一下清北这些一流院校的羟基题（都是抄的高联，“考羟基前复习一下前几届高联初赛就可以了”）。讲课节奏快，方法多，听起来就给人一种知识流过大脑的感觉。当然这不是刷知乎的那种”流过”，听完课后还是真的有收获的。\n\n后面的物理老师才是真正的重量级，他是北京大学教物理的一个大学老师，而且带了教物理竞赛老师的一个特性，就是有一种 **蜜汁优越感**。上来先 diss 一波生物、化学、英语。\n\n- “你孩子英语不好？你孩子是智障，我不教”\n- “有人知道 normal force 是什么意思吗？嗨，小地方的孩子。所以重庆永远不能成为大都市！”\n- \"rvsinα = const.\"\n- \"我们北京（后鼻音要加重）\"...\n\n以上种种都已经成为我们班上的流行梗，模仿老学究说话就是别有一番风趣。\n\n## 旅行\n\n羟基结束后，我们班主任给了我们约 8 天的自主安排时间（“注意不是放假，因为我们一直在放假”）\n\n我是选择去了一直心心念念的大西北，详见另一篇博文。\n\n## 漫长的暑假自习\n\n收假回来后，我们的暑假可谓是到了终点。\n\n### 娱乐\n\n但是我们的自习作息也是相当的自由，早上 7 点 20 到，中午 12 点放，下午 2 点 20 到，晚上 9 点半放\n\n还有非常宽松的门禁，导致我整个暑假自习期间就只在学校食堂吃过一次饭。\n\n中午下午一放学，就和同学们到金沙天街吃大餐，或者是去学校后门吃面或者快餐。有时候运气好还能碰到几个老师（？\n\n至于晚上的生活那是相当潇洒，自从有几个同学发现了学校对面新开了家烧烤店，几乎每周都会到那边去”串”，从 9 点半吃到 10 点半\n\n点得东西也不多，就一两串羊肉串，两三串素材，每个人一二十块钱就搞定了。\n\n最开始等菜的时候是聊闲天\n\n到后面，有人带了副扑克牌后就开始疯狂斗地主。让我这种几乎没有碰过扑克的人小小地增长了一下斗地主技术（但还是很菜/(ㄒoㄒ)/~~\n\n### 学习\n\n以上是休闲娱乐，但正经学习也不轻松。班主任给我们提前做好了好几张暑假计划表，每天的任务一点都不少...\n\n而且还有卷王带来的压迫感推动我学习 XD，尤其是当我连直线与 ⚪ 都还没做完的时候，有人都已经做完圆锥曲线，开始做概率与统计的时候，真的有点崩溃。。\n\n所以那几天，我就狂刷必刷题，把进度追到了双曲线。（圆锥曲线好难的说）\n\n值得注意的是，我们前段自习的时候班主任出差去了，就派了家长坐讲台上来监视我们（！！！）这实际上非常的不好，因为老师守自习一般都很水，但家长很负责全程把人盯住\n\n期间偶尔穿插些有趣的活动，像什么读书汇报小组，真的是趁着暑假狠狠地整活，夹带私货。","tags":["日常"]},{"title":"穷玩游戏--PC Game Pass","path":"/posts/202469.html","content":"## 写在开头\n\nXbox Game Pass，可谓是全球最受欢迎的游戏订阅服务，在用户规模和内容体量上都十分庞大。得益于巨硬的气大财粗以及Xbox旗下一系列工作室（如Playground Studio）产出的大量第一方游戏，XGP中也就不乏高质量的游戏。\n\n经典的热门游戏如：**极限竞速：地平线4**、**极限竞速：地平线5**、**Minecraft:Java & Bedrock Edition**\n\n爆火的现象级游戏如：**幻兽帕鲁**、**庄园领主**\n\n（这俩甚至是首发登录XGP）\n\n稍小众的高质量游戏如：**HiFi RUSH**、**Persona 3 Reload**、**都市：天际线2**\n\n其他大作：**星空**、**原子之心**、**星球大战：绝地幸存者**(EA Play)\n\n以上仅是我个人比较感兴趣的部分游戏，实际XGP中还包含很多游戏但我可能不知道（或者并不关心），而且XGP Ultimate还有云游戏等服务这里不作阐述\n\n\n\n**但是**，对于大多数PC玩家来说，我们需要购买的只有PC Game Pass（即Xbox Game Pass for PC）。而PC Game Pass不仅国区无法正常购买，而且价格不菲。对于新用户来说是10港币/月，也就是大约9元/月，而老用户为27元/月，若购买一年订阅则将花费超300元。对于学生党来说，可能一个月就只能玩10个小时左右，承担如此订阅费用会略有些压力。\n\n![](https://bu.dusays.com/2024/06/09/6665c67c27380.webp)\n\n因此，PC Game Pass共享号应运而生。\n\n## 共享号？\n\n目前，PC Game Pass共享号一年花费约在15元左右，甚至可以更低\n\n一听见“共享号”再结合这个价格，似乎这个方案显得很不靠谱\n\n实则不然，大多数卖PC Game Pass共享号的商家都采取了如下模式\n\n1. 用新号购买一整年的XGPU,成本最多300\n2. 出售PC 登录位*10，15元\n3. 出售主机 HOME位*1，129元\n4. 出售主机 登录位*1，99元\n5. 出售EA Play账号*1，49元\n6. 出售战网*1，69元\n7. 出售拳头绑定*1，69元\n8. 出售云游戏服务，99元\n\n上述总共加和约**565元**，对比成本来说就很合理了。即使在最坏情况的下，只卖出了PC登录位和Xbox主机 HOME位、EA Play商家也是能赚钱的。\n\n而且更重要的是，PC登录位一年只能有10个账号，这不能由号主删除或添加，所以店家也就没有了跑路的必要，即便跑了也不能多赚钱。\n\n## Xbox账号问题\n\nPC Game Pass共享号很好的一点就是——它只需要登录微软商店用于验证所有权，而玩游戏时用的Xbox是登录的自己的账号。也就是说，虽然是用的共享号，但如云存档、XBox点数、成就、在线游戏联机等都在自己的号上。（这点真的非常好\n\n## 关于购买\n\n随便找一家评价时间跨度长一点的老店即可\n\n## 成品\n\n![最终成品](https://bu.dusays.com/2024/06/09/6665c5e18331e.webp)","tags":["游戏","pgp","xbox"],"categories":["水文"]},{"title":"浅谈高考赋分制","path":"/posts/62312.html","content":"# 前言不久之前，进入高一下以来也是分科后的第一次考试结束了。最开始听别人说这次考试不赋分，心里面就有些窃喜。因为很早之前在初二就从 zq 口中听说了赋分的威力，后面结果出来后先拿到原始分很开心，觉得这次稳了，结果再选学科一赋分，排名一下子就往后滑了不少(；′⌒`)。# 不理性分析溯其本源赋分制本身是重庆近几年实行**3+1+2新高考模式**带来的产物，将原先的大文综、大理综拆成了四个再选学科可供自由选择，但录取时只分物理类和历史类，为保证公平，四个再选学科分数必须进行转换以消除学科间分数差异，于是以排名为基础的**赋分制**诞生了算法简述重庆市高考再选学科转换分满分为100分，赋分起点为30分。将没门选择考再选学科考生的原始分从高到低划分到A、B、C、D、E共五个等级，各个等级人数比例分别为15%、35%、35%、13%和2%，赋分区间以此为100~86、85~71、70~56、55~41和40~30Influence注意到，A、B两等级（即是说71~100）分数段的人就占了足足50%的比例，这说起来可能没什么直观感受，但如果再想想自己学校平时月考原始分的中位数大概是多少呢？？在 bz，中间名次大概是在1000名左右，这个时候的分数一般都有点一般，甚至是很一般，但是却能轻松赋到80分的高分，直接带来了20~30分左右的分数跃升（真的有点恐怖了。而且，越到高分段赋分带来的增长越来越弱，在一些学校高考的再选学科甚至有扁平化的趋势。赋分不会影响在这个再选学科的排名，但是对于总分影响就真的**相当大**了。记得尊敬的 xy 老师从高一入学前的暑假开始就在强调**主科的重要性**而且再选学科可以暂时不去管他。当时我还没意识到事情的严重性，觉得自己多摸过几年化学，就搞了本《天利》来刷（当然最后 xy 布置的任务是一个也没完成就拿我来说，我化学考试赋分之后大约只涨了有3分，生物也差不多；然而我周围原始分与我相当的同学几乎都有10~20分的涨幅，直接把我吊打了(*^_^*)。# 结语总之，教训很显然：","tags":["学习","高考","赋分"],"categories":["学习"]},{"title":"Caddy -- 一款优秀的Web服务器","path":"/posts/51203.html","content":"# 前言\n\n这几天一直在折腾家里的旧手机（参照前文），在用传统的 Nginx 搭建 https 服务的时候，证书问题真的超级麻烦而且 Nginx 的文件也很复杂，对一些新特性支持也一般，对我这种又懒又想折腾的人及其不友好。\n\n结果在网上冲浪的时候，偶然发现了 Caddy 这个宝藏软件\n\n官网：https://caddyserver.com/docs/\n\n# 独特之处\n\n首先，最重要的是是它的 **SSL 证书自动申请续期**，过程完全自动而且速度快，自己只需要提供 token（或者开放 80 端口）\n\n其次，它对 **新特性的支持优秀**，无需配置便支持 HTTP/3 quic、Markdown 自动翻译、ipv6 等特性\n\n![支持 http3/quic, ipv6](../img/屏幕截图%202023-08-28%20150439.png)\n\n最后，配置文件简单，配置三个站点仅用短短几行就能解决\n\n~~~Caddyfile\nipv6.pan.keee.top: 29565 {\n    reverse_proxy / 127.0.0.1:5244\n    encode gzip\n    tls {\n        dns dnspod \t\"ID, Token\"\n    }\n}\nipv6.keee.top: 443 mirror1.keee.top: 23232 {\n    root * /home/cqlkc/cqlkc.github.io\n    file_server\n    encode gzip\n    tls {\n        dns dnspod \t\"ID, Token\"\n    }\n}\n~~~\n\n但是，Caddy 相比 Nginx 在性能方面仍有劣势，Nginx 资源占用更低，速度更快（但是它更麻烦啊！\n\n所以小站点可能会更推荐 Caddy，可以大大降低维护成本（利好学生党\n\n# 配置教程\n\n参照 [官方文档](https://caddyserver.com/docs/) 和我的 Caddyfile 示例即可\n\n需要注意的是，国内家宽的 80 端口被封锁，因此 Caddy 默认的 HTTP-01 验证无法正常检验域名所有权\n\n## 非 80 端口验证域名所有权\n\n解决方法就是用 XCaddy 编译第三方插件和 Caddy 源码第三方插件即可\n\n第三方插件列表在 https://caddyserver.com/docs/modules/ 里面找\n\n我这里有编译过的 DNSpod 插件的 [Caddy 二进制文件（ARM64）](https://pan.keee.top:29565/d/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/Caddy/caddy)，可以直接用\n\n# 总结\n\nCaddy 很好用很好用很好用，懒人必备（笑","tags":["web","caddy"]},{"title":"给老手机部署上Alist服务","path":"/posts/13283.html","content":"家里有一台闲置的小米8（dipper），已经提前解锁Bootloader，中考后就想着在上面架设linux终端跑点东西\n\n# 准备过程\n\n所需材料:\n\n1. 安卓手机一台\n2. windows电脑一台\n\n安卓手机推荐解锁bl并root，方便后续实现插电运行，避免电池损耗鼓包，后续也以root为准\n\n国内开放解锁bl的手机品牌有：小米、一加、oppo、realme\n\n（小米为绑定后7天解锁，一加可以直接解锁，oppo、realme需要申请名额很难）\n\n有些较老安卓机可以直接fastboot解锁另说\n\n## 刷入合适的刷机包\n\n由于手上的小米8当时更新到了拉胯的MIUI12.5，又卡又费电不适合长期运行，所以决定回滚到MIUI10.3.5\n\n**如果手机当前状况良好可以不管**\n\n具体过程参照\n\nhttps://www.coolapk.com/feed/45223331\n\n## 提前下载所需应用\n\n解锁bl以后会清空手机数据，到时候一个一个下载很麻烦，所以提前下好，节约时间\n\n手机应用列表：\n\nMagisk Delta : https://github.com/HuskyDG/magisk-files/releases \n\nTermux  : https://github.com/termux/termux-app/releases\n\nAccA : https://github.com/MatteCarra/AccA/releases\n\nMT管理器 : https://www.coolapk.com/apk/bin.mt.plus\n\n电脑所需：\n\nMiflash : https://pan.keee.top:29565/123\n\nFastboot工具箱 : https://pan.keee.top:29565/123\n\n## 提前准备boot镜像\n\n首先在手机设置中确定系统版本，如MIUI10.3.5\n\n在相关渠道找到该版本的线刷包（fastboot刷机包）\n\n经过几次解压后，打开Image文件夹，找到boot.img拷贝到手机中备用\n\n![](https://img.keee.top/202306/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-29%20131920.webp)\n\n![](https://img.keee.top/202306/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-29%20132036.webp)\n\n# 操作流程\n\n## Root 手机（可选）\n\n注：需要解锁Bootloader\n\n### 安装Magisk\n\n安装Magisk Delta，这是Magisk的一个好用的第三方分支\n\n![](https://img.keee.top/202306/Screenshot_2023-06-29-13-41-28-085_com.miui.home.webp)\n\n打开后，在主页找到Magisk 安装\n\n![选择Magisk右侧的安装](https://img.keee.top/202306/Screenshot_2023-06-29-13-41-33-805_io.github.huskydg.magisk.webp)\n\n选择选择并修补一个文件，选项不用打钩\n\n在文件管理中找到先前准备的boot.img进行修补\n\n![](https://img.keee.top/202306/Screenshot_2023-06-29-13-41-40-542_io.github.huskydg.magisk.webp)\n\n跑码跑到最后提示Done即为成功\n\n再将修补好的boot.img（形如\"magisk_patched_XXXXX.img\"）拷贝至电脑\n\n将手机关机，同时按住电源键和音量-键，出现Fastboot标志后松手，连接电脑\n\n打开fastboot工具箱中的“打开CMD命令行.bat”\n\n输入fastboot flash boot 修补好的boot镜像\n\n### 配置AccA、Termux\n\n重启手机，安装Termux、AccA\n\n打开Magisk Delta\n\n在设置中开启Magisk Hide和强制使用超级用户列表\n\n在超级用户列表中勾选系统界面、设置、以及Termux和AccA\n\n打开AccA，授权超级用户权限\n\n![](https://img.keee.top/202306/Screenshot_2023-06-29-13-39-28-056_mattecarra.accapp.webp)\n\n在配置一栏启用Default，并编辑开启电池闲置优先模式\n\n![](https://img.keee.top/202306/Screenshot_2023-06-29-13-39-36-325_mattecarra.accapp.webp)\n\n## 配置 Termux\n\n在系统设置中，将Termux的后台管理设为“无限制”\n\n（各品牌UI设计不尽相同，不做阐释）\n\n接下来就比较轻松了，Termux完全可以当成正常的Linux终端使用（补：完全不能！！！\n\n（下载软件时注意架构为ARM64）\n\n## 固定 局域网IP\n\n在手机中WLAN设置中，将IP分配方式设置为静态，记住这一IP\n\n如图\n\n![](https://img.keee.top/202306/Screenshot_2023-06-29-14-02-19-526_com.android.settings.png)\n\n# 部署 Alist\n\nAlist是一个轻量级的网盘管理项目，可以挂载很多网盘\n\n这里尝试部署Alist项目在手机上\n\n首先在Termux中输入\n\n~~~bash\npkg install alist\n~~~\n\n接着输入\n\n~~~bash\nalist admin \n~~~\n\n以确认admin密码\n\n然后启动服务即可\n\n~~~\nalist server\n~~~\n\n这样Alist就运行在5244端口上了\n\n在同一局域网内的设备，可以通过IP:端口的方式打开Alist面板\n\n如192.168.31.77:5244\n\n但是这样只能在内网访问，很不方便，需要将其开放至外网\n\n## 部署内网穿透\n\n推荐服务商[SakuraFrp](https://www.natfrp.com)\n\n提供2条隧道，10Mbps网速，以及内地节点使用\n\n下面以SakuraFrp为例部署内网穿透\n\n## SakuraFrp网页端配置\n\n注册账号并进行实名认证（或者不实名使用日本NTT节点也可）\n\n服务-隧道列表创建隧道，在普通节点中选择一个合适的节点\n\n![](https://img.keee.top/202306/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-29%20141337.webp)\n\n这里我选择了离得比较近的成都电信7节点\n\n隧道类型为TCP隧道，本地IP选择0.0.0.0\n\n本地端口为5244\n\n远程端口随意，之后访问要用到\n\n自动HTTPS一栏要注意，如果选择自动会出现证书错误，影响体验\n\n因此建议输入自己的域名，我这里输入pan.keee.top\n\n到这里就创建成功了\n\n接下来在操作中，选择配置文件，下载配置文件保存，后续要用\n\n## SSL证书配置\n\n由于绑定到了自己的域名下，因此需要自己去申请SSL证书\n\n建议使用[FreeSSL](https://freessl.cn)申请免费证书\n\n![](https://img.keee.top/202306/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-29%20142246.webp)\n\n![](https://img.keee.top/202306/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-29%20142326.webp)\n\n如图选择即可，CSR选择离线生成，用他提供的KeyManager软件导出Nginx格式的证书（包含.key和.crt两个格式的文件）\n\n![](https://img.keee.top/202306/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-29%20142421.webp)\n\n重命名证书为 你的域名.key 和 你的域名.crt\n\n如 pan.keee.top.crt\n\n完成后拷贝到手机备用\n\n## Termux文件交互\n\n安装并打开MT管理器，按要求授权后点击左上角，再点击菜单右上角的三个点添加本地储存，选择Termux即可\n\n![](https://img.keee.top/202306/Screenshot_2023-06-29-14-28-38-868_bin.mt.plus.png)\n\n![](https://img.keee.top/202306/Screenshot_2023-06-29-14-28-49-313_bin.mt.plus.png)\n\n然后将frpc.ini、网站证书一起复制到根目录\n\n### Termux端配置\n\n根据[frpc 基本使用指南 | SakuraFrp 帮助文档 (natfrp.com)](https://doc.natfrp.com/frpc/usage.html)，我们这里要使用的是Frpc（建议按照下列步骤进行，原指南不适用于Termux环境）\n\n首先我们完善一下Termux组件\n\n~~~bash\npkg install wget vim aria2 -y\n~~~\n\n然后下载frpc并授权（可能会遇到TooManyRequests报错，等一会再下载即可）\n\n~~~bash\nwget -O https://getfrp.sh/d/frpc_linux_arm64_noupx\nchmod 755 frpc\n~~~\n\n运行frpc\n\n~~~bash\n./frpc\n~~~\n\n如无误，会在3秒后自动载入配置文件并提示TCP隧道启动成功\n\n并提示你通过某个域名:端口连接隧道\n\n这时回到DNS网站，添加CNAME类型解析，记录值为提示域名\n\n![](https://img.keee.top/202306/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-29%20143609.webp)\n\n但此时alist服务还没有运行，我们还需要将两者同时运行\n\n回到Termux，按Crtl+C退出frpc\n\n输入\n\n~~~bash\nalist server & ./frpc\n~~~\n\n大功告成，接下来通过你绑定的域名打开Alist吧\n\n（记得带端口号\n\n# 2023.8.27更新\nTermux 的文件结构是被魔改过的，而且在权限上有些bug\n\n所以有能力刷机或者root手机的建议不再使用 Termux 部署 linux\n\n可以使用 Ubuntu Touch （推荐）或者 PostmarketOS 等原生Linux发行版，体验会好很多\n\n如果原生Linux对于使用的手机缺少驱动支持，再考虑使用 Linux Deploy 等在chroot容器上运行Linux发行版，体验会好很多\n\n注:\n\n1. Docker需要内核支持，Android手机的内核是基于Linux魔改过的，无法运行Docker，因此在Android上就需要自行修改编译内核（Android手机的内核一般都是开源的）\n\n附小米内核源码仓库 https://github.com/MiCode/Xiaomi_Kernel_OpenSource\n\nclone以后可以自己先编译测试一下，再添加kernelsu、docker等特性编译（不然容易出问题\n\n2. sakurafrp也可以选择其他替代品，如mefrp，在实名认证和带宽方面更友好\n3. 可以用 caddy 自动配置tls，详见另一篇文章","tags":["瞎搞"]},{"title":"A卡、I卡如何愉快地使用UVR5","path":"/posts/37966.html","content":"# DirectML 分支解决方案\n\nUVR5项目在GitHub有人为它做了DirectML分支，能够在支持DX12的GPU上启用GPU加速\n\n项目链接：[Aloereed/ultimatevocalremovergui-directml](https://github.com/Aloereed/ultimatevocalremovergui-directml)\n\n但是该分支目前**仅支持VR Architecture算法**\n\n1. git clone https://github.com/Aloereed/ultimatevocalremovergui-directml.git\n\n2. pip install -r requirements.txt\n\n3. 将已下载的模型拖入model文件夹（或者在GUI中下载）\n\n4. python UVR.py\n\n   \n\n# ROCM 解决方案\n\n注意：此方案仅支持A卡，要求Linux环境（推荐Ubuntu20.04）\n\n首先，安装显卡驱动和ROCM\n\n可以通过其他人制作的一键工具，或者根据他人教程安装\n\n[AMD显卡 Ubuntu 部署Stable DIffusion WebUI基于Pytorch2.0.0 Rocm5.4.2_Ha7nk的博客-CSDN博客](https://blog.csdn.net/u011450629/article/details/129793402)\n\n不过这个教程直接用的自带的python3进行安装（**不推荐**）\n\n建议使用conda创建一个虚拟环境进行安装\n\n[k7212519/ksd-launcher: AMD专用stable-diffusion-webui 图形化安装启动器 KSD-Launcher (github.com)](https://github.com/k7212519/ksd-launcher)\n\n这个执行到安装完成驱动就行，实测可用\n\n首先下载https://github.com/Anjok07/ultimatevocalremovergui/archive/refs/heads/master.zip\n\n```bash\nsudo apt update && sudo apt upgrade\nsudo apt-get update\nsudo apt install ffmpeg\nsudo apt install python3-pip\nsudo apt-get -y install python3-tk\npip3 install -r requirements.txt\n```","tags":["水文"]},{"title":"红米9A “Windows未识别的USB设备” 深度救砖","path":"/posts/34206.html","content":"# 前言\n\n用了一年多的低端机 Redmi 9a 感觉就非常的卡，放假有时间打算刷个 qeui 官改用用\n\n解锁 bootloader 的时候，小米的官解当时还要等 23h，就选择了 mtk 强解 bl\n\n第一次解很顺利，只是 fastboot 被阉割了点，问题不大\n\n然而，线刷降级回 miui12.5.12 时不小心又给 bootloader 锁上了\n\n当再次强解时，不幸翻车\n\n手机黑屏，长按电源键无反应，电脑显示“Windows 未识别的 USB 设备”\n\n（无法进入 rec 或 fastboot\n\n# 过程\n\n## 拆后盖\n\n注：该步骤或许可以省略，在保机器最好先别弄，若深刷步骤无法进行再拆后盖也行\n\n1. **取出 SIM 卡槽**，很重要，不取无法撬开后盖\n\n2. **用刀片或者指甲沿着屏幕边缘撬开后盖**，塑料后盖直接闭着眼睛撬就行\n\n3. **拧开主板保护盖的螺丝，取下电池排线**\n\n   ![如图排线](https://img.keee.top/2023/03/10fdb4ee8a4a072c04df8d3640b875a0.webp)\n\n4. **半合上后盖**，确保可以按到电源键，+/-音量键\n\n## 深度刷机\n\n### 准备\n\n链接：https://pan.quark.cn/s/f58efcfa9bfa\n\n1. 解压后先进入 工具--驱动 安装里面的两个驱动\n2. 打开 SP FLASH TOOL 后，会有如图界面\n3. 导入 DA 文件，直接用 SP FLASH TOOL 里的 MTK_AllInOne_DA.bin 即可\n4. 导入配置文件，该文件在线刷包中的 Image 中，形如 MT6765_Android_scatter.txt 字样的文件\n\n最终效果如图 ![](https://img.keee.top/2023/03/7b0d295deaad1e7786e11c08dacaa761.webp)\n\n### 稳深刷端口\n\nmtk 的深刷端口是不稳定的，但可以用 bypass 工具稳定端口\n\n注：此时手机黑屏，先不插数据线\n\n1. 打开 工具--稳深刷模式\n2. 点击下方 **Disable Auth** 按钮，同时按下手机 **电源键** 和 **+ - 声量键 ** 三个键不放约 10s 后，再插入数据线\n3. 出现如图信息，即为成功，可以进行下一步操作 ![](https://img.keee.top/2023/03/9538242c0d66eb35ab781792009c6e92.webp)\n\n### 开始刷机\n\n稳定了深刷端口后，在设备管理器中应该能看到 mtk 端口，没有那就重来上一个步骤\n\n若一切正常，点击 SP FLASH TOOL 中的 **下载** 按钮，开始刷机（先跑红条，然后马上跑黄条即为正常）\n\n刷完后会提示一个大绿勾，接着拔掉数据线，安装好电池排线和主板保护盖后合上后盖开机即可\n\n\n\n最终成果，顺利开机\n\n![](https://img.keee.top/2023/03/16c524b830d063b9f5dfad52b41f180f.webp)\n\n## 遇到过的问题\n\n###  只跑红条，报错 ERROR *STATUS_EXT_RAM_EXCEPTION* (0xC0050005)\n\n一般为线刷包有问题，推荐使用 miui12.5 的最早期版本\n\n下载地址去 miuirom 找对应型号即可\n\n### 稳深刷端口失败\n\n多试几次就行了（\n\n# 总结\n\n**搞机有风险，刷机需谨慎**\n\n推荐走官解 bl 锁（非小米机型除外\n\n新手不要在晚上刷机（大雾，不然睡不了觉","tags":["瞎折腾"],"categories":["水文"]},{"title":"a卡视频开启插帧功能","path":"/posts/59508.html","content":"# 写在开头\n\n月考结束后又是快乐的网课时光，所以决定水一篇文章证明我还活着（大雾\n\n我们知道一般的视频帧率大多约为24fps，而通过 **Bluesky Frame Rate Converter 视频滤镜**我们可以将24fps补全至60fps ( 甚至更高 ) 以**增加视频流畅度**\n\n当然，这个有硬件限制，那就是必须是GCN架构的AMD GPU\n\n2024更：RDNA架构也可用\n\n---\n\n# 准备\n\n- **GCN架构的GPU（当然要装驱动**\n- [Potplayer播放器](https://potplayer.daum.net/)\n- [Bluesky Frame Rate Converter 视频滤镜](https://bluesky-soft.com/en/BlueskyFRC.html)\n\n## 如何判断我的GPU是不是GCN架构？\n\n一般来说，AMD的独立显卡系列从HD 7000系列开始 ~~(不会还有人在用这么老的显卡吧~~，一直到RX 500系列都是用的GCN架构\n\n核心显卡应该是笔记本系列**锐龙5000系及其以前**的几乎所有型号，台式机系列**除锐龙7000系**所有型号也都是GCN架构\n\n# 配置\n\n在准备并安装好上述软件后，就可以开始我们的配置工作了\n\n## Bluesky FRC配置\n\n首先，打开刚刚安装的Bluesky FRC\n\n按照如图进行配置即可，部分配置可以自己微调\n\n比如:\n\n- Output的输出帧率可以根据自身设备情况调，我的显示器是75Hz所以调到了72p，如果是60Hz的用60p即可\n\n![](https://img.keee.top/202212/eb379e85b24f6148bb73285e71cd272c.webp)\n\n## AMD驱动配置\n\n首先，桌面找个空白处右键，选择**AMD Software: Adrenalin Edition**\n\n![](https://img.keee.top/202212/f60859fd6676575e22d705d0b1992eb7.webp)\n\n打开后，直接在右上角搜索框，输入：\"**音频和视频设置**\"\n\n在**视频配置文件**一项中，选择自定义，然后会出现一个\"**自定义选项**\"\n\n找到**AMD Fluid Motion Video**并开启即可\n\n![](https://img.keee.top/202212/6c6a8604e5b5c9c32560e6264ca423b8.webp)\n\n## Potplayer 配置\n\n随便打开一个视频，右键找到\"**选项**\"\n\n左侧侧边栏选择**滤镜--全局滤镜优先权**\n\n右侧点击**添加系统滤镜**，找到\"**Bluesky Frame Rate Converter**\"并添加\n\n然后，别忘了优先顺序选择为\"**强制使用**\"\n\n![](https://img.keee.top/202212/0f72daacb097fecd29fea4ec4055a764.webp)\n\n# 效果展示\n\n至此，所有配置工作都结束了，来看一下效果如何\n\n![](https://img.keee.top/202212/57454b26023c196664bfa8810d17be47.webp)\n\n可以看到帧率显示“23.976 -> 71.92”，这就代表插帧成功了\n\n当然这种即时插帧效果比较一般，而且像动漫这些还是得24fps看起来才对味\n\n# 深度折腾\n\n以上配置都是基于Potplayer进行的，这个播放器很有意思，可以搭配madVR+LAV实现一些很惊艳的视频显示效果\n\n（当然我这种用着廉价显示器的，看着低码率资源的菜鸡就不用折腾就是了``","tags":["插帧"],"categories":["水文"]},{"title":"高考化学易考易错知识点总结","path":"/posts/10471.html","content":"# 前言\n\n## 笔者的碎碎念\n\n个人感觉高考化学思维要求不高，很多地方只是机械记忆即可。虽然如此，这里面的坑还是太多了\n\n所以就总结一下自己遇到的易错点（顺便也是复习了\n\n## 概述\n\n高中化学教学主要使用4本教材\n\n- 必修一，比较简单，有点初高中衔接的感觉，没有思维障碍（？\n- 选择性必修一，主讲化学反应理论类，比较抽象（个人认为最难的部分\n- 选择性必修二，主讲结构，需要记忆和一定的空间想象能力\n- 选择性必修三，专讲有机物及有机反应，重推理和记忆能力\n\n# 正片\n\n ## 选择题\n\n### T1\n\n这个题目一般是考察基础概念，没有什么难度\n\n### T2-5\n\n考察方程式的书写，一般注意一下几点：\n\n1. 最简单的，配平了没有\n2. 考虑反应能否发生，氧化性？酸性？条件？\n3. 其次，离子方程式考虑各物质的存在形式（石灰乳？石灰水？\n4. 产物在该环境下能否存在（酸性？碱性？\n\n考察阿伏伽德罗常数（感觉易错），注意：\n\n1. 反应可逆与否，诸如合成氨、盐的水解等等\n\n离子共存，没什么特别的\n\n## T6\n\n考察有机物，常见已混概念：\n\n1. 同系物，一定要求同类，不是差个(CH2)就可以！\n2. 分子式，记得环要算不饱和度、有N元素存在H的数量会有变化！\n3. 共面共线问题，注意问的是可能还是一定\n4. 酯类的水解，注意考虑有酚类生成的情况\n5. 未完待续","tags":["学习","化学","总结"],"categories":["学习"]},{"title":"白嫖gpu云服务器部署webui方案汇总","path":"/posts/39808.html","content":"# Paperspace 方案（不推荐）\n\n官网：\n\nhttps://www.paperspace.com/\n\n这里是自己写的终端命令全流程，直接 CV 到终端回车即可\n\n用的 anythingv3.0 的 3.7g 模型，也可以用别的，自己改，但不能超过 4.5g（数据瞎估的，反正太大存不下\n\n```bash\ngit clone https://github.com/AUTOMATIC1111/stable-diffusion-webui\ncd stable-diffusion-webui/\nmkdir -p /notebooks/stable-diffusion-webui/models/Stable-diffusion /notebooks/stable-diffusion-webui/models/hypernetworks\nwget  -P /notebooks/stable-diffusion-webui/models/Stable-diffusion/  \"https://huggingface.co/Linaqruf/anything-v3.0/resolve/main/Anything-V3.0-pruned.ckpt\"\nCOMMANDLINE_ARGS=\"--exit\" REQS_FILE=\"requirements.txt\" python launch.py\npython lauch.py --share\n```\n最后一步的 \"INFO bore_cli:: client: listening at bore.pub: xxxxx\" 中的 pore.pub: xxxxx 就是生成的隧道链接，直接打开即可\n\n只能连续用 6h 用完了重启即可，没有限额\n\n# Google Colab 方案（不可用）\n\n# Kaggle（推荐）\n\n官网：https://www.kaggle.com\n\n直接创建一个空白的 notebook 即可\n\n记得验证手机号以启用 GPU（推荐使用 T4*2 并使用半精度）和 Internet 链接\n\n\n```bash\ngit clone https://github.com/AUTOMATIC1111/stable-diffusion-webui\ncd stable-diffusion-webui/\nmkdir -p /kaggle/working/stable-diffusion-webui/models/Stable-diffusion /notebooks/stable-diffusion-webui/models/hypernetworks\nwget  -P /kaggle/working/stable-diffusion-webui/models/Stable-diffusion/  \"https://huggingface.co/gsdf/Counterfeit-V3.0/resolve/main/Counterfeit-V3.0_fp16.safetensors\"\nCOMMANDLINE_ARGS=\"--exit\" REQS_FILE=\"requirements.txt\" python launch.py\npython lauch.py --share\n```\n注：模型用的是 Counterfeit-V3.0_fp16，感觉还不错\n![2381107994](https://bu.dusays.com/2024/08/31/66d27fcbdfb59.png)","tags":["白嫖","GPU云服务器"],"categories":["水文"]},{"title":"给你的A卡换张皮--强刷vBIOS开核","path":"/posts/59890.html","content":"# 写在开头\n\n开核，一个AMD的产品特有的词汇。\n\n对于CPU而言，在Zen架构之前的系列里，部分特定批次的CPU可以在主板BIOS中打开那些被AMD屏蔽掉的可用核心（都是稀缺货\n\n对于GPU而言，同样也是打开AMD屏蔽掉的那些流处理器，不过显卡不能通过像CPU那样调节BIOS轻松实现，但是它一般具有普适性\n\n即只要是这个核心的显卡，就能通过强刷vBIOS来打开被屏蔽的流处理器\n\n（有时为了让黑苹果免驱（如RX580 2048SP刷RX570），为了变身专业卡（Vega56刷WX8200）等，我们也许也会称这种行为叫开核，但这并不是严格意义上的开核，这顶多算换了个皮\n\n# 实践前提\n\n## 确认条件\n\n首先，你先要有一块能够开核（或者开核有实际意义的）显卡\n\n一般来说，有如下常见型号:（箭头具有传递性，也可以反着刷，只要你愿意XD）\n\n1. RX470D[^1]-->RX470-->RX580 2048SP\n\n2. RX460 --> RX560\n\n3. RX560d[^1] --> RX560\n\n4. RX480 --> RX580 --> RX590GME\n\n5. RX Vega56 --> RX Vega64\n\n[^1]:\"可以产生额外的流处理器\"\n\n\n\n## 准备vBIOS\n刷VBIOS具有极高的风险，要随时做好刷黑变砖的准备!\n\n1.第一步打开[GPU-Z ](https://www.techpowerup.com/download/techpowerup-gpu-z/)\"（如果没有，曾经作为一名图钉，我推荐[图吧工具箱](http://www.tbtool.cn/)，doge）\n\n如果没有问题的话，你应该看到这个界面\n\n![GPU-Z](https://img.keee.top/202212/cdbd0cb24a4c2126ae7fea631d1405b6.webp)\n\n这是对你现在使用的VBIOS的备份，非常重要！！\n\n2.点击如图标出的小箭头，选择一个你可以找到的地方保存下来\n\n（同时记住标红的几个参数，图中“4096MB”处对应你的显存大小，“Hynix”对于你的显存品牌\n\n3.接下来，进入[VGA Bios Collection | TechPowerUp](https://www.techpowerup.com/vgabios/)检索适合你的显卡的VBIOS\n\n这里简单说下选择VBIOS的原则：\n\n1. 核心一样（RX480 4G-->RX580 4G是允许的，RX460 --> RX580是不被允许的）\n2. 显存容量，品牌一样（RX480 4G尔必达 --> RX480 4G三星不被允许，RX480 4G海力士 --> RX580 4G海力士 是允许的）\n\n如图就是RX480 4G（海力士）对应的一个比较好的VBIOS（高亮的地方均符合要求\n\n![](https://img.keee.top/202212/0c0f91c8b63cabf819cb2264bfdb2699.jpg)\n\n---\n\n\n\n# 刷入vBIOS\n\n1. 到[AMDVBFlash / ATI ATIFlash (3.31) Download | TechPowerUp](https://www.techpowerup.com/download/ati-atiflash/)下载软件 AMDVBFlash 并解压至一个你找得到的地方\n\n2. 将提前准备的待刷入的vBIOS，与amdvbflash放置在同一文件夹\n\n3. 右键，选择“在此处打开命令窗口”，输入\n\n   amdvbflash.exe -p -f 0 xxx.rom\n\n   其中，xxx.rom为准备的vBIOS\n\n4. 如果一切正常，他应该会提示你“Restart System To Complete VBIOS Update.”\n\n   ![](https://i0.hdslb.com/bfs/album/c66ffba0beca04d8bc6d2816544a0ad3c8246cbc.jpg)\n\n5. 重启电脑后，打开GPU-Z看看效果如何\n\n   如图，是我用RX480 4G刷的RX580 4G的成品图\n\n![变身RX580](https://img.keee.top/202212/851b780760bcef4a1530a2ac2088c32f.webp)\n\n# 刷黑救砖\n\n刷vBIOS是一件有极大风险的事（失败了显卡直接变砖\n\n不过一般而言，仅是刷错了vBIOS的话，显卡都还能救回来\n\n## 对于有双vBIOS开关的卡\n\n有双vBIOS开关的卡救卡难度是最低的\n\n如果你发现刷入vBIOS后开机不过自检/黑屏，断电关机，切换vBIOS开关重启\n\n进入系统后，直接切换vBIOS开关，依照[刷入vBIOS](#刷入vBIOS)的方法再次强刷回先前备份的原vBIOS\n\n（因此说备份vBIOS很重要！）\n\n## 对于没双vBIOS开关的\n\n可以在DOS环境下盲刷，具体教程：\n\nhttps://tieba.baidu.com/p/5500803523\n\n可以在PE（Windows）环境下盲刷，对电脑要有相当的熟悉才可以做到：\n\nhttps://tieba.baidu.com/p/6728462628\n\n还有一种要用到编程器，这里就不涉及了（我没有也不会\n\n# 最后\n\n刷vBIOS有意思归有意思，但他最后有没有用嘛，就是另一回事了\n\n如我的RX480 4G刷上RX580 4G后\n\n待机功耗52W --> 90W\n\n游戏功耗 90Ww --> 148W\n\n功耗增加了50%以上，然而性能反而下降了10%左右\n\n因为虽然RX480 和RX580本质上没什么区别，都是魔改GCN北极星架构\n\n但是RX480供电为8pin TDP约120W，而RX580为8+6pin TDP约180W\n\n刷入RX580的vBIOS后，针对RX480设计的供电和散热纷纷撞墙，因此性能不增反减\n\n不过也不失为一种打发时间的好方法doge","tags":["电脑","显卡"],"categories":["水文"]},{"title":"电脑续命四年计划(3)-CPU升级2667v2","path":"/posts/62402.html","content":"<script defer src=\"https://cdn.jsdmirror.com/npm/echarts@5.4.0/dist/echarts.min.js\" data-pjax type=\"text/javascript\"></script>\n\n# 写在开头\n\n这篇水文原本应该很久之前就动笔的，不过因为插进来个可恶的线上半期被迫延期\n\n实际上，我也不是第一次换这台电脑的CPU了，总的路线图如下\n\nE5-2670 --> E5-1620v2 --> E5-2667v2\n\n第一次换呢，是为了提升单核性能，牺牲了多核性能（因为当时玩的游戏多核优化都很烂）\n\n这一次换就是既要多核性能，还要单核性能（因此2667v2在当时是相当昂贵的U\n\n---\n\n# CPU-Z参数图\n\n## E5-1620V2\n\n<img src=\"https://i0.hdslb.com/bfs/album/9aae0b9ca05d1f30ca864a4883a02b0a284057bb.webp\" alt = \"1620v2\" referrerPolicy=\"no-referrer\" />\n\nE5-1620v2参数实际上标得很迷惑，TDP标到了130W，但实际测试中顶天跑个90W（石锤了，1620v2就是i7-3770马甲）\n\n## E5-2667V2\n\n![2667v2](https://i0.hdslb.com/bfs/album/ab3cf21546741c92dc6f2d07f2c8de21b51db7c9.webp)\n\n可以看到实际上两块CPU因为同代产品，都是用的Ivy-bridge架构（也就是3代酷睿架构），因此IPC应该相近\n\n且2667v2的睿频跑的要比1620v2要低一些（1620v2全核3.7GHz，2667V2全核3.6GHz）\n\n然而实测下来，2667v2的单线程跑分比1620v2还高\n\n猜测有可能是因为，2667v2有比1620v2大得多的三级缓存（不过一般来说，三缓只对游戏体验的有较大的影响\n\n---\n\n# 不严谨理论测试\n<div id=\"cpu-test1\" style=\"width: 85%;height:400px;\"></div>\n<script data-pjax>\nvar e1 = function(){\n  var myChart = echarts.init(document.getElementById('cpu-test1'));\nvar option = {\n  title: {\n          text: 'CPU理论性能测试成绩'\n        },\n  legend: {},\n  tooltip: {},\n  dataset: {\n    dimensions: ['product', 'E5-1620v2', 'E5-2667v2', 'i5-10400F'],\n    source: [\n      {\n        product: 'CPU-Z单线程',\n        'E5-1620v2': 372.3,\n        'E5-2667v2': 376.4,\n        'i5-10400F': 479.1\n      },\n      {\n        product: 'CPU-Z多线程',\n        'E5-1620v2': 1862,\n        'E5-2667v2': 3536.8,\n        'i5-10400F': 3623.4\n      },\n      {\n        product: 'R15多线程',\n        'E5-1620v2': 621,\n        'E5-2667v2': 1141,\n        'i5-10400F': 1291\n      },\n      {\n        product: '国际象棋(取1/10)',\n        'E5-1620v2': 1331.4,\n        'E5-2667v2': 2202.2,\n        'i5-10400F': 2246.8\n      }\n    ]\n  },\n  xAxis: { type: 'category' },\n  yAxis: {},\n  // Declare several bar series, each will be mapped\n  // to a column of dataset.source by default.\n  series: [{ type: 'bar' }, { type: 'bar' }, { type: 'bar' }]\n};\n myChart.setOption(option);\n  // 刷新调整\n  window.onresize = function () {\n    myChart.resize();\n  }\n}\ne1();\n    document.addEventListener('pjax:complete', function () {\n        e1();\n    });\n</script>\n\n这里为了方便对比洋垃圾v2与现在CPU性能差距，引入了一个I5-10400F的参考对比数据\n\n不过不难看出，E5-2667v2几乎可以跟i5-10400f打个五五开（当然IPC是远远不如，尤其是面对新出的13代\n\n而理论多线程性能约为1620v2的两倍\n\n---\n\n# 不严谨游戏测试\n\n## 战地1 64人模式\n\n画质设置: 高\n\n环境温度:不知道\n\n### E5-1620v2\n\n![](https://i0.hdslb.com/bfs/album/d6cf9a56ff0e11458243180771a60b1bb66a0fd9.webp)\n\n在非交战区域，**FPS大约在69帧**左右，勉强能玩\n\nCPU占用跑到了79%，后台基本上不能挂东西\n\n之前就某一次游戏全程掉帧，预估平均fps只有20左右~~（结果发现是后台挂了<a href = \"https://oi.saiodgm.gq\">@Saiodgm</a>的网站没有休眠，把CPU吃到了99%~~\n\nGPU跑到了100%，还是很给力的（GPU一般都最好跑满，跑不满要么是优化问题，要么是其他硬件有瓶颈限制了发挥）\n\n### E5-2667V2\n\n![E5-2667v2](https://i0.hdslb.com/bfs/album/51204f2e0537e138d55131495ac9b2eee9673f76.webp)\n\n在同一场景下，E5-2667v2为**76fps**，要比E5-1620v2高出7fps\n\n而且CPU的占用仅有33%（缺点是功耗的温度都有显著上升\n\n## 战地5 64人线上模式\n\n战地系列游戏特有的大战场场景非常适合用来测试CPU实际性能（而且优化做的很好，不像某P社只会用CPU0\n\n在战地5中对CPU性能的要求比前作战地1还要高得多\n\n画质设置：中（开启DX12和未来帧渲染，关闭垂直同步）\n\n（原本想开高的，但是开高的话就爆显存了。。。）\n\n环境温度：不知道\n\n### E5-1620V2\n\n![E5-1620v2](https://i0.hdslb.com/bfs/album/290712973e1b65cab2ecb55c55fc72c7b11a5a16.webp)\n\n野外非交战区域，**FPS大约为76**\n\n此时CPU占用已经跑到97%了，已经接近满载，后台几乎不能挂东西（否则会严重掉帧\n\nGPU跑到了98%，也还不错，基本性能是发挥到位了的\n\n游戏过程偶尔会掉帧，在中心交战区域尤其显著\n\n（这就是为啥我打战地1却不玩战地5的部分原因\n\n（当然战地5的画风和武器手感不喜欢也是\n\n### E5-2667V2\n\n![](https://i0.hdslb.com/bfs/album/45c7f0027e573c4731f11408752c5fdacbc567e9.webp)\n\n\n\n同样野外非交战场景，**FPS大约为100**\n\n遇到对CPU性能要求更高的战地5的时候，2667v2的双倍性能就得到了充分体现\n\n这里CPU占用率仅为48%（后台可以随便挂了属于是），GPU占用率跑到了100%\n\n帧数也相比1620v2有很大进步，76FPS --> 100FPS\n\n~~CPU功耗和温度也获得了显著提升~~\n\n### 表格汇总\n<div id=\"cpu-test2\" style=\"width: 85%;height:400px;\"></div>\n<script data-pjax=\"\" type=\"text/javascript\">\nvar myChart = echarts.init(document.getElementById('cpu-test2'));\nvar option = {\n  title: {\n          text: 'CPU实际游戏帧率'\n        },\n  legend: {},\n  tooltip: {},\n  dataset: {\n    dimensions: ['product', 'E5-1620v2', 'E5-2667v2'],\n    source: [\n      {\n        product: '战地1',\n        'E5-1620v2': 69,\n        'E5-2667v2': 78\n      },\n      {\n        product: '战地5',\n        'E5-1620v2': 76,\n        'E5-2667v2': 100\n      }\n    ]\n  },\n  xAxis: { type: 'category' },\n  yAxis: {},\n  // Declare several bar series, each will be mapped\n  // to a column of dataset.source by default.\n  series: [{ type: 'bar' }, { type: 'bar' }, { type: 'bar' }]\n};\n myChart.setOption(option);\n  // 刷新调整\n  window.onresize = function () {\n    myChart.resize();\n  }\n</script>\n\n---\n\n# 总结\n\n总的来说，这次升级还是非常值得的，不过这也仅限于升级来说\n\n目前1620v2市场价90元左右（市场上需求真的很小，我挂咸鱼很久都卖不出去\n\n2667v2市场价180元左右（还是最近价格大跳水才有的性价比，几个月前的价格是现在的好几倍\n\n当然，如果你是全新装机，X79/X99这类**洋垃圾一定要划入黑名单**，老平台在最近的新架构面前没有**任何性价比**","tags":["电脑","生活","评测"],"categories":["电脑续命四年计划"]},{"title":"一些奇怪的想法","path":"/posts/27613.html","content":"# 写在开头\n\n​\temmm...这个页面呢, 主要是用来记录一些平时脑子里突然产生的一些想法或者说问题 ~~(像什么上课走神的时候)~~\n\n这些可能有简洁明了的答案, 但也有可能没有,  但我一定尽力去寻找并作一些分享吧\n\n\n\n# Part1 摩擦起电的一些思考\n\n​\t物理很早以前就已经讲了摩擦起电了, 但是这个内容是在更深层次的化学知识学习之前讲的, 并且对具体原理并没有作要求。而我们在学习了更多化学知识后， 会发现有些内容是难以理解的\n\n## 课本原文的引发\n\n> 两个物体互相摩擦时，因为不同物体的原子核束缚核外电子的本领不同，所以其中必定有一个物体失去一些电子，另一个物体得到多余的电子。\n\n​\t课本原文似乎在最初学习时是可以理解的, 但学过一点点化学后就不禁会有疑问:\n\n1. **许多物质是由分子构成的, 这些分子的\"对电子的束缚能力\"又跟什么有关**\n2. **许多物质化学构成中各原子是保持着相对稳定结构的，而摩擦起电的电子得失不会打破这种相对稳定结构引起物质的不稳定吗**（而我们又知道摩擦起电被认为是物理变化）\n\n## 摩擦起电的电子得失问题\n\n### Generic Electron-Cloud-Potential模型\n\n这里需要查询一下万能的维基百科 [摩擦电效应](https://en.wikipedia.org/wiki/Triboelectric_effect#Sparks)\n\n>Although the part 'tribo-' comes from the Greek for \"rubbing\", *τρίβω* (τριβή: friction), the two materials only need to come into contact for electrons to be exchanged. After coming into contact, a chemical bond is formed between parts of the two surfaces, called [adhesion](https://en.wikipedia.org/wiki/Adhesion), and charges move from one material to the other to equalize their [electrochemical potential](https://en.wikipedia.org/wiki/Electrochemical_potential). This is what creates the net charge imbalance between the objects. When separated, some of the bonded atoms have a tendency to keep extra electrons, and some a tendency to give them away, though the imbalance will be partially destroyed by [tunneling](https://en.wikipedia.org/wiki/Quantum_tunneling) or [electrical breakdown](https://en.wikipedia.org/wiki/Electrical_breakdown) (usually [corona discharge](https://en.wikipedia.org/wiki/Corona_discharge)). In addition, some materials may exchange ions of differing mobility, or exchange charged fragments of larger molecules.\n\n> The triboelectric effect is related to [friction](https://en.wikipedia.org/wiki/Friction) only because they both involve [adhesion](https://en.wikipedia.org/wiki/Adhesion). However, the effect is greatly enhanced by rubbing the materials together, as they touch and separate many times.[[17\\]](https://en.wikipedia.org/wiki/Triboelectric_effect#cite_note-DiazFelix-Navarro2004-17)\n\n> For surfaces with differing geometry, rubbing may also lead to heating of protrusions, causing [pyroelectric](https://en.wikipedia.org/wiki/Pyroelectricity) charge separation which may add to the existing [contact electrification](https://en.wikipedia.org/wiki/Contact_electrification), or which may oppose the existing polarity. Surface nano-effects are not well understood, and the [atomic force microscope](https://en.wikipedia.org/wiki/Atomic_force_microscope) has enabled rapid progress in this field of physics.\n\n维基百科大概的意思是说:\n\n这里有一个解释一般的摩擦起电的模型被称为**generic electron-cloud-potential模型**![](https://cdn.afdelivr.top/npm/cqlkc_img@1.0.14/img/Electron_cloud_model.webp)\n\n讲的就是，两种材料制成的物质只需要紧密接触(并不一定需要摩擦) , 电子即可发生交换\n\n。在**低于原子平衡距离**接触后，两个表面的部分之间通过**电子云的重叠**形成**化学键** (这里可以是共价键也可以是离子键)。\n\n而施加的外力，可以进一步**减小**这两材料间两个原子间的距离（也就是键长），这种电子云的高度重叠降低两原子的**能垒**促使其发生电子的转移。\n\n此时若使两原子分离(摩擦实际上就是不断接触又分离的过程)，转移后的电子就保留了下来，形成了静电荷。\n\n---\n\n### 理论后的思考\n\n可以看到这个非常高大上的理论解释了为什么会有电子的转移，但这个并没有问答上面的问题\n\n而且随着研究的深入， 问题的探究深度已经远远超出了我的预期\n\n这里提供一篇大佬的相关论文 [On the Electron-Transfer Mechanism in the ContactElectrification Effect](https://cdn.afdelivr.top/npm/cqlkc_assets@1.0.2/pdf/ce.pdf)\n\n说了这么多， 对于一般的题目来说只需要记住结论就可以了，千万不要想太多🤣\n\n# Part2 未完待续","tags":["奇思妙想","胡扯"],"categories":["胡扯区"]},{"title":"电脑续命四年计划(2)-PE4010两个月使用体验","path":"/posts/36101.html","content":"# 写在开头\n  这个使用体验为什么被划进了四年计划里面?\n\n实际上是因为这块海力士的PE4010是要顶掉挂掉的机械硬盘之前所扮演的角色:\n- 存游戏: 主盘480g, 实际可用容量不足300G, 用起来难受\n- 存不重要文件: 毕竟还是块洋垃圾, 不敢装重要文件(\n  \n---\n# 使用体验\n\n## 购入经历\n  这块盘是在2022年8月21号购入 (正好在短短的暑假第二阶段的开头)\n\n之前, 这台电脑一直是 2TB机械 + 480G SATA固态的搭配\n\n![而我上次发说说已经是2018年了...](https://cdn.jsdmirror.com/npm/cqlkc_img@1.0.11/img/qq-zone-1.webp)\n\n当然机械硬盘上面所有的数据也是全部挂掉了(但是大多都是游戏)\n\n原来的游戏还需要一块盘来储存, 购入一块新硬盘的需求就很明显了\n\n经过一些考虑, 最终选择了新靠岸的大船货PE4010:\n![现在已经买不到了](https://cdn.jsdmirror.com/npm/cqlkc_img@1.0.9/img/pe4010-1.webp)\n\n商家说这块盘的写入量10t-20t左右, 通电时间100h以下(是不是清零盘存疑)\n\n不过据网上的说法, 这块盘采用的主控马牌88SS1093是不能清零的, 无论如何这个价格要什么自行车\n\n而为什么就写了10t就从服务器流入了市场,网上传言的解释是：\n> PSA PE4010 和 PE6110 有极为严重的品控问题，具体表现为因焊料和 PCB 选材问题，在相对不够干净的环境下会出现铜绿腐蚀穿 PCB 和 NAND 的情况\n>南方高湿度的气候会显著加速这个过程\n>\n>且厂商无妥善解决方案\n\n---\n\n## 实物\n\n![转接卡+散热片完全体](https://cdn.jsdmirror.com/npm/cqlkc_img@1.0.10/img/DSC_0379.webp)\n\n而受限于X79的扩展性 (没有m.2 22110插槽, 也不支持NVME引导)\n\n所以这块盘的定位就只能是从盘 (从盘性能比主盘好就离谱)\n\n只能用pcie转接卡, 并且紧贴显卡这一大热源, 而这个马牌主控本身就有惊人的发热量(裸奔情况下温度能破90)\n\n![没对焦好的主控特写](https://cdn.jsdmirror.com/npm/cqlkc_img@1.0.10/img/DSC_0383.webp)\n\n为此特地买了散热片专门给主控散热, 日常使用温度理论上就不会撞墙\n\n## 不严谨测试\n\n话不多说, 先看一下基本信息\n\n![Diskinfo](https://cdn.jsdmirror.com/npm/cqlkc_img@1.0.10/img/a2.webp)\n\n由于在此之前, 博主已经用了将近两个月了, 这个写入状况还是很OK的\n\n再给它来一个测速:\n\n![不严谨测速](https://cdn.jsdmirror.com/npm/cqlkc_img@1.0.10/img/a3.webp)\n\n性能表现实际上很一般, 不过已经比主盘TC10 480G和机械硬盘好太多了(已经知足了\n\n作为对比, 我们来看一下TC10孱弱的性能表现\n\n![乐色](https://cdn.jsdmirror.com/npm/cqlkc_img@1.0.12/img/tc10.webp)\n\n---\n\n# 总结\n\n  海力士PE4010 960G这块盘在当时250元左右的时候是性价比最高的, 我上车的时候就已经算晚了\n\n  至于现在更不推荐将PE4010作为 960G 固态仓库盘\n\n  一是它的2字头价格已经一去不复返了, 二是它稳定性缺乏保障\n\n  现在一般推荐加个几十上 pdd 的 SN350 1TB, 保修什么的都是实打实的, 而且性能作为仓库盘也足够了\n\n# 2023-08更新\n  这下成大怨种了，现在2t的全新全速3.0固态盘也才400![](00F3ED01.png)","tags":["电脑","生活","评测"],"categories":["电脑续命四年计划"]},{"title":"电脑续命四年计划(0)-电脑情况概述","path":"/posts/26610.html","content":"# 写在开头\n  不知不觉, 手上这台电脑也已经服役将近6年(2017年1月购入并组装) 但是这台电脑目前的性能和工作状况一言难尽\n\n且目前来看, 估计一直到高考结束(这期间有4年,故得名\"四年计划\"), 这台电脑都不可能有更新主要配件的机会\n\n所以，保证这台电脑正常工作就显得至关重要\n\n# 配置概览\n  ## 简单介绍\n  先上图\n  ![](https://cdn.jsdmirror.com/npm/cqlkc_img@1.0.5/img/a5.webp)\n\n  可以看到这套配置就一纯种洋垃圾配置, 几乎包含了洋垃圾的全部要素:\n  - E5-1620v2 服务器cpu, 差不多是i7-3770的马甲(不过价格低很多\n  - HUANAN X79 华南的寨板, 不过这块X79是用的原生X79南桥, 不是用B75魔改的(质量还不错?\n  - 4GB REG ECC DDR3 1333MHz *4  三星的服务器内存, 由于家用主板用不了recc所以价格相当的便宜\n  - 海力士PE4010 960G(HFS9600GD0TEG) 也是捡的服务器SSD\n  - 恺侠tc10 480G 这个属于是没做功课, pdd上随便乱买的, 性价比一般\n\n  至于为什么要配这样一套配置，就得把时间拉回2017年1月了...(发现自己竟然这么早就在搞这个东西)\n\n## 为什么不换平台？\n\n​\t你可能会说，怎么2202年了还搁着用X79呢？12代i3什么的不比这个老掉牙的E5香的多？\n\n实际上，目前如果购入一套新平台的话，没有1000+预算根本拿不下来。（现有所有零件基本均不适配\n\n并且目前X79的相关二手价格奇低无比（4g内存条价格可能还不够出运费\n\n奇低的二手价格导致了换平台的高成本，但是如果换一个思路想：\n\n​\t那它是不是也降低了我的**升级成本**呢？\n\n答案是很显然的，目前情况如下：\n\n- 16g 1866recc单条只要50（64g内存指日可待？！\n- e5-2667v2单价200 （而e5-1620v2二手还能卖100\n\n所以短期来看，低投入的小修小补应该是最优解\n\n  ## 背景原因\n\n  在2017年的时候, AMD的锐龙系列还没有发售, 推土机之类的模块化架构IPC一言难尽\n\n  家用平台基本只能用intel的酷睿系列\n\n  由于缺乏竞争, 这个板u一套的价格嘛就一言难尽了\n\n  最为重要的是, 2017年内存市场的爆炸(感谢生产线火灾的馈赠\n\n  ![内存价格飙升](https://cdn.jsdmirror.com/npm/cqlkc_img@1.0.6/img/memory-increasing-price.webp)\n\n  但是随着一批批大船的靠岸, 大量被称为\"洋垃圾\"的淘汰服务器配件涌入国内市场, 包括但不限于:\n  - 服务器内存(REGECC)\n  - 服务器主板(X79等)\n  - 服务器CPU(E5/E3等)\n  - ...\n\n  博主当时选择的是e5-2670 , 8C16T 花了约420性价比还是很足的(一个缺点是单核性能较为拉跨)\n\n  4*4G REGECC也是相当的便宜,一根估计也就几十块钱(而且有4通道加成)\n\n  还有显卡用的是GTX780Ti   不过后来换成了RX480, 下篇文章有讲\n\n## 一些小插曲\n\n不过便宜也有代价， 当时电脑最开始组装好后出现了一个致命问题困扰了我好几个月（且十分难以排查\n\n这里描述一下现象，看一下你能不能猜出来是什么问题:\n\n- CPU正常鲁大师(均为旧版)跑分应为11.9w，结果实际只有9w\n- GPU正常鲁大师跑分应为18.9w，结果只有11w\n- 游戏内帧数如GTA5只有个位数FPS，MC表现要好一些(至少能上60fps)\n- 游戏内GPU和CPU都跑不满，既没有爆内存也没有爆显存\n\n揭秘：有一根**内存条**有问题，他处于一个半正常工作状态(能点亮过自检，但有问题)\n\n这是在某次开机的时候，这个内存条直接开摆连自检都过不了，我就随便拿了两根家用内存条去测试\n\n结果开机后跑分时发现：跑分又**恢复正常了?!**\n\n可以直接断定内存条有问题，直接换下来即可（不过这个问题时隔5年又复发了，但我已经有经验也不就慌了...\n\n# 运行现状\n  ## 一张图就能说明一切\n  ![机箱侧面图](https://cdn.jsdmirror.com/npm/cqlkc_img@1.0.7/img/DSC_0385.webp)\n\n  **要素盘点:**\n  - 缺乏安全感的水冷(水冷:从入门到索赔无门)\n  - 敞开体系运行(大号吸尘器)\n  - 灵 魂 走 线(哪天开不了机了记得看一下跳线是不是松了)\n  - 装饰兼玩具用光驱(没接SATA数据线,只连了电源线,等开机的时候按着玩..)\n  - 没有螺丝固定的风扇和固态(丑)\n  - 连接不全的跳线(只连了开机和重启跳线)\n\n以这个运行状况, 这电脑能用5年就已经是奇迹了(逃\n# 升级计划\n  - [x] 把CPU换成E5-2667v2(4核e5打战地太捉急了)\n  - [ ] 换下令人缺乏安全感的120水冷(已经过了质保期了...)\n  - [x] 整理一下走线\n  - [ ] ...","tags":["电脑","生活"],"categories":["电脑续命四年计划"]},{"title":"电脑续命四年计划(1)-给老显卡改善一下散热条件","path":"/posts/23205.html","content":"# 写在开头\n## 为什么要换成RX484  \n\n不知不觉，电脑上的这块RX480 4G也用了快5年了 ~~(能用5年就是奇迹)~~\n\n实际上这台电脑最开始用的不是RX484, 最开始是用的老卡皇gtx780ti 3G\n\n这gtx780ti呢, 给人最显著的感受就是: **这功耗真的大啊！！**\n\n为此电源是直接给到了额定700W, 用是可以用了, 但是老开普勒架构的表现也是不尽如人意:\n  - 功耗问题：游戏时可以达到300W的功耗，这电费和温度谁顶得住\n  - 优化问题: 老架构对新游戏支持不够好\n\n## 换了RX484后的表现\n\n综合了一些考虑以后， 果断在咸鱼上面卖掉换了RX484(并小赚几百)\n\n  至于RX484, 一看它的参数:\n  - 功耗只有100W\n  - 有14nm制程加持(~~想必这温度表现一定很好吧!~~)\n\n结果这块RX484温度表现更为惊人, 正常游戏中就可以跑到780ti都难以企及的80度以上\n\n权宜之计就是机箱不关侧盖，结果就是变身吸尘器+电热炉\n\n\n这样一直用到了2021年...\n\n  到了2021年的时候, 大家都知道又一轮大规模的矿潮来了, 一时间各平台的显卡价格飞涨\n\n甚至包括RX480 4G这块挖不了ETH的老兵, 当时挂咸鱼上时价格直接给到了2000元\n\n但是由于我当时沉迷于游戏之中, 确实不愿意将显卡出手(谁知道什么时候矿难呢?\n\n结果, 过了一周显卡价格直接跳水, 再过一两个月2000元就能买到新的丐版RX6600XT了\n\n(追悔莫及中...&#x1F602;)\n\n---\n\n不过既然当时没有抛弃它, 未来也很难有机会甩掉它了\n\n所以,我们的目标肯定不是只用5年就结束了, 既然叫四年计划目标就是尽量让它再战四年, (~~让高中还能继续打游戏~~)\n\n---\n\n# 第一阶段: 换硅脂\n\n简简单单换个硅脂, 毕竟干其他的, 我条件也有限。\n\n现在用的硅脂是估计一年前左右买的便宜大碗的高导GD007(几块钱就有十多克), 对比一下7921甚至TFX, 这个性价比简直不能太高\n\n但是这种便宜的硅脂一个很大的问题就是寿命有限, 越到后面这散热性能就越令人捉急\n\n  ## 初始表现\n    测试条件: 敞开体系, 室温19℃\n\n  驱动日用设置参数如图\n  ![驱动参数](https://cdn.jsdmirror.com/npm/cqlkc_img@1.0.5/img/a6.webp)\n\n  为了对比, 先跑一个甜甜圈看一下GD007的表现\n  ![直逼80度的骇人散热](https://cdn.jsdmirror.com/npm/cqlkc_img@1.0.4/img/a1.webp)\n  ![直逼112A的骇人电流](https://cdn.jsdmirror.com/npm/cqlkc_img@1.0.4/img/a7.webp)\n\n  可以看到核心温度基本稳定在79度, 功耗107W左右, 我就很疑惑这真的能用4年吗\n\n  ## 更换硅脂\n\n  先拆下这块久经沙场的RX480\n  ![黑狼丐中丐](https://cdn.jsdmirror.com/npm/cqlkc_img@1.0.5/img/DSC_0377.webp)\n\n  拧掉背板上的几颗螺丝后，就看见PCB板真面目了\n  ![PCB局部图](https://cdn.jsdmirror.com/npm/cqlkc_img@1.0.5/img/DSC_0378.webp)\n\n  把核心上原有的硅脂擦干净以后\n\n  (忽视旁边溢出的硅脂和有些焦黄的显存，这个核心还是很好看的\n\n  挤上硅脂7921, 插电正常亮机\n\n  ## 7921的表现\n  保持显卡驱动设置不变再跑一次\n\n  ![7921的表现](https://cdn.jsdmirror.com/npm/cqlkc_img@1.0.5/img/a4.webp)\n\n  emmmmmm...这个好像并没有什么变化啊\n\n  不过核心我们一般认为还是很耐艹的, 76度也问题不大(麻痹自己中...)\n# 第二阶段: 降压但不超频\n  ## 微调电压\n  ### 为什么?\n\n  我们知道很多玩家拿到显卡后, 最喜欢做的就是看下显卡的体质来波降压超频(甚至是加压超频)\n\n  根据半导体芯片的功耗公式: (a,b对于同一芯片为常量,F指频率)\n\n  $$ P=a*b*F*U^2 $$ \n\n  可以看到电压在其中是二次项, 调整电压的大小对于功耗来说有举足轻重的作用(再辅以降频)\n  可以达到降低功耗进而 (~~践行低碳生活~~) 降低散热压力\n\n  ### 实际操作\n\n  实际操作起来就是一点点地去降低电压, 比如:\n\n  我设置1150mV能过压测,我设置1130mV也能过压测,我设置1101mV还能过压测\n\n  但是如果跳到1100mV显卡终于绷不住了,那你就成功地把握住了显卡的底线1101mV(大雾)\n\n  不过并不建议就把电压设置为1101mV, 在低负载的时候可能会出问题......\n\n  这里是我自己测好的最优电压状态\n  ![](https://cdn.jsdmirror.com/npm/cqlkc_img@1.0.8/img/test1.webp)\n\n  ## 风扇策略\n\n  这个的话就不展开了, 风扇策略实际上是取决于使用者本身的底线(对噪音的忍耐程度)\n\n  不过我都把机箱侧盖扔了, 噪音什么的也不在乎, 直接往上拉就行了\n\n# 第三阶段:未完待续\n\n\n# To Do List:\n - [ ] 给裸露的显存加一下散热片\n - [ ] 给mos管加导热垫","tags":["电脑","生活"],"categories":["电脑续命四年计划"]},{"title":"Hello World","path":"/posts/4a17b156.html","content":"# 不弃坑，坚持写\n本站从10月2日也就正式启用了，希望用这个官方生成的helloworld来作为纪念吧。\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)"},{"path":"/manifest.json","content":"{   \"lang\": \"zh-CN\",\n    \"dir\": \"ltr\",\n    \"name\": \"Keee的博客\",\n    \"description\": \"blog.keee.top\",\n    \"display\": \"standalone\",\n    \"short_name\": \"Keee\",\n    \"scope\": \"/\",\n    \"start_url\": \"/\",\n    \"theme_color\": \"#7dd3fc\",\n    \"background_color\": \"#cbd5e1\",\n    \"icons\": [\n        {\n            \"src\": \"/img/siteicon/16.png\",\n            \"sizes\": \"16x16\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"/img/siteicon/32.png\",\n            \"sizes\": \"32x32\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"/img/siteicon/64.png\",\n            \"sizes\": \"64x64\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"/img/siteicon/512.png\",\n            \"sizes\": \"512x512\",\n            \"type\": \"image/png\"\n        }\n    ]   \n}"},{"path":"/package.json","content":"{\n  \"name\": \"keee_sources\",\n  \"version\": \"1.0.0\",\n  \"description\": \".\",\n  \"main\": \"/\",\n  \"scripts\": {\n    \"test\": \"/\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"/\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\"\n}"},{"path":"/package_o.json","content":"{\n  \"name\": \"cqlkc-mirror\",\n  \"version\": \"2.1.11\",\n  \"description\": \"\",\n  \"main\": \"sw.js\",\n  \"directories\": {\n    \"test\": \"test\"\n  },\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"author\": \"cqlkc\",\n  \"license\": \"ISC\"\n}"},{"path":"/sw-old.js","content":"const CACHE_NAME = 'ICDNCache';\nlet cachelist = [];\nself.addEventListener('install', async function (installEvent) {\n    self.skipWaiting();\n    installEvent.waitUntil(\n        caches.open(CACHE_NAME)\n            .then(function (cache) {\n                console.log('Opened cache');\n                return cache.addAll(cachelist);\n            })\n    );\n});\nself.addEventListener('fetch', async event => {\n    try {\n        event.respondWith(handle(event.request))\n    } catch (msg) {\n        event.respondWith(handleerr(event.request, msg))\n    }\n});\nconst handleerr = async (req, msg) => {\n    return new Response(`<h1>sw挂了</h1>\n    <b>${msg}</b>`, { headers: { \"content-type\": \"text/html; charset=utf-8\" } })\n}\nlet cdn = {//镜像列表\n    \"gh\": {\n        jsdelivr: {\n            \"url\": \"https://cdn.jsdmirror.com/gh\"\n        },\n        tianli: {\n            \"url\": \"https://cdn1.tianli0.top/gh\"\n        }\n    },\n    \"combine\": {\n        jsdelivr: {\n            \"url\": \"https://cdn.jsdmirror.com/combine\"\n        },\n        jsdelivr_fastly: {\n            \"url\": \"https://cdn.jsdmirror.com/combine\"\n        }\n    },\n    \"npm\": {\n        afdelivr: {\n            \"url\": \"https://cdn.afdelivr.top/npm\"\n        },\n        eleme: {\n            \"url\": \"https://npm.elemecdn.com\"\n        },\n        jsdelivr: {\n            \"url\": \"https://cdn.jsdmirror.com/npm\"\n        },\n        jsdelivr_fastly: {\n            \"url\": \"https://cdn.jsdmirror.com/npm\"\n        },\n        zhimg: {\n            \"url\": \"https://unpkg.zhimg.com\"\n        },\n        unpkg: {\n            \"url\": \"https://unpkg.com\"\n        },\n        tianli: {\n            \"url\": \"https://cdn1.tianli0.top/npm\"\n        }\n    }\n}\n//主控函数\nconst handle = async function (req) {\n    const urlStr = req.url\n    const domain = (urlStr.split('/'))[2]\n    const urlObj = new URL(urlStr);\n    const urlPath = urlObj.pathname;\n    const pathname = urlObj.href.substr(urlObj.origin.length);\n    let urls = []\n    if (pathname.match(/\\/sw\\.js/g)) { return fetch(req) }\n    if(domain === \"keee.top\"){\n        return lfetch(generate_blog_urls('cqlkc-mirror',await db.read('blog_version') || '1.0.1',fullpath(urlPath)))\n        .then(res=>res.arrayBuffer())//arrayBuffer最科学也是最快的返回\n        .then(buffer=>new Response(buffer,{headers:{\"Content-Type\":\"text/html;charset=utf-8\"}}))//重新定义header\n    }\n    for (let i in cdn) {\n        for (let j in cdn[i]) {\n            if (domain == cdn[i][j].url.split('https://')[1].split('/')[0] && urlStr.match(cdn[i][j].url)) {\n                urls = []\n                for (let k in cdn[i]) {\n                    urls.push(urlStr.replace(cdn[i][j].url, cdn[i][k].url))\n                }\n                if (urlStr.indexOf('@latest/') > -1) {\n                    return lfetch(urls, urlStr)\n                } else {\n                    return caches.match(req).then(function (resp) {\n                        return resp || lfetch(urls, urlStr).then(function (res) {\n                            return caches.open(CACHE_NAME).then(function (cache) {\n                                cache.put(req, res.clone());\n                                return res;\n                            });\n                        });\n                    })\n                }\n            }\n        }\n    }\n    return fetch(req)\n}\nconst lfetch = async (urls, url) => {\n    let controller = new AbortController();\n    const PauseProgress = async (res) => {\n        return new Response(await (res).arrayBuffer(), { status: res.status, headers: res.headers });\n    };\n    if (!Promise.any) {\n        Promise.any = function (promises) {\n            return new Promise((resolve, reject) => {\n                promises = Array.isArray(promises) ? promises : []\n                let len = promises.length\n                let errs = []\n                if (len === 0) return reject(new AggregateError('All promises were rejected'))\n                promises.forEach((promise) => {\n                    promise.then(value => {\n                        resolve(value)\n                    }, err => {\n                        len--\n                        errs.push(err)\n                        if (len === 0) {\n                            reject(new AggregateError(errs))\n                        }\n                    })\n                })\n            })\n        }\n    }\n    return Promise.any(urls.map(urls => {\n        return new Promise((resolve, reject) => {\n            fetch(urls, {\n                signal: controller.signal\n            })\n                .then(PauseProgress)\n                .then(res => {\n                    if (res.status == 200) {\n                        controller.abort();\n                        resolve(res)\n                    } else {\n                        reject(res)\n                    }\n                })\n        })\n    }))\n}\n/*\n2022-11-30新增all-site-npm\n*/\nconst fullpath = (path) => {\n    path = path.split('?')[0].split('#')[0]\n    if (path.match(/\\/$/)) {\n        path += 'index'\n    }\n    if (!path.match(/\\.[a-zA-Z]+$/)) {\n        path += '.html'\n    }\n    return path\n}\nconst generate_blog_urls = (packagename, blogversion, path) => {\n    const npmmirror = [\n        `https://cdn.afdelivr.top/npm/${packagename}@${blogversion}`,\n        `https://unpkg.com/${packagename}@${blogversion}`,\n        `https://npm.elemecdn.com/${packagename}@${blogversion}`,\n        `https://cdn.jsdmirror.com/npm/${packagename}@${blogversion}`,\n        `https://npm.sourcegcdn.com/npm/${packagename}@${blogversion}`,\n        `https://cdn1.tianli0.top/npm/${packagename}@${blogversion}`\n    ]\n    for (var i in npmmirror) {\n        npmmirror[i] += path\n    }\n    return npmmirror\n}\nconst mirror = [\n    `https://registry.npmmirror.com/cqlkc-mirror/latest`,\n    `https://registry.npmjs.org/cqlkc-mirror/latest`,\n    `https://mirrors.cloud.tencent.com/npm/cqlkc-mirror/latest`\n]\nconst get_newest_version = async (mirror) => {\nreturn lfetch(mirror, mirror[0])\n    .then(res => res.json())\n    .then(res.version)\n}\nself.db = { //全局定义db,只要read和write,看不懂可以略过\n    read: (key, config) => {\n        if (!config) { config = { type: \"text\" } }\n        return new Promise((resolve, reject) => {\n            caches.open(CACHE_NAME).then(cache => {\n                cache.match(new Request(`https://LOCALCACHE/${encodeURIComponent(key)}`)).then(function (res) {\n                    if (!res) resolve(null)\n                    res.text().then(text => resolve(text))\n                }).catch(() => {\n                    resolve(null)\n                })\n            })\n        })\n    },\n    write: (key, value) => {\n        return new Promise((resolve, reject) => {\n            caches.open(CACHE_NAME).then(function (cache) {\n                cache.put(new Request(`https://LOCALCACHE/${encodeURIComponent(key)}`), new Response(value));\n                resolve()\n            }).catch(() => {\n                reject()\n            })\n        })\n    }\n}\n\nconst set_newest_version = async (mirror) => { //改为最新版本写入数据库\n    return lfetch(mirror, mirror[0])\n        .then(res => res.json()) //JSON Parse\n        .then(async res => {\n            await db.write('blog_version', res.version) //写入\n            return;\n        })\n}\n\nsetInterval(async() => {\n    await set_newest_version(mirror) //定时更新,一分钟一次\n}, 60*1000);\n\nsetTimeout(async() => { \n    await set_newest_version(mirror)//打开五秒后更新,避免堵塞\n},5000)"},{"path":"/sw-d.js","content":"self.addEventListener('install', function(e) {\n    self.skipWaiting();\n  });\n  \n  self.addEventListener('activate', function(e) {\n    self.registration.unregister()\n      .then(function() {\n        return self.clients.matchAll();\n      })\n      .then(function(clients) {\n        clients.forEach(client => client.navigate(client.url))\n      });\n  });"},{"path":"/sw_o.js","content":"const CACHE_NAME = 'Keee-sw';\nlet cachelist = [];\nself.cons = {\n    s: (m) => {\n        console.log(`%c[SUCCESS]%c ${m}`, 'color:white;background:green;', '')\n    },\n    w: (m) => {\n        console.log(`%c[WARNING]%c ${m}`, 'color:brown;background:yellow;', '')\n    },\n    i: (m) => {\n        console.log(`%c[INFO]%c ${m}`, 'color:white;background:blue;', '')\n    },\n    e: (m) => {\n        console.log(`%c[ERROR]%c ${m}`, 'color:white;background:red;', '')\n    },\n    d: (m) => {\n        console.log(`%c[DEBUG]%c ${m}`, 'color:white;background:black;', '')\n    }\n}\nconst generate_uuid = () => {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\n        return v.toString(16);\n    });\n}\nself.db = {\n    read: (key, config) => {\n        if (!config) { config = { type: \"text\" } }\n        return new Promise((resolve, reject) => {\n            caches.open(CACHE_NAME).then(cache => {\n                cache.match(new Request(`https://LOCALCACHE/${encodeURIComponent(key)}`)).then(function (res) {\n                    if (!res) resolve(null)\n                    res.text().then(text => resolve(text))\n                }).catch(() => {\n                    resolve(null)\n                })\n            })\n        })\n    },\n    write: (key, value) => {\n        return new Promise((resolve, reject) => {\n            caches.open(CACHE_NAME).then(function (cache) {\n                cache.put(new Request(`https://LOCALCACHE/${encodeURIComponent(key)}`), new Response(value));\n                resolve()\n            }).catch(() => {\n                reject()\n            })\n        })\n    }\n}\n\nself.addEventListener('activate', async function (installEvent) {\n    self.clients.claim()\n})\n\nself.addEventListener('install', async function (installEvent) {\n    self.skipWaiting();\n    installEvent.waitUntil(\n        caches.open(CACHE_NAME)\n            .then(async function (cache) {\n                if (!await db.read('uuid')) {\n                    await db.write('uuid', generate_uuid())\n                }\n                return cache.addAll(cachelist);\n            })\n    );\n});\nconst handleerr = async (req, msg) => {\n    return new Response(`<h1>sw挂了</h1>\n    <b>${msg}</b>`, { headers: { \"content-type\": \"text/html; charset=utf-8\" } })\n}\n\nlet cdn = {\n    \"gh\": {\n        zzko: {\n            \"url\": \"https://cdn.jsdmirror.com/gh\"\n        },\n        jsdelivr: {\n            \"url\": \"https://cdn.jsdmirror.com/gh\"\n        }\n    },\n    \"npm\": {\n        eleme: {\n            \"url\": \"https://npm.elemecdn.com\"\n        },\n        zzko: {\n            \"url\": \"https://cdn.jsdmirror.com/npm\"\n        },\n        jsdelivr: {\n            \"url\": \"https://cdn.jsdmirror.com/npm\"\n\n        }\n        //oplog: {\n        //    \"url\": \"https://cdn.oplog.cn/npm\"\n        //},\n        \n\n    }\n}\n\nconst cache_url_list = ['keee.top']\nconst blog_default_version = '1.0.1'\nconst handle = async function (req) {\n    set_blog_config(await db.read('blog_version') || blog_default_version)\n    const reqdata = await req.clone()\n    // try {\n    //     if (!wsc.OPEN) wsc.onclose()\n    // } catch (e) { }\n    const urlStr = req.url\n    let urlObj = new URL(urlStr)\n    const uuid = await db.read('uuid')\n    const pathname = urlObj.href.substr(urlObj.origin.length)\n    const port = urlObj.port\n    const domain = (urlStr.split('/'))[2]\n    if (pathname.match(/\\/sw\\.js/g)) { return fetch(req) }\n    if (pathname.match(/\\/null/g)) { return null }\n    if (pathname.match(/\\/undefined/g)) { return null }\n    const path = pathname.split('?')[0]\n    const query = q => urlObj.searchParams.get(q)\n    let urls = []\n    let msg = JSON.parse(await db.read('msg')) || (async () => { await db.write('msg', '[]'); return '[]' })()\n    const nqurl = urlStr.split('?')[0]\n    const nqreq = new Request(nqurl)\n    const cache_delete = async (url) => {\n        const cache = await caches.open(CACHE_NAME)\n        await cache.delete(url)\n    }\n    if (query('nosw') == 'true') {\n        return fetch(req)\n    }\n    if (query('delete') == 'true') {\n        cache_delete(nqreq);\n        msg.push(\n            {\n                \"name\": \"文件已删除\",\n                \"time\": new Date(),\n                \"info\": `已删除${nqurl}`\n            }\n        )\n        await db.write('msg', JSON.stringify(msg))\n        return new Response(JSON.stringify({ ok: 1 }))\n    }\n    if (query('forceupdate') == 'true') {\n        //update cache\n\n        msg.push(\n            {\n                \"name\": \"文件已强制更新\",\n                \"time\": new Date(),\n                \"info\": `已更新${nqurl}`\n            }\n        )\n        await db.write('msg', JSON.stringify(msg))\n        await fetch(req).then(function (res) {\n            return caches.open(CACHE_NAME).then(function (cache) {\n                cache_delete(nqreq);\n                cache.put(req, res.clone());\n                return res;\n            });\n        });\n        return new Response(JSON.stringify({ ok: 1 }))\n    }\n    for (let i in cdn) {\n        for (let j in cdn[i]) {\n\n            if (domain == cdn[i][j].url.split('https://')[1].split('/')[0] && urlStr.match(cdn[i][j].url)) {\n                urls = []\n                for (let k in cdn[i]) {\n                    urls.push(urlStr.replace(cdn[i][j].url, cdn[i][k].url))\n                }\n                return caches.match(req).then(function (resp) {\n                    return resp || lfetch(urls, urlStr).then(function (res) {\n                        return caches.open(CACHE_NAME).then(function (cache) {\n                            cache.put(req, res.clone());\n                            return res;\n                        });\n                    });\n                })\n\n\n            }\n        }\n    }\n    for (var i in blog.origin) {\n        if (domain.split(\":\")[0] == blog.origin[i].split(\":\")[0]) {\n            // if (typeof wsc !== \"undefined\") {\n            //     if (wsc.readyState != 1) {\n            //         await db.write('disconnect', '1')\n            //     } else {\n            //         await db.write('disconnect', '0')\n            //     }\n            // }\n            if (blog.local) { return fetch(req) }\n            setTimeout(async () => {\n                await set_newest_blogver()\n            }, 30 * 1000);\n            urls = []\n            /*\n            for (let k in blog.plus) {\n                //urls.push(urlStr.replace(domain, blog.plus[k]).replace(domain + \":\" + port, blog.plus[k]).replace('http://', \"https://\"))\n                urls.push(`https://${blog.plus[k]}` + fullpath(pathname))\n            }*/\n            for (let k in blog.npmmirror) {\n                urls.push(blog.npmmirror[k] + fullpath(pathname))\n            }\n            const generate_blog_html = async (res) => {\n                return new Response(await res.arrayBuffer(), {\n                    headers: {\n                        'Content-Type': 'text/html;charset=utf-8'\n                    },\n                    status: res.status,\n                    statusText: res.statusText\n                })\n            }\n            return new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    caches.match(req).then(function (resp) {\n                        if (!!resp) {\n                            cons.s(`Cache Hited! | Origin:${urlStr}`)\n                            setTimeout(() => {\n                                resolve(resp)\n                            }, 200);\n                            setTimeout(() => {\n                                lfetch(urls, urlStr).then(async function (res) {\n                                    return caches.open(CACHE_NAME).then(async function (cache) {\n                                        cache.delete(req);\n                                        cons.s(`Cache Updated! | Origin:${urlStr}`)\n                                        if (fullpath(pathname).match(/\\.html$/g)) {\n                                            const NewRes = await generate_blog_html(res)\n                                            cache.put(req, NewRes.clone());\n                                            resolve(NewRes)\n                                        } else {\n                                            cache.put(req, res.clone());\n                                            resolve(res)\n                                        }\n                                    });\n                                });\n                            }, 0);\n                        } else {\n                            cons.w(`Cache Missed! | Origin:${urlStr}`)\n                            setTimeout(() => {\n                                lfetch(urls, urlStr).then(async function (res) {\n                                    return caches.open(CACHE_NAME).then(async function (cache) {\n                                        if (fullpath(pathname).match(/\\.html$/g)) {\n                                            const NewRes = await generate_blog_html(res)\n                                            cache.put(req, NewRes.clone());\n                                            resolve(NewRes)\n                                        } else {\n                                            cache.put(req, res.clone());\n                                            resolve(res)\n                                        }\n                                    });\n                                }).catch(function (err) {\n                                    resolve(caches.match(new Request('/offline.html')))\n                                })\n                            }, 0);\n                            setTimeout(() => {\n                                resolve(caches.match(new Request('/offline.html')))\n                            }, 5000);\n                        }\n                    })\n                }, 0);\n            })\n\n        }\n    }\n    for (var i in cache_url_list) {\n        if (urlStr.match(cache_url_list[i])) {\n            return caches.match(req).then(function (resp) {\n                return resp || fetch(req).then(function (res) {\n                    return caches.open(CACHE_NAME).then(function (cache) {\n\n                        cache.put(req, res.clone());\n                        return res;\n                    });\n                });\n            })\n        }\n    }\n\n    return fetch(req)\n}\n\nconst lfetch = async (urls, url) => {\n    cons.i(`LFetch Handled! | Mirrors Count:${urls.length} | Origin: ${url}`)\n    const t1 = new Date().getTime()\n    const uuid = await db.read('uuid')\n    if (!Promise.any) {\n        Promise.any = function (promises) {\n            return new Promise((resolve, reject) => {\n                promises = Array.isArray(promises) ? promises : []\n                let len = promises.length\n                let errs = []\n                if (len === 0) return reject(new AggregateError('All promises were rejected'))\n                promises.forEach((promise) => {\n                    promise.then(value => {\n                        resolve(value)\n                    }, err => {\n                        len--\n                        errs.push(err)\n                        if (len === 0) {\n                            reject(new AggregateError(errs))\n                        }\n                    })\n                })\n            })\n        }\n    }\n    let controller = new AbortController();\n    const PauseProgress = async (res) => {\n        return new Response(await (res).arrayBuffer(), { status: res.status, headers: res.headers });\n    };\n    let results = Promise.any(urls.map(async urls => {\n        return new Promise(async (resolve, reject) => {\n            fetch(urls, {\n                signal: controller.signal\n            })\n                .then(PauseProgress)\n                .then(async res => {\n                    const resn = res.clone()\n                    if (resn.status == 200) {\n                        controller.abort();\n                        cons.s(`LFetch Success! | Time: ${new Date().getTime() - t1}ms | Origin: ${url} `)\n                        resolve(resn)\n                    } else {\n                        reject(null)\n                    }\n                }).catch((e) => {\n                    if (String(e).match('The user aborted a request') || String(e).match('Failed to fetch')) {\n                        console.log()\n                    } else if (String(e).match('been blocked by CORS policy')) {\n                        cons.e(`LFetch Blocked by CORS policy! | Origin: ${url}`)\n                    }\n                    else {\n                        cons.e(`LFetch Error! | Origin: ${url} | Reason: ${e}`)\n                    }\n                    reject(null)\n                })\n        }\n        )\n    }\n    )).then(res => { return res }).catch(() => { return null })\n\n    return results\n\n}\n\nconst fullpath = (path) => {\n    path = path.split('?')[0].split('#')[0]\n    if (path.match(/\\/$/)) {\n        path += 'index'\n    }\n    if (!path.match(/\\.[a-zA-Z0-9]+$/)) {\n        path += '.html'\n    }\n    return path\n}\n\n\n\nconst set_blog_config = (version) => {\n    self.packagename = \"cqlkc-mirror\"\n    self.blogversion = version\n    self.blog = {\n        local: 0,\n        origin: [\n            \"blog.keee.top\",\n        ],\n        plus: [\n            \"blog.keee.top\",\n        ],\n        npmmirror: [\n            //`https://cdn1.tianli0.top/npm/${packagename}@${blogversion}`,\n            `https://cdn.jsdmirror.com/npm/${packagename}@${blogversion}`,\n           //`https://cdn.afdelivr.top/npm/${packagename}@${blogversion}`,\n            //`https://npm.elemecdn.com/${packagename}@${blogversion}`,\n            //`https://unpkg.com/${packagename}@${blogversion}`,\n            //`https://cdn.jsdmirror.com/npm/${packagename}@${blogversion}`,\n            //`https://cdn-jsd.pigax.cn/npm/${packagename}@${blogversion}`,\n            //`https://cdn.oplog.cn/npm/${packagename}@${blogversion}/public`\n        ]\n    };\n}\nconst set_newest_blogver = async () => {\n    self.packagename = \"cqlkc-mirror\"\n    const mirror = [\n        `https://registry.npmmirror.com/${packagename}/latest`,\n        `https://registry.npmjs.org/${packagename}/latest`,\n       // `https://mirrors.cloud.tencent.com/npm/${packagename}/latest`\n    ]\n    cons.i(`Searching For The Newest Version...`)\n    return lfetch(mirror, mirror[0])\n        .then(res => res.json())\n        .then(async res => {\n            if (!res.version) throw ('No Version Found!')\n            const gVer = choose_the_newest_version(res.version, await db.read('blog_version') || blog_default_version)\n            cons.d(`Newest Version: ${res.version} ; Local Version: ${await db.read('blog_version')} | Update answer: ${gVer}`)\n            cons.s(`Update Blog Version To ${gVer}`);\n            if (gVer !== await db.read('blog_version') && gVer !== blog_default_version){\n                function a() {\n                    return self.clients.matchAll()\n                        .then(function (clients) {\n                            if (clients && clients.length) {\n                                clients.forEach(function (client) {\n                                    client.postMessage('sw.update');\n                                })\n                            }\n                        })\n                }\n                a();\n            }\n            await db.write('blog_version', gVer)\n            set_blog_config(gVer)\n        })\n        .catch(e => {\n            cons.e(`Get Blog Newest Version Erorr!Reseon:${e}`);\n            set_blog_config(blog_default_version)\n        })\n}\n\n\nconst choose_the_newest_version = (g1, g2) => {\n\n    const spliter = (v) => {\n\n        const fpart = v.split('.')[0]\n        return [parseInt(fpart), v.replace(fpart + '.', '')]\n    }\n    const compare_npmversion = (v1, v2) => {\n        const [n1, s1] = spliter(v1)\n        const [n2, s2] = spliter(v2)\n        cons.d(`n1:${n1} s1:${s1} n2:${n2} s2:${s2}`)\n        if (n1 > n2) {\n            return g1\n        } else if (n1 < n2) {\n            return g2\n        } else if (!s1.match(/\\./) && !s2.match(/\\./)) {\n            if (parseInt(s1) > parseInt(s2)) return g1\n            else return g2\n        } else {\n            return compare_npmversion(s1, s2)\n        }\n    }\n    return compare_npmversion(g1, g2)\n}\n\nsetInterval(async () => {\n    cons.i('Trying to fetch the newest version...')\n    await set_newest_blogver()\n}, 240 * 1000);\nself.addEventListener('fetch', async event => {\n    try {\n\n        event.respondWith(handle(event.request))\n    } catch (msg) {\n        event.respondWith(handleerr(event.request, msg))\n    }\n});"},{"title":"about","path":"/about/index.html","content":"![](https://pic1.imgdb.cn/item/660eb4cf68eb935713d1be5e.webp)\n\n<span id=\"ppoems\"></span>\n<script src=\"https://unpkg.com/typed.js@2.1.0/dist/typed.umd.js\"></script>\n<script>\n  var xhr = new XMLHttpRequest();\n  xhr.open('get', 'https://v2.jinrishici.com/one.json');\n  xhr.withCredentials = true;\n  xhr.onreadystatechange = function () {\n    if (xhr.readyState === 4) {\n      var data = JSON.parse(xhr.responseText);\n      // 处理示例\n      var gushici = document.getElementById('ppoems');\n       var ppoems = data.data.content;\n    }\n    var typed = new Typed('#ppoems', {\n  strings: [ppoems],\n  typeSpeed: 100\n});\n  };\n  xhr.send();\n</script>\n<script>\n  var typed6 = new Typed('#typed6', {\n    strings: [' ^1000\\n `一个普通的重庆高中学生，爱好游戏、数码、摄影等...`'],\n    typeSpeed: 40,\n    backSpeed: 0,                                                                                                                                                                                                                             \n    loop: true\n  });\n</script>\n\n一个普通的重庆高中学生，爱好游戏、数码、摄影等\n\n2024 年 3 月 29 日\n\n弃用Butterfly，启用Stellar主题并基本完成适配工作\n\n2022年 10 月 3 日\n\n选择 Hexo + Butterfly主题并推送首个文章"},{"title":"说说","path":"/bbtalk/index.html","content":"<div id=\"ispeak\"></div>\n<link rel=\"stylesheet\" href=\"https://s4.zstatic.net/ajax/libs/highlight.js/10.6.0/styles/atom-one-dark.min.css\"/>\n<link rel=\"stylesheet\" href=\"https://cdn.jsdmirror.com/npm/ispeak@4.4.0/style.css\"/>\n<script data-no-instant src=\"https://s4.zstatic.net/ajax/libs/highlight.js/10.6.0/highlight.min.js\"></script>\n<script src=\"https://s4.zstatic.net/ajax/libs/marked/2.0.0/marked.min.js\"></script>\n<!-- JS -->\n<script data-no-instant= \"false\">\n    /*var head = document.getElementsByTagName('head')[0]\n    var meta = document.createElement('meta')\n    meta.name = 'referrer'\n    meta.content = 'no-referrer'*\n    head.appendChild(meta)\n    if (ispeak) {\n        ispeak.init({\n            el: '#ispeak',\n            api: 'https://kkapi.keee.top/',\n            author: '633aaa45d0d52c818b1cf9c1',\n            pageSize: 10,\n            loading_img: 'https://bu.dusays.com/2022/05/01/626e88f349943.gif',\n            comment: \n            function (speak) {\n            // 4.4.0 之后在此回调函数中初始化评论\n            const { _id, title, content } = speak\n            const contentSub = content.substring(0, 30)\n            twikoo.init({\n                envId: 'https://twikoo-netlify-c.netlify.app/.netlify/functions/twikoo', // 腾讯云环境填 envId；Vercel 环境填地址（https://xxx.vercel.app）\n                pageTitle: title || contentSub, // 手动传入当前speak的标题(由于content可能过长，因此截取前30个字符)\n                site: 'bbtalk',\n                el: '.ispeak-comment', // 容器元素\n                // region: 'ap-guangzhou', // 环境地域，默认为 ap-shanghai，腾讯云环境填 ap-shanghai 或 ap-guangzhou；Vercel 环境不填\n                path:  '/bbtalk/info.html?q=' + _id, // 用于区分不同文章的自定义 js 路径，如果您的文章路径不是 location.pathname，需传此参数'/bbtalk/info.html?q=' +\n                // lang: 'zh-CN', // 用于手动设定评论区语言，支持的语言列表 https://github.com/imaegoo/twikoo/blob/main/src/client/utils/i18n/index.js\n                onCommentLoaded: function () {}\n            })\n            }\n        })\n        .then(function () {\n            console.log('ispeak 加载完成')\n            document.getElementById('tip').style.display = 'none'\n        })\n    } else {\n        document.getElementById('tip').innerHTML = 'ipseak依赖加载失败！'\n    }\n}\npia();*/\n    load_ispeak();\n    InstantClick.on(\"change\", pjax_ispeak);\n</script>"},{"title":"Speak","path":"/bbtalk/info.html","content":"<!-- CSS -->\n<!--<link href=\"https://unpkg.com/artalk@2.3.4/dist/Artalk.css\" rel=\"stylesheet\">-->\n<link\n  rel=\"stylesheet\"\n  href=\"https://cdn.jsdmirror.com/npm/ispeak@4.4.0/style.css\"\n/>\n<link rel=\"stylesheet\" href=\"https://s4.zstatic.net/ajax/libs/highlight.js/10.6.0/styles/atom-one-dark.min.css\" />\n<div class='content'>\n</div>\n<hr />\n<div class='ispeak-comment'></div>\n<!-- JS -->\n<script src=\"https://s4.zstatic.net/ajax/libs/highlight.js/10.6.0/highlight.min.js\"></script>\n<script src=\"https://s4.zstatic.net/ajax/libs/marked/2.0.0/marked.min.js\"></script>\n<script src=\"https://cdn.jsdmirror.com/npm/ispeak@4.4.0/ispeak.umd.js\"></script>\n<div id=\"tcomment\"></div>\n<script src=\"https://cdn.jsdmirror.com/npm/twikoo@1.6.38/dist/twikoo.all.min.js\"></script>\n<script>\n  const searchParams = new URLSearchParams(window.location.search);\n  const speakId = searchParams.get('q');\n  const path = window.location.pathname;\n  const apiURL = 'htt';\n  const markedRenderps://kkapi.keee.top/api/ispeak = (body, loading_img='https://bu.dusays.com/2022/05/01/626e88f349943.gif') => {\n    const renderer = {\n      image(href, title, text) {\n        return `<a href=\"${href}\" target=\"_blank\" data-fancybox=\"group\" class=\"fancybox\">\n            <img speak-src=\"${href}\" src=${loading_img} alt='${text}'>\n            </a>`\n      }\n    }\n    marked.setOptions({\n      renderer: new marked.Renderer(),\n      highlight: function (code) {\n        if (hljs) {\n          return hljs.highlightAuto(code).value\n        } else {\n          return code\n        }\n      },\n      pedantic: false,\n      gfm: true,\n      tables: true,\n      breaks: true,\n      sanitize: false,\n      smartLists: true,\n      smartypants: false,\n      xhtml: false\n    })\n    marked.use({ renderer })\n    return marked.parse(body)\n  }\n  fetch(`${apiURL}/get/${speakId}`)\n  .then(response => response.json())\n  .then(res => {\n    const data = res.data;\n    if(data){\n      const {title,content} = data;\n      const contentSub = content.substring(0, 30);\n      document.querySelector('.content').innerHTML = markedRender(content);\n      if(title){\n        document.title = title;\n      }\n      twikoo.init({\n        envId: 'https://twikoo-netlify-c.netlify.app/.netlify/functions/twikoo', // 腾讯云环境填 envId；Vercel 环境填地址（https://xxx.vercel.app）\n        pageTitle: title || contentSub, // 手动传入当前speak的标题(由于content可能过长，因此截取前30个字符)\n        site: 'bbtalk',\n        el: '.ispeak-comment', // 容器元素\n        // region: 'ap-guangzhou', // 环境地域，默认为 ap-shanghai，腾讯云环境填 ap-shanghai 或 ap-guangzhou；Vercel 环境不填\n        path:  '/bbtalk/info.html?q=' + _id, // 用于区分不同文章的自定义 js 路径，如果您的文章路径不是 location.pathname，需传此参数'/bbtalk/info.html?q=' +\n         // lang: 'zh-CN', // 用于手动设定评论区语言，支持的语言列表 https://github.com/imaegoo/twikoo/blob/main/src/client/utils/i18n/index.js\n          })\n    }\n  });\n  \n</script>"},{"title":"friends","path":"/friends/index.html","content":"欢迎交换友链哦！# 关于我```YAML- name: Keee的博客 url: https://blog.keee.top avatar: https://blog.keee.top/img/avatar-24.webp descr: 开心就好。```"},{"path":"/js/aha.js","content":"(function () {\n    'use strict';\n    document.onkeydown = function (event) {\n        event = (event || window.event);\n        if (event.keyCode == 123) {\n            iziToast.info({\n                title: '已开启开发者模式',\n                message: '请遵守MIT协议',\n                timeout: 2000,\n                backgroundColor: '#e5f7ff',\n                icon: 'Fontawesome',\n                icon: 'far fa-copyright',\n                position: 'topRight'\n            });\n        }\n    }\n})();\n\ndocument.body.oncopy = function () {\n    iziToast.info({\n        timeout: 2000,\n        icon: 'Fontawesome',\n        closeOnEscape: 'true',\n        transitionIn: 'bounceInLeft',\n        transitionOut: 'fadeOutRight',\n        layout: '2',\n        position: 'topRight',\n        icon: 'far fa-copy',\n        backgroundColor: '#e5f7ff',\n        title: '复制成功',\n        message: '请遵守 CC BY-NC-SA 4.0 协议'\n    });\n}\n\n// 老旧浏览器提示\nfunction browserTC() {\n    iziToast.warning({\n        title: '检测到您的浏览器版本过低',\n        message: '这可能会导致网站样式错乱',\n        timeout: 5000,\n        position: 'topRight'\n    });\n}\n\nfunction browserVersion() {\n    var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串\n    var isIE = userAgent.indexOf(\"compatible\") > -1 && userAgent.indexOf(\"MSIE\") > -1; //判断是否IE<11浏览器\n    var isIE11 = userAgent.indexOf('Trident') > -1 && userAgent.indexOf(\"rv:11.0\") > -1;\n    var isEdge = userAgent.indexOf(\"Edge\") > -1 && !isIE; //Edge浏览器\n    var isFirefox = userAgent.indexOf(\"Firefox\") > -1; //Firefox浏览器\n    var isOpera = userAgent.indexOf(\"Opera\")>-1 || userAgent.indexOf(\"OPR\")>-1 ; //Opera浏览器\n    var isChrome = userAgent.indexOf(\"Chrome\")>-1 && userAgent.indexOf(\"Safari\")>-1 && userAgent.indexOf(\"Edge\")==-1 && userAgent.indexOf(\"OPR\")==-1; //Chrome浏览器\n    var isSafari = userAgent.indexOf(\"Safari\")>-1 && userAgent.indexOf(\"Chrome\")==-1 && userAgent.indexOf(\"Edge\")==-1 && userAgent.indexOf(\"OPR\")==-1; //Safari浏览器\n    if(isEdge) {\n        if(userAgent.split('Edge/')[1].split('.')[0]<90){\n            browserTC()\n        }\n    } else if(isFirefox) {\n        if(userAgent.split('Firefox/')[1].split('.')[0]<90){\n            browserTC()\n        }\n    } else if(isOpera) {\n        if(userAgent.split('OPR/')[1].split('.')[0]<80){\n            browserTC()\n        }\n    } else if(isChrome) {\n        if(userAgent.split('Chrome/')[1].split('.')[0]<90){\n            browserTC()\n        }\n    }\n}\nfunction setCookies(obj, limitTime) {\n\tlet data = new Date(new Date().getTime() + limitTime * 24 * 60 * 60 * 1000).toGMTString()\n\tfor (let i in obj) {\n\t\tdocument.cookie = i + '=' + obj[i] + ';expires=' + data\n\t}\n}\nfunction getCookie(name) {\n\tvar arr, reg = new RegExp(\"(^| )\" + name + \"=([^;]*)(;|$)\");\n\tif (arr = document.cookie.match(reg))\n\t\treturn unescape(arr[2]);\n\telse\n\t\treturn null;\n}\nif(getCookie('browsertc')!=1){\n    setCookies({\n        browsertc: 1,\n    }, 1);\n    browserVersion();\n}\nnow = new Date(), hour = now.getHours();\nif (hour < 6) {\n    var hello = \"凌晨好\";\n} else if (hour < 9) {\n    var hello = \"早上好\";\n} else if (hour < 12) {\n    var hello = \"上午好\";\n} else if (hour < 14) {\n    var hello = \"中午好\";\n} else if (hour < 17) {\n    var hello = \"下午好\";\n} else if (hour < 19) {\n    var hello = \"傍晚好\";\n} else if (hour < 22) {\n    var hello = \"晚上好\";\n} else {\n    var hello = \"夜深了\";\n}\n/*\nvar sayhello = function(){\n    if(document.body.clientWidth > 600){\n        document.body.onload = function(){\n            iziToast.info({\n                timeout: 2000,\n                icon: 'Fontawesome',\n                closeOnEscape: 'true',\n                transitionIn: 'bounceInLeft',\n                transitionOut: 'fadeOutRight',\n                layout: '2',\n                position: 'topLeft',\n                icon: 'fa-solSWd fa-sun',\n                backgroundColor: '#efefef',\n                title: hello,\n                message: '欢迎来到 cqlkc 的博客'  \n            });\n    }\n\n}\n}();*/\n// 固定卡片点击动作\nfunction FixedCardWidget(type,name,index){\n    // 根据id或class选择元素\n    if (type === \"id\"){\n      var tempcard = document.getElementById(name);\n    }\n    else{\n      var tempcard = document.getElementsByClassName(name)[index];\n    }\n    // 若元素存在\n    if (tempcard) {\n        // 首先判断是否存在fixed-card-widget类\n        if (tempcard.className.indexOf('fixed-card-widget') > -1){\n          // 存在则移除\n          RemoveFixedCardWidget();\n        }\n        else{\n          // 不存在则先初始化防止卡片叠加\n          RemoveFixedCardWidget();\n          //新建退出蒙版\n          CreateQuitBox();\n          // 再添加固定卡片样式\n          tempcard.classList.add('fixed-card-widget');\n        }\n    }\n  }\n  //创建一个蒙版，作为退出键使用\n  function CreateQuitBox(){\n    var quitBox = `<div id=\"quit-box\" onclick=\"RemoveFixedCardWidget()\"></div>`\n    var asideContent = document.getElementById('aside-content');\n    asideContent.insertAdjacentHTML(\"beforebegin\",quitBox)\n  }\n  // 移除卡片方法\n  function RemoveFixedCardWidget(){\n    var activedItems = document.querySelectorAll('.fixed-card-widget');\n    if (activedItems) {\n      for (i = 0; i < activedItems.length; i++) {\n        activedItems[i].classList.remove('fixed-card-widget');\n      }\n    }\n    //移除退出蒙版\n    var quitBox = document.getElementById('quit-box');\n    if (quitBox) quitBox.remove();\n  }\n  // 常规先初始化，确保切换页面后不会有固定卡片留存\n  RemoveFixedCardWidget()\n  window.ATK_LIGHTBOX_CONF = {\n    groupAll: true,\n  }/*\n// 给首页文章卡片套上动画\nvar arr = document.getElementsByClassName(\"recent-post-item\");\nfor(var i = 0;i<arr.length;i++){\n    arr[i].classList.add(\"wow\"); //必要项，添加wow.js标记\n    arr[i].classList.add(\"animate__zoomIn\"); //必要项，添加样式动画\n  }\n// 给侧栏卡片套上动画\nvar arr = document.getElementsByClassName(\"card-widget\");\nfor(var i = 0;i<arr.length;i++){\n    arr[i].classList.add(\"wow\");\n    arr[i].classList.add(\"animate__slideInRight\");\n  }\n//初始化函数\nwow = new WOW({\n  boxClass: 'wow',\n  // 当用户滚动时显示隐藏框的类名称\n  animateClass: 'animate__animated',\n  // 触发 CSS 动画的类名称（动画库默认为\"animate.css\"库）\n  offset: 0,\n  // 定义浏览器视口底部与隐藏框顶部之间的距离。\n  // 当用户滚动并到达此距离时，将显示隐藏的框。\n  mobile: true,\n  // 在移动设备上打开/关闭wow.js。\n  live: true\n  // 在页面上检查新的 wow.js元素。\n})\nwow.init();*/"},{"path":"/js/artalk-plugin-lightbox.js","content":"var __defProp=Object.defineProperty,__getOwnPropSymbols=Object.getOwnPropertySymbols,__hasOwnProp=Object.prototype.hasOwnProperty,__propIsEnum=Object.prototype.propertyIsEnumerable,__defNormalProp=(t,e,o)=>e in t?__defProp(t,e,{enumerable:!0,configurable:!0,writable:!0,value:o}):t[e]=o,__spreadValues=(t,e)=>{for(var o in e||(e={}))__hasOwnProp.call(e,o)&&__defNormalProp(t,o,e[o]);if(__getOwnPropSymbols)for(var o of __getOwnPropSymbols(e))__propIsEnum.call(e,o)&&__defNormalProp(t,o,e[o]);return t};!function(t,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?e(require(\"artalk\")):\"function\"==typeof define&&define.amd?define([\"artalk\"],e):e((t=\"undefined\"!=typeof globalThis?globalThis:t||self).Artalk)}(this,(function(t){\"use strict\";function e(t){return t&&\"object\"==typeof t&&\"default\"in t?t:{default:t}}e(t).default.use((t=>{const e=\"atk-lightbox-loaded\",o=\"atk-lightbox-img\",r=\".atk-lightbox-img\",n=window.ATK_LIGHTBOX_TYPE,a=t=>!n&&window[t]||(n||\"\").toLowerCase()===t.toLowerCase();t.on(\"list-loaded\",(()=>{const n=[];t.getCommentList().forEach((t=>{const l=t.getRender().$content;l.querySelectorAll(`img:not([atk-emoticon]):not([${e}])`).forEach((t=>{t.setAttribute(e,\"\");const r=document.createElement(\"a\");r.setAttribute(\"class\",o),r.setAttribute(\"href\",t.src),r.setAttribute(\"data-src\",t.src),r.append(t.cloneNode()),t.replaceWith(r),n.push(r)})),a(\"lightGallery\")&&window.lightGallery(l,__spreadValues({selector:r},window.ATK_LIGHTBOX_CONF||{}))})),a(\"lightbox\")&&n.forEach((t=>{window.$(t).attr(\"data-title\",window.$(t).find(\"img\").attr(\"alt\")),window.$(t).attr(\"rel\",\"lightbox\"),t.onclick=e=>{e.preventDefault(),window.lightbox.start(window.$(t))}}))})),a(\"Fancybox\")&&window.Fancybox.bind(\".artalk .atk-list .atk-lightbox-img\",window.ATK_LIGHTBOX_CONF)}))}));"},{"path":"/js/bbtalk.js","content":"let jsonUrl = 'https://kkapi.keee.top/api/ispeak?author=633aaa45d0d52c818b1cf9c1&page=1' // 在这修改api\nlet el = document.querySelector('#bber-talk');\ndocument.getElementById('bber-talk').addEventListener('click', () => {\n    pjax.loadUrl(\"/bbtalk/\")// 在这修改你的哔哔页面地址\n})\nif(document.getElementById('bber-talk')) {\n    bbtalk();\n    document.addEventListener('load', () => {\n    bbtalk();}) \n}\nelse {\n    \n}\nfunction bbtalk() {\n    let data = JSON.parse(localStorage.getItem('bibi'));\n    let nowTime = Date.now();\n    let ls;\n    if (data == null || nowTime - data.time >= 1800000) { // 设置缓存时长，单位毫秒，默认30分钟，建议10分钟以上，不能为0，想不缓存自己改代码。\n        getData();\n        return\n    } else {\n        ls = JSON.parse(data.ls)\n    };\n    let bberHtml = ''\n    //utils.onLoadSuccess(el);\n    ls.forEach((item, i) => {\n        if(i>=5)return;\n        let br = /[\\s\\uFEFF\\xA0]+/g;\n        item.content = item.content.replace(br, '')\n       /* let d = new Date(item.createdAt)\n        let date = d.getFullYear() + '/' + (d.getMonth() + 1) + '/' + d.getDate() + ' ' + d.getHours() + ':' + d.getMinutes() + ':' + d.getSeconds()\n        let dataTime = timeago.format(date, 'zh_CN');\n        let newdataTime = '<span class=\"datatime\">' + dataTime + '</span>'*/\n        bberHtml += '<div class=\"item timenode\" index=\"' + (i) + '\">'; //+ newdataTime + '： ' + urlToLink(item.content) + '</div>'\n        bberHtml += '<div class=\"header\">';\n        bberHtml += '<div class=\"user-info\">';\n        bberHtml += '<span>' + 'cqlkc' + '</span>';\n        bberHtml += '</div>';\n        bberHtml += '<span>' + new Date(item.createdAt).toLocaleString('zh-CN', {year:'2-digit',month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', hour12: false}) + '</span>';\n        bberHtml += '</div>';\n        bberHtml += '<a class=\"body\" href=\"' + '/bbtalk/' + '\">';\n        bberHtml += item.content;\n        bberHtml += '</a>';\n        bberHtml += '</div>';\n    });\n    document.getElementById(\"bber-talk\").innerHTML += '<i style=\"margin-right: 10px;\" class=\"fa-regular fa-message\"></i><div class=\"tag-plugin timeline\" api>' + bberHtml + '</div><i class=\"fa-solid fa-angles-right pass bber-icon\"></i>'\n}\n\nfunction getData() {\n    fetch(jsonUrl)\n        .then(res => res.json())\n        .then((data) => {\n            data = { time: Date.now(), ls: JSON.stringify(data.data.items) }\n            localStorage.setItem('bibi', JSON.stringify(data))\n        }).then(() => {\n            bbtalk();\n        }).catch(() => {\n            console.log('获取哔哔数据失败！');\n        });\n}\n\nfunction urlToLink(str) {\n    let re_forimg = /<img(.*?)src=[\\\"|\\']?(.*?)[\\\"|\\']?(.*?)>|!\\[(.*?)\\]\\((.*?)\\)/g;\n    str = str.replace(re_forimg, '<i class=\"fa-solid fa-image\"></i>');\n    return str\n}\n/*\nfunction Roll() {\n    try {\n        let list_li = Array.prototype.slice.call(document.querySelectorAll('.talk-list li'));\n        let tmp = list_li[0];\n        list_li.splice(0, 1);\n        list_li.push(tmp);\n        let list = document.querySelector('ul.talk-list')\n        list_li.forEach((item) => {\n            list.appendChild(item)\n        });\n    } catch (error) {}\n};\nsetInterval(Roll, 3000);*/"},{"path":"/js/bibi.js","content":"let svg = '<svg  viewBox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\" class=\"is-badge\"><path  d=\"m512 268c0 17.9-4.3 34.5-12.9 49.7s-20.1 27.1-34.6 35.4c.4 2.7.6 6.9.6 12.6 0 27.1-9.1 50.1-27.1 69.1-18.1 19.1-39.9 28.6-65.4 28.6-11.4 0-22.3-2.1-32.6-6.3-8 16.4-19.5 29.6-34.6 39.7-15 10.2-31.5 15.2-49.4 15.2-18.3 0-34.9-4.9-49.7-14.9-14.9-9.9-26.3-23.2-34.3-40-10.3 4.2-21.1 6.3-32.6 6.3-25.5 0-47.4-9.5-65.7-28.6-18.3-19-27.4-42.1-27.4-69.1 0-3 .4-7.2 1.1-12.6-14.5-8.4-26-20.2-34.6-35.4-8.5-15.2-12.8-31.8-12.8-49.7 0-19 4.8-36.5 14.3-52.3s22.3-27.5 38.3-35.1c-4.2-11.4-6.3-22.9-6.3-34.3 0-27 9.1-50.1 27.4-69.1s40.2-28.6 65.7-28.6c11.4 0 22.3 2.1 32.6 6.3 8-16.4 19.5-29.6 34.6-39.7 15-10.1 31.5-15.2 49.4-15.2s34.4 5.1 49.4 15.1c15 10.1 26.6 23.3 34.6 39.7 10.3-4.2 21.1-6.3 32.6-6.3 25.5 0 47.3 9.5 65.4 28.6s27.1 42.1 27.1 69.1c0 12.6-1.9 24-5.7 34.3 16 7.6 28.8 19.3 38.3 35.1 9.5 15.9 14.3 33.4 14.3 52.4zm-266.9 77.1 105.7-158.3c2.7-4.2 3.5-8.8 2.6-13.7-1-4.9-3.5-8.8-7.7-11.4-4.2-2.7-8.8-3.6-13.7-2.9-5 .8-9 3.2-12 7.4l-93.1 140-42.9-42.8c-3.8-3.8-8.2-5.6-13.1-5.4-5 .2-9.3 2-13.1 5.4-3.4 3.4-5.1 7.7-5.1 12.9 0 5.1 1.7 9.4 5.1 12.9l58.9 58.9 2.9 2.3c3.4 2.3 6.9 3.4 10.3 3.4 6.7-.1 11.8-2.9 15.2-8.7z\" fill=\"#1da1f2\"></path></svg>'\nlet total = 0\nlet nowNum = 0\nlet items = []\nlet page = 1\nlet Url = 'https://kkapi.keee.top/api/ispeak?author=633aaa45d0d52c818b1cf9c1&page=' // 修改api，记得带参数page\n\n\nwindow.addEventListener('DOMContentLoaded', () => {\n    getNew();\n});\n\n// 获取数据\nfunction getNew() {\n    let bibi = document.getElementById('bibi');\n    try {\n        bibi.removeChild(document.getElementById('more'))\n    } catch (error) {}\n\n    bibi.innerHTML += '<div id=\"loading\"><img src=\"https://cdn.afdelivr.top/npm/cqlkc_img@1.0.13/img/loading.gif\" alt=\"loading\"></div>' // loading图片可以f12在我网站源码下载，也可以使用其他图片。\n\n    fetch(Url + page).then(res => res.json()).then((res) => {\n        total = res.data.total\n        items = res.data.items\n        nowNum += items.length\n        if (page == 1) {\n            document.querySelector('.bb-info').innerHTML = '<i class=\"far fa-comment-alt\"></i> My bibi(' + total + ')'\n        }\n        page += 1\n    }).then(() => {\n        bb();\n        if (nowNum < total) {\n            document.getElementById('bibi').innerHTML += '<button id=\"more\" onclick=\"getNew()\">下一页</button>'\n        }\n        document.getElementById('bibi').removeChild(document.getElementById('loading'))\n    })\n}\n\n// 渲染数据\nfunction bb() {\n    let bb = document.getElementById('bb-main')\n    items.forEach((item) => {\n        let time = item.createdAt.substring(0, 10);\n        let div = document.createElement('div')\n        item.content = contentFormat(item.content)\n\n        div.className = 'bb-card'\n        div.innerHTML = '<div class=\"card-header\"><div class=\"avatar\"><img class=\"nofancybox\"src=\"' + item.author.avatar + '\"></div><div class=\"name\">' + item.author.nickName + '</div>' + svg + '<div class=\"card-time\">' + time + '</div></div><div class=\"card-content\">' + item.content + '</div><div class=\"card-footer\"><div data-v-185689ea=\"\"class=\"card-label\"style=\"background: ' + item.tag.bgColor + '; color: white;\">' + item.tag.name + '</div></div>'\n        bb.appendChild(div)\n    })\n}\n\n// content格式化\nfunction contentFormat(s) {\n    let br = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n    let re_forimg = /<img(.*?)src=[\\\"|\\']?(.*?)[\\\"|\\']?(.*?)>|!\\[(.*?)\\]\\((.*?)\\)/g;\n    let getImgUrl = /(http(.*).[jpg|png|gif])/g;\n    let ls = s.match(getImgUrl)\n    s = s.replace(re_forimg, '')\n    s = s.replace(br, '')\n\n    let html = '<br>'\n    if (ls) {\n        ls.forEach((e) => {\n            html += '<a href=\"' + e + '\" target=\"_blank\" data-fancybox=\"group\" class=\"fancybox\"><img src=\"' + e + '\"></a>'\n        })\n    }\n    s += html\n    return s\n}"},{"path":"/js/biggerimg.js","content":"// 如果当前页有评论就执行函数\nfunction pjaxbigger(){\nif (document.getElementById('post-comment')) owoBig();\n// 表情放大\nfunction owoBig() {\n    let flag = 1, // 设置节流阀\n        owo_time = '', // 设置计时器\n        m = 3; // 设置放大倍数\n    // 创建盒子\n    let div = document.createElement('div'),\n        body = document.querySelector('body');\n    // 设置ID\n    div.id = 'owo-big';\n    // 插入盒子\n    body.appendChild(div)\n\n    // 构造observer\n    let observer = new MutationObserver(mutations => {\n\n        for (let i = 0; i < mutations.length; i++) {\n            let dom = mutations[i].addedNodes,\n                owo_body = '';\n            if (dom.length == 2 && dom[1].className == 'OwO-body') owo_body = dom[1];\n            // 如果需要在评论内容中启用此功能请解除下面的注释\n            else if (dom.length == 1 && dom[0].className == 'tk-comment') owo_body = dom[0];\n            else continue;\n            \n            // 禁用右键（手机端长按会出现右键菜单，为了体验给禁用掉）\n            if (document.body.clientWidth <= 768) owo_body.addEventListener('contextmenu', e => e.preventDefault());\n            // 鼠标移入\n            owo_body.onmouseover = (e) => {\n                    if (flag && e.target.tagName == 'IMG') {\n                        flag = 0;\n                        // 移入300毫秒后显示盒子\n                        owo_time = setTimeout(() => {\n                            let height = e.path[0].clientHeight * m, // 盒子高\n                                width = e.path[0].clientWidth * m, // 盒子宽\n                                left = (e.x - e.offsetX) - (width - e.path[0].clientWidth) / 2, // 盒子与屏幕左边距离\n                                top = e.y - e.offsetY; // 盒子与屏幕顶部距离\n\n                            if ((left + width) > body.clientWidth) left -= ((left + width) - body.clientWidth + 10); // 右边缘检测，防止超出屏幕\n                            if (left < 0) left = 10; // 左边缘检测，防止超出屏幕\n                            // 设置盒子样式\n                            div.style.cssText = `display:flex; height:${height}px; width:${width}px; left:${left}px; top:${top}px;`;\n                            // 在盒子中插入图片\n                            div.innerHTML = `<img src=\"${e.target.src}\">`\n                        }, 300);\n                    }\n                };\n            // 鼠标移出隐藏盒子\n            owo_body.onmouseout = () => { div.style.display = 'none', flag = 1, clearTimeout(owo_time); }\n        }\n\n    })\n    observer.observe(document.getElementById('post-comment'), { subtree: true, childList: true }) // 监听的 元素 和 配置项\n}\n}\npjaxbigger();\ndocument.addEventListener('pjax:complete', () => {\n    pjaxbigger();\n})"},{"path":"/js/functions.js","content":"function load_ispeak() {\n  if(!document.querySelectorAll(\"#ispeak\")[0])return;\n  const scriptUrls = [\n    'https://cdn.jsdmirror.com/npm/ispeak/ispeak.umd.js',\n    'https://s4.zstatic.net/ajax/libs/highlight.js/10.6.0/highlight.min.js',\n    'https://s4.zstatic.net/ajax/libs/marked/2.0.0/marked.min.js',\n    'https://s4.zstatic.net/ajax/libs/twikoo/1.6.38/twikoo.all.min.js '\n  ];\n  scriptUrls.forEach(url => {\n    // 检查是否已存在该脚本\n    if (![...document.scripts].some(script => script.src === url)) {\n      const script = document.createElement('script');\n      script.src = url;\n      script.setAttribute('data-no-instant', '');\n      script.async = false; // 保持执行顺序（如有需要）\n      document.body.appendChild(script);\n    }\n  });\n    \n};\nfunction pjax_ispeak() {\n    if(!document.querySelectorAll(\"#ispeak\")[0])return;\n    ispeak\n      .init({\n        el: '#ispeak',//不用改\n        api: 'https://kkapi.keee.top/', //填写你kkapi地址（不是kkadmin后台地址！）\n        author: '633aaa45d0d52c818b1cf9c1',//填写个人ID\n        pageSize: 10,//每页speak显示的条数（建议保持默认，除非你要魔改css）\n        loading_img: '/img/iloading.svg',//加载动画\n        comment: function (speak) {\n          const { _id, title, content } = speak\n          const contentSub = content.substring(0, 30)\n          twikoo.init({\n            envId: 'https://twikoo-netlify-c.netlify.app/.netlify/functions/twikoo', // 腾讯云环境填 envId；Vercel 环境填地址（https://xxx.vercel.app）\n            el: '.ispeak-comment', // 不用改\n            //region: 'ap-guangzhou', // 环境地域，默认为 ap-shanghai，腾讯云环境填 ap-shanghai 或 ap-guangzhou；Vercel 环境不填\n            path: '/speak/info.html?q=' + _id, //不用改，除非你将上面的speak改为别的文件夹昵称\n            lang: 'zh-CN', // 用于手动设定评论区语言，支持的语言列表 https://github.com/imaegoo/twikoo/blob/main/src/client/utils/i18n/index.js\n          })\n        }\n      });\n}\nclass SummaryHandler {\n  constructor(options) {\n    this.backendUrl = options.backendUrl || \"https://qwen.keee.top\";\n    this.contentCursor = document.getElementById(options.contentId || \"markd-content\");\n    this.outputCursor = document.getElementById(options.outputId || \"post-ai-result-text\");\n    this.loadingText = document.getElementById(options.loadingId || \"result-loading\");\n    this.aiLogoCursor = document.getElementById(options.logoId || \"ai-logo\");\n    this.postTitleCursor = document.getElementsByClassName(options.titleClass || \"article-title\");\n\n    if (!this.outputCursor || !this.contentCursor || !this.aiLogoCursor) {\n      throw new Error(\"Required DOM elements are missing.\");\n    }\n\n    this.apiUrl = this.backendUrl.endsWith(\"/\")\n      ? `${this.backendUrl}api/summary`\n      : `${this.backendUrl}/api/summary`;\n\n    this.typingTimeout = null;\n    this.shouldDisable = false;\n    this.summaryData = undefined;\n\n    this.init();\n  }\n\n  init() {\n    const url = new URL(location.href);\n    this.postId = url.pathname.split(\"/\").filter((e) => e !== \"\").pop();\n    this.content = this.contentCursor.textContent;\n    this.requestBody = {\n      postId: this.postId,\n      content: this.content,\n    };\n    this.fetchSummary();\n  }\n\n  addCursor() {\n    if (!this.outputCursor) {\n      console.error(\"Output cursor element is missing.\");\n      return;\n    }\n  \n    // 如果 `.ai-cursor` 不存在则创建\n    if (!this.outputCursor.querySelector(\".ai-cursor\")) {\n      const cursorSpan = document.createElement(\"span\");\n      cursorSpan.className = \"ai-cursor\";\n      this.outputCursor.appendChild(cursorSpan);\n    }\n  }\n  \n  typeWriter(index, text) {\n    if (this.loadingText) {\n      this.loadingText.remove();\n    }\n    this.aiLogoCursor.classList.add(\"typing\");\n  \n    const cursor = this.outputCursor.querySelector(\".ai-cursor\");\n    if (!cursor) {\n      console.error(\"Cursor element is missing. Please ensure addCursor is called before typeWriter.\");\n      return;\n    }\n  \n    if (index < text.length) {\n      cursor.insertAdjacentText(\"beforebegin\", text.charAt(index));\n      this.typingTimeout = setTimeout(() => this.typeWriter(index + 1, text), 20);\n    } else {\n      this.aiLogoCursor.classList.remove(\"typing\");\n      cursor.remove();\n      this.shouldDisable = false;\n    }\n  }\n  \n  inputSummary(data) {\n    const text = data;\n    this.shouldDisable = true;\n    clearTimeout(this.typingTimeout);\n  \n    // 添加 `.ai-cursor`（确保只执行一次）\n    this.addCursor();\n  \n    this.typeWriter(0, text);\n  }\n\n  fetchSummary() {\n    fetch(`${this.apiUrl}?postId=${this.postId}`, {\n      method: \"GET\",\n    })\n      .then((response) => response.json())\n      .then((data) => {\n        if (data.isSave) {\n          this.summaryData = data.data;\n          this.inputSummary(data.data);\n        } else {\n          this.postSummary();\n        }\n      })\n      .catch((error) => {\n        this.outputCursor.textContent = `${error}`;\n        console.error(\"Fetch error:\", error);\n      });\n  }\n\n  postSummary() {\n    fetch(this.apiUrl, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(this.requestBody),\n    })\n      .then((response) => response.json())\n      .then((data) => {\n        if (data.code === 1) {\n          this.summaryData = data.data;\n          this.inputSummary(data.data);\n        } else {\n          console.error(\"Error:\", data);\n        }\n      })\n      .catch((error) => {\n        this.outputCursor.textContent = `${error}`;\n        console.error(\"Fetch error:\", error);\n      });\n  }\n}\n\n  function fetchHitokoto(options = {}) {\n    const {\n        apiUrl = 'https://v1.hitokoto.cn', // 默认 API 地址\n        hitokotoElementId = 'hitokoto_all', // 显示句子的元素 ID\n        clickElementId = 'hitokoto_text'   // 可点击触发的元素 ID\n    } = options;\n\n    const hitokotoElement = document.getElementById(hitokotoElementId);\n    const clickElement = document.getElementById(clickElementId);\n\n    if (!hitokotoElement || !clickElement) {\n        console.error('指定的元素未找到，请检查元素 ID 是否正确。');\n        return;\n    }\n\n    // 用于跟踪点击次数的变量\n    let clickCount = 0;\n\n    // 加载句子的方法\n    function loadHitokoto() {\n        fetch(apiUrl)\n            .then(res => res.json())\n            .then(data => {\n                hitokotoElement.innerText = data.hitokoto;\n                if (data.from_who) {\n                    hitokotoElement.innerText += `  —— ${data.from_who}`;\n                }\n                if (data.from) {\n                    hitokotoElement.innerText += `《${data.from}》`;\n                }\n            })\n            .catch(err => {\n                console.error('获取 Hitokoto 失败：', err);\n            });\n    }\n\n    // 点击事件处理\n    clickElement.addEventListener('click', event => {\n        event.preventDefault(); // 阻止默认行为\n        clickCount++; // 增加点击次数\n\n        if (clickCount === 1) {\n            hitokotoElement.innerText = '别急，我在思考🤔';\n        } else if (clickCount === 2) {\n            hitokotoElement.innerText = '别急，我还在思考🤔';\n        } else if (clickCount <= 10) {\n            hitokotoElement.innerText = `你已经点击了 ${clickCount} 次🤣`;\n        } else {\n            hitokotoElement.innerText = '憋点了😅';\n        }\n    });\n\n    // 初次加载句子\n    loadHitokoto();\n}\n  \n  // 使用示例\n /* document.addEventListener(\"DOMContentLoaded\", () => {\n    new SummaryHandler({\n      backendUrl: \"https://qwen.keee.top\",\n      contentId: \"markd-content\",\n      outputId: \"post-ai-result-text\",\n      loadingId: \"result-loading\",\n      logoId: \"ai-logo\",\n      titleClass: \"article-title\",\n    });\n  });*/\n  document.addEventListener(\"DOMContentLoaded\", load_ispeak);\n  document.addEventListener(\"DOMContentLoaded\", fetchHitokoto);  \n  InstantClick.on(\"change\", load_ispeak);\n  InstantClick.on(\"change\", pjax_ispeak);\n\n  InstantClick.on(\"change\", () => {\n      if(!document.querySelectorAll(\"#markd-content\")[0])return;\n      new SummaryHandler({\n      backendUrl: \"https://qwen.keee.top\",\n      contentId: \"markd-content\",\n      outputId: \"post-ai-result-text\",\n      loadingId: \"result-loading\",\n      logoId: \"ai-logo\",\n      titleClass: \"article-title\",\n    });\n  });\n  InstantClick.on(\"change\", () => {\n    fetchHitokoto({\n      apiUrl: 'https://v1.hitokoto.cn',\n      hitokotoElementId: 'hitokoto_all',\n      clickElementId: 'hitokoto_text'\n  });\n  });"},{"path":"/js/ispeak.js","content":"function pia(){\n    var head = document.getElementsByTagName('head')[0]\n    var meta = document.createElement('meta')\n    meta.name = 'referrer'\n    meta.content = 'no-referrer'\n    head.appendChild(meta)\n    if (ispeak) {\n        ispeak\n        .init({\n            el: '#ispeak',\n            api: 'https://kkapi.keee.top/',\n            author: '633aaa45d0d52c818b1cf9c1',\n            pageSize: 10,\n            loading_img: 'https://bu.dusays.com/2022/05/01/626e88f349943.gif',\n            comment: \n            function (speak) {\n            // 4.4.0 之后在此回调函数中初始化评论\n            const { _id, title, content } = speak\n            const contentSub = content.substring(0, 30)\n            twikoo.init({\n                envId: 'https://twikoo-netlify-c.netlify.app/.netlify/functions/twikoo', // 腾讯云环境填 envId；Vercel 环境填地址（https://xxx.vercel.app）\n                pageTitle: title || contentSub, // 手动传入当前speak的标题(由于content可能过长，因此截取前30个字符)\n                site: 'bbtalk',\n                el: '.ispeak-comment', // 容器元素\n                // region: 'ap-guangzhou', // 环境地域，默认为 ap-shanghai，腾讯云环境填 ap-shanghai 或 ap-guangzhou；Vercel 环境不填\n                path:  '/bbtalk/info.html?q=' + _id, // 用于区分不同文章的自定义 js 路径，如果您的文章路径不是 location.pathname，需传此参数'/bbtalk/info.html?q=' +\n                // lang: 'zh-CN', // 用于手动设定评论区语言，支持的语言列表 https://github.com/imaegoo/twikoo/blob/main/src/client/utils/i18n/index.js\n                onCommentLoaded: function () {\n                \n            }\n            })\n            }\n        })\n        .then(function () {\n            console.log('ispeak 加载完成')\n            document.getElementById('tip').style.display = 'none'\n        })\n    } else {\n        document.getElementById('tip').innerHTML = 'ipseak依赖加载失败！'\n    }\n}\npia();\ndocument.addEventListener('pjax:complete', () => {\n    pia();\n})"},{"path":"/js/pace.js","content":"onload=function(){\n\t/*!\n\t * pace.js v1.2.4\n\t * https://github.com/CodeByZach/pace/\n\t * Licensed MIT © HubSpot, Inc.\n\t */\n\t(function(){var t,e,n,r,s,o,i,u,a,c,l,p,h,f,d,g,m,y,v,w,b,k,S,q,L,x,P,T,R,j,O,E,M,A,C,N,_,F,U,W,X,D,H,I,z,G,B,J,K,Q=[].slice,V={}.hasOwnProperty,Y=function(t,e){for(var n in e)V.call(e,n)&&(t[n]=e[n]);function r(){this.constructor=t}return r.prototype=e.prototype,t.prototype=new r,t.__super__=e.prototype,t},Z=[].indexOf||function(t){for(var e=0,n=this.length;e<n;e++)if(e in this&&this[e]===t)return e;return-1},$=function(t,e){return function(){return t.apply(e,arguments)}};for(k={className:\"\",catchupTime:100,initialRate:.03,minTime:250,ghostTime:100,maxProgressPerFrame:20,easeFactor:1.25,startOnPageLoad:!0,restartOnPushState:!0,restartOnRequestAfter:500,target:\"body\",elements:{checkInterval:100,selectors:[\"body\"]},eventLag:{minSamples:10,sampleCount:3,lagThreshold:3},ajax:{trackMethods:[\"GET\"],trackWebSockets:!0,ignoreURLs:[]}},j=function(){var t;return null!=(t=\"undefined\"!=typeof performance&&null!==performance&&\"function\"==typeof performance.now?performance.now():void 0)?t:+new Date},E=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame,b=window.cancelAnimationFrame||window.mozCancelAnimationFrame,g=function(t,e,n){return\"function\"==typeof t.addEventListener?t.addEventListener(e,n,!1):function(){if(\"function\"!=typeof t[\"on\"+e]||\"object\"!=typeof t[\"on\"+e].eventListeners){var r=new u;\"function\"==typeof t[\"on\"+e]&&r.on(e,t[\"on\"+e]),t[\"on\"+e]=function(t){return r.trigger(e,t)},t[\"on\"+e].eventListeners=r}else r=t[\"on\"+e].eventListeners;r.on(e,n)}()},null==E&&(E=function(t){return setTimeout(t,50)},b=function(t){return clearTimeout(t)}),A=function(t){var e,n;return e=j(),(n=function(){var r;return(r=j()-e)>=33?(e=j(),t(r,(function(){return E(n)}))):setTimeout(n,33-r)})()},M=function(){var t,e,n;return n=arguments[0],e=arguments[1],t=3<=arguments.length?Q.call(arguments,2):[],\"function\"==typeof n[e]?n[e].apply(n,t):n[e]},S=function(){var t,e,n,r,s,o,i;for(e=arguments[0],o=0,i=(r=2<=arguments.length?Q.call(arguments,1):[]).length;o<i;o++)if(n=r[o])for(t in n)V.call(n,t)&&(s=n[t],null!=e[t]&&\"object\"==typeof e[t]&&null!=s&&\"object\"==typeof s?S(e[t],s):e[t]=s);return e},y=function(t){var e,n,r,s,o;for(n=e=0,s=0,o=t.length;s<o;s++)r=t[s],n+=Math.abs(r),e++;return n/e},L=function(t,e){var n,r,s;if(null==t&&(t=\"options\"),null==e&&(e=!0),s=document.querySelector(\"[data-pace-\"+t+\"]\")){if(n=s.getAttribute(\"data-pace-\"+t),!e)return n;try{return JSON.parse(n)}catch(t){return r=t,\"undefined\"!=typeof console&&null!==console?console.error(\"Error parsing inline pace options\",r):void 0}}},i=function(){function t(){}return t.prototype.on=function(t,e,n,r){var s;return null==r&&(r=!1),null==this.bindings&&(this.bindings={}),null==(s=this.bindings)[t]&&(s[t]=[]),this.bindings[t].push({handler:e,ctx:n,once:r})},t.prototype.once=function(t,e,n){return this.on(t,e,n,!0)},t.prototype.off=function(t,e){var n,r,s;if(null!=(null!=(r=this.bindings)?r[t]:void 0)){if(null==e)return delete this.bindings[t];for(n=0,s=[];n<this.bindings[t].length;)this.bindings[t][n].handler===e?s.push(this.bindings[t].splice(n,1)):s.push(n++);return s}},t.prototype.trigger=function(){var t,e,n,r,s,o,i,u,a;if(n=arguments[0],t=2<=arguments.length?Q.call(arguments,1):[],null!=(i=this.bindings)?i[n]:void 0){for(s=0,a=[];s<this.bindings[n].length;)r=(u=this.bindings[n][s]).handler,e=u.ctx,o=u.once,r.apply(null!=e?e:this,t),o?a.push(this.bindings[n].splice(s,1)):a.push(s++);return a}},t}(),c=window.Pace||{},window.Pace=c,S(c,i.prototype),O=c.options=S({},k,window.paceOptions,L()),I=0,G=(J=[\"ajax\",\"document\",\"eventLag\",\"elements\"]).length;I<G;I++)!0===O[F=J[I]]&&(O[F]=k[F]);a=function(t){function e(){return e.__super__.constructor.apply(this,arguments)}return Y(e,t),e}(Error),e=function(){function t(){this.progress=0}return t.prototype.getElement=function(){var t;if(null==this.el){if(!(t=document.querySelector(O.target)))throw new a;this.el=document.createElement(\"div\"),this.el.className=\"pace pace-active\",document.body.className=document.body.className.replace(/(pace-done )/,\"pace-running \");var e=\"\"!==O.className?\" \"+O.className:\"\";this.el.innerHTML='<div class=\"pace-progress'+e+'\">\\n  <div class=\"pace-progress-inner\"></div>\\n</div>\\n<div class=\"pace-activity\"></div>',null!=t.firstChild?t.insertBefore(this.el,t.firstChild):t.appendChild(this.el)}return this.el},t.prototype.finish=function(){var t;return(t=this.getElement()).className=t.className.replace(\"pace-active\",\"pace-inactive\"),document.body.className=document.body.className.replace(\"pace-running \",\"pace-done \")},t.prototype.update=function(t){return this.progress=t,c.trigger(\"progress\",t),this.render()},t.prototype.destroy=function(){try{this.getElement().parentNode.removeChild(this.getElement())}catch(t){a=t}return this.el=void 0},t.prototype.render=function(){var t,e,n,r,s,o,i;if(null==document.querySelector(O.target))return!1;for(t=this.getElement(),r=\"translate3d(\"+this.progress+\"%, 0, 0)\",s=0,o=(i=[\"webkitTransform\",\"msTransform\",\"transform\"]).length;s<o;s++)e=i[s],t.children[0].style[e]=r;return(!this.lastRenderedProgress||this.lastRenderedProgress|0!==this.progress|0)&&(t.children[0].setAttribute(\"data-progress-text\",(0|this.progress)+\"%\"),this.progress>=100?n=\"99\":(n=this.progress<10?\"0\":\"\",n+=0|this.progress),t.children[0].setAttribute(\"data-progress\",\"\"+n)),c.trigger(\"change\",this.progress),this.lastRenderedProgress=this.progress},t.prototype.done=function(){return this.progress>=100},t}(),u=function(){function t(){this.bindings={}}return t.prototype.trigger=function(t,e){var n,r,s,o,i;if(null!=this.bindings[t]){for(i=[],r=0,s=(o=this.bindings[t]).length;r<s;r++)n=o[r],i.push(n.call(this,e));return i}},t.prototype.on=function(t,e){var n;return null==(n=this.bindings)[t]&&(n[t]=[]),this.bindings[t].push(e)},t}(),H=window.XMLHttpRequest,D=window.XDomainRequest,X=window.WebSocket,q=function(t,e){var n,r;for(n in r=[],e.prototype)try{null==t[n]&&\"function\"!=typeof e[n]?\"function\"==typeof Object.defineProperty?r.push(Object.defineProperty(t,n,{get:function(t){return function(){return e.prototype[t]}}(n),configurable:!0,enumerable:!0})):r.push(t[n]=e.prototype[n]):r.push(void 0)}catch(t){t}return r},T=[],c.ignore=function(){var t,e,n;return e=arguments[0],t=2<=arguments.length?Q.call(arguments,1):[],T.unshift(\"ignore\"),n=e.apply(null,t),T.shift(),n},c.track=function(){var t,e,n;return e=arguments[0],t=2<=arguments.length?Q.call(arguments,1):[],T.unshift(\"track\"),n=e.apply(null,t),T.shift(),n},_=function(t){var e;if(null==t&&(t=\"GET\"),\"track\"===T[0])return\"force\";if(!T.length&&O.ajax){if(\"socket\"===t&&O.ajax.trackWebSockets)return!0;if(e=t.toUpperCase(),Z.call(O.ajax.trackMethods,e)>=0)return!0}return!1},l=function(t){function e(){var t,n=this;e.__super__.constructor.apply(this,arguments),t=function(t){var e;return e=t.open,t.open=function(r,s,o){return _(r)&&n.trigger(\"request\",{type:r,url:s,request:t}),e.apply(t,arguments)}},window.XMLHttpRequest=function(e){var n;return n=new H(e),t(n),n};try{q(window.XMLHttpRequest,H)}catch(t){}if(null!=D){window.XDomainRequest=function(){var e;return e=new D,t(e),e};try{q(window.XDomainRequest,D)}catch(t){}}if(null!=X&&O.ajax.trackWebSockets){window.WebSocket=function(t,e){var r;return r=null!=e?new X(t,e):new X(t),_(\"socket\")&&n.trigger(\"request\",{type:\"socket\",url:t,protocols:e,request:r}),r};try{q(window.WebSocket,X)}catch(t){}}}return Y(e,t),e}(u),z=null,N=function(t){var e,n,r,s;for(n=0,r=(s=O.ajax.ignoreURLs).length;n<r;n++)if(\"string\"==typeof(e=s[n])){if(-1!==t.indexOf(e))return!0}else if(e.test(t))return!0;return!1},(x=function(){return null==z&&(z=new l),z})().on(\"request\",(function(e){var n,r,s,o,i;if(o=e.type,s=e.request,i=e.url,!N(i))return c.running||!1===O.restartOnRequestAfter&&\"force\"!==_(o)?void 0:(r=arguments,\"boolean\"==typeof(n=O.restartOnRequestAfter||0)&&(n=0),setTimeout((function(){var e,n,i,u,a;if(\"socket\"===o?s.readyState<1:0<(i=s.readyState)&&i<4){for(c.restart(),a=[],e=0,n=(u=c.sources).length;e<n;e++){if((F=u[e])instanceof t){F.watch.apply(F,r);break}a.push(void 0)}return a}}),n))})),t=function(){function t(){this.complete=$(this.complete,this);var t=this;this.elements=[],x().on(\"request\",(function(){return t.watch.apply(t,arguments)}))}return t.prototype.watch=function(t){var e,n,r,s;if(r=t.type,e=t.request,s=t.url,!N(s))return n=\"socket\"===r?new f(e,this.complete):new d(e,this.complete),this.elements.push(n)},t.prototype.complete=function(t){return this.elements=this.elements.filter((function(e){return e!==t}))},t}(),d=function(t,e){var n,r,s,o,i=this;if(this.progress=0,null!=window.ProgressEvent)for(g(t,\"progress\",(function(t){return t.lengthComputable?i.progress=100*t.loaded/t.total:i.progress=i.progress+(100-i.progress)/2})),n=0,r=(o=[\"load\",\"abort\",\"timeout\",\"error\"]).length;n<r;n++)g(t,o[n],(function(){return e(i),i.progress=100}));else s=t.onreadystatechange,t.onreadystatechange=function(){var n;return 0===(n=t.readyState)||4===n?(e(i),i.progress=100):3===t.readyState&&(i.progress=50),\"function\"==typeof s?s.apply(null,arguments):void 0}},f=function(t,e){var n,r,s,o=this;for(this.progress=0,n=0,r=(s=[\"error\",\"open\"]).length;n<r;n++)g(t,s[n],(function(){return e(o),o.progress=100}))},r=function(){function t(t){var e,n,r,o;for(null==t&&(t={}),this.complete=$(this.complete,this),this.elements=[],null==t.selectors&&(t.selectors=[]),n=0,r=(o=t.selectors).length;n<r;n++)e=o[n],this.elements.push(new s(e,this.complete))}return t.prototype.complete=function(t){return this.elements=this.elements.filter((function(e){return e!==t}))},t}(),s=function(){function t(t,e){this.selector=t,this.completeCallback=e,this.progress=0,this.check()}return t.prototype.check=function(){var t=this;return document.querySelector(this.selector)?this.done():setTimeout((function(){return t.check()}),O.elements.checkInterval)},t.prototype.done=function(){return this.completeCallback(this),this.completeCallback=null,this.progress=100},t}(),n=function(){function t(){var t,e,n=this;this.progress=null!=(e=this.states[document.readyState])?e:100,t=document.onreadystatechange,document.onreadystatechange=function(){return null!=n.states[document.readyState]&&(n.progress=n.states[document.readyState]),\"function\"==typeof t?t.apply(null,arguments):void 0}}return t.prototype.states={loading:0,interactive:50,complete:100},t}(),o=function(){var t,e,n,r,s,o=this;this.progress=0,t=0,s=[],r=0,n=j(),e=setInterval((function(){var i;return i=j()-n-50,n=j(),s.push(i),s.length>O.eventLag.sampleCount&&s.shift(),t=y(s),++r>=O.eventLag.minSamples&&t<O.eventLag.lagThreshold?(o.progress=100,clearInterval(e)):o.progress=3/(t+3)*100}),50)},h=function(){function t(t){this.source=t,this.last=this.sinceLastUpdate=0,this.rate=O.initialRate,this.catchup=0,this.progress=this.lastProgress=0,null!=this.source&&(this.progress=M(this.source,\"progress\"))}return t.prototype.tick=function(t,e){var n;return null==e&&(e=M(this.source,\"progress\")),e>=100&&(this.done=!0),e===this.last?this.sinceLastUpdate+=t:(this.sinceLastUpdate&&(this.rate=(e-this.last)/this.sinceLastUpdate),this.catchup=(e-this.progress)/O.catchupTime,this.sinceLastUpdate=0,this.last=e),e>this.progress&&(this.progress+=this.catchup*t),n=1-Math.pow(this.progress/100,O.easeFactor),this.progress+=n*this.rate*t,this.progress=Math.min(this.lastProgress+O.maxProgressPerFrame,this.progress),this.progress=Math.max(0,this.progress),this.progress=Math.min(100,this.progress),this.lastProgress=this.progress,this.progress},t}(),U=null,C=null,v=null,W=null,m=null,w=null,c.running=!1,P=function(){if(O.restartOnPushState)return c.restart()},null!=window.history.pushState&&(B=window.history.pushState,window.history.pushState=function(){return P(),B.apply(window.history,arguments)}),null!=window.history.replaceState&&(K=window.history.replaceState,window.history.replaceState=function(){return P(),K.apply(window.history,arguments)}),p={ajax:t,elements:r,document:n,eventLag:o},(R=function(){var t,n,r,s,o,i,u,a;for(c.sources=U=[],n=0,s=(i=[\"ajax\",\"elements\",\"document\",\"eventLag\"]).length;n<s;n++)!1!==O[t=i[n]]&&U.push(new p[t](O[t]));for(r=0,o=(a=null!=(u=O.extraSources)?u:[]).length;r<o;r++)F=a[r],U.push(new F(O));return c.bar=v=new e,C=[],W=new h})(),c.stop=function(){return c.trigger(\"stop\"),c.running=!1,v.destroy(),w=!0,null!=m&&(\"function\"==typeof b&&b(m),m=null),R()},c.restart=function(){return c.trigger(\"restart\"),c.stop(),c.start()},c.go=function(){var t;return c.running=!0,v.render(),t=j(),w=!1,m=A((function(e,n){var r,s,o,i,u,a,l,p,f,d,g,m,y,b,k;for(100-v.progress,s=d=0,o=!0,a=g=0,y=U.length;g<y;a=++g)for(F=U[a],f=null!=C[a]?C[a]:C[a]=[],l=m=0,b=(u=null!=(k=F.elements)?k:[F]).length;m<b;l=++m)i=u[l],o&=(p=null!=f[l]?f[l]:f[l]=new h(i)).done,p.done||(s++,d+=p.tick(e));return r=d/s,v.update(W.tick(e,r)),v.done()||o||w?(v.update(100),c.trigger(\"done\"),setTimeout((function(){return v.finish(),c.running=!1,c.trigger(\"hide\")}),Math.max(O.ghostTime,Math.max(O.minTime-(j()-t),0)))):n()}))},c.start=function(t){S(O,t),c.running=!0;try{v.render()}catch(t){a=t}return document.querySelector(\".pace\")?(c.trigger(\"start\"),c.go()):setTimeout(c.start,50)},\"function\"==typeof define&&define.amd?define((function(){return c})):\"object\"==typeof exports?module.exports=c:O.startOnPageLoad&&c.start()}).call(this)}"},{"path":"/js/pjax.js","content":"/*document.addEventListener(\"pjax:complete\", function () {\n    load_twikoo();\n    window.lazyLoadInstance?.update();\n});*/\ndocument.addEventListener('pjax:complete', function () {\n    document.querySelectorAll('script[data-pjax]').forEach(item => {\n      const newScript = document.createElement('script')\n      const content = item.text || item.textContent || item.innerHTML || \"\"\n      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))\n      newScript.appendChild(document.createTextNode(content))\n      item.parentNode.replaceChild(newScript, item)\n    })\n    load_twikoo();\n    window.lazyLoadInstance?.update();\n});\ndocument.addEventListener('pjax:error', (e) => {\n    if (e.request.status === 404) {\n      pjax.loadUrl('/404.html')\n    }\n  })"},{"path":"/js/pwa.js","content":"//重定向浏览器地址\npjax.site_handleResponse = pjax.handleResponse;\npjax.handleResponse = function(responseText, request, href, options){\n  Object.defineProperty(request,'responseURL',{\n    value: href\n  });\n  pjax.site_handleResponse(responseText,request,href,options);\n}"},{"path":"/js/summary.js","content":"function load_summary() {\n  let backendUrl = \"https://qwen.keee.top\";\n      let contentCursor = document.getElementById(\"markd-content\");\n      let outputCursor = document.getElementById(\"post-ai-result-text\");\n      let loadingText = document.getElementById(\"result-loading\");\n      let aiLogoCursor = document.getElementById(\"ai-logo\");\n      let postTitleCursor = document.getElementsByClassName(\"article-title\");\n\n      // 获取 postId 和 content\n      let url = new URL(location.href);\n      let postId = url.pathname\n        .split(\"/\")\n        .filter((e) => e !== \"\")\n        .pop();\n      let content = contentCursor.textContent;\n\n      // 处理 backendUrl 可能以 / 结尾的情况\n      let apiUrl = backendUrl.endsWith(\"/\")\n        ? `${backendUrl}api/summary`\n        : `${backendUrl}/api/summary`;\n\n      // 构建请求体\n      let requestBody = {\n        postId: postId,\n        content: content,\n      };\n\n      // 光标效果\n      let addCursor = () => {\n        let cursorSpan = document.createElement(\"span\");\n        cursorSpan.className = \"ai-cursor\";\n        outputCursor.appendChild(cursorSpan);\n      };\n\n      // 插入光标\n      addCursor();\n\n      // 打字效果\n      let typingTimeout;\n      let shouldDisable = false;\n\n      let typeWriter = (index, text) => {\n        if (loadingText) {\n          loadingText.remove();\n        }\n        aiLogoCursor.classList.add(\"typing\");\n        if (index < text.length) {\n          // 在光标前面插入文本\n          let cursor = document.querySelector(\".ai-cursor\");\n          cursor.insertAdjacentText(\"beforebegin\", text.charAt(index));\n\n          index++;\n\n          typingTimeout = setTimeout(() => typeWriter(index, text), 20); // 调整打字速度\n        } else {\n          aiLogoCursor.classList.remove(\"typing\");\n          document.querySelector(\".ai-cursor\")?.remove(); // 移除光标\n\n          shouldDisable = false;\n        }\n      };\n\n      // 摘要输入\n      let inputSummary = (data) => {\n        let outputElement = outputCursor;\n        let text = data;\n        let index = 0;\n        shouldDisable = true;\n\n        clearTimeout(typingTimeout);\n        typeWriter(index, text);\n      };\n\n      // 发送 GET 请求，获得摘要状态\n      let summaryData = undefined;\n\n      let fetchSummary = () => {\n        fetch(`${apiUrl}?postId=${postId}`, {\n          method: \"GET\",\n        })\n          .then((response) => response.json())\n          .then((data) => {\n            if (data.isSave) {\n              // 存入摘要\n              summaryData = data.data;\n              // 成功，模拟打字效果\n              inputSummary(data.data);\n            } else {\n              // 如果 isSave 为 false，发送 POST 请求\n              fetch(apiUrl, {\n                method: \"POST\",\n                headers: {\n                  \"Content-Type\": \"application/json\",\n                },\n                body: JSON.stringify(requestBody),\n              })\n                .then((response) => response.json())\n                .then((data) => {\n                  if (data.code === 1) {\n                    // 存入摘要\n                    summaryData = data.data;\n                    // 成功，模拟打字效果\n                    inputSummary(data.data);\n                  } else {\n                    // 客户端错误，输出响应内容\n                    console.error(\"Error:\", data);\n                  }\n                })\n                .catch((error) => {\n                  outputCursor.textContent = `${error}`;\n                  console.error(\"Fetch error:\", error);\n                });\n            }\n          })\n          .catch((error) => {\n            outputCursor.textContent = `${error}`;\n            console.error(\"Fetch error:\", error);\n          });\n      };\n\n      // 发送请求\n      fetchSummary();\n\n      // 监听 Logo 点击事件\n      /*\n      let switchMode = false;\n      aiLogoCursor.addEventListener(\"click\", () => {\n        if (!shouldDisable) {\n          if (!switchMode) {\n            // 介绍模式\n            let index = 0;\n            let text =\n              \"我是浮杨开发的摘要生成助理 QwenGPT，如你所见，这是一个使用 Qwen 14B 作为生成模型的工具。我在这里只负责显示，并仿照 GPT 的形式输出，如果你像我一样讨厌 Cloudflare Worker 的速度，又囊中羞涩，你也可以像我这样做，当然，你也可以使用 Tianli 开发的 TianliGPT 来更简单的实现 AI 摘要。当然，我的样式与代码很大一部分来自于無名大佬，感谢他的帮助！\";\n\n            shouldDisable = true;\n            switchMode = true;\n\n            clearTimeout(typingTimeout);\n\n            outputCursor.textContent = ``;\n\n            addCursor();\n            setTimeout(() => {\n              typeWriter(index, text);\n            }, 1000);\n          } else {\n            if (summaryData !== undefined) {\n              shouldDisable = true;\n              switchMode = false;\n\n              clearTimeout(typingTimeout);\n\n              outputCursor.textContent = ``;\n\n              addCursor();\n              inputSummary(summaryData);\n            }\n          }\n        }\n      });\n      postTitleCursor.addEventListener(\"click\", () => {\n        location.href = `/posts/qwen-summary`;\n      });*/\n}"},{"path":"/js/timeago.min.js","content":"!function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?t(exports):\"function\"==typeof define&&define.amd?define([\"exports\"],t):t((e=e||self).timeago={})}(this,function(e){\"use strict\";var r=[\"second\",\"minute\",\"hour\",\"day\",\"week\",\"month\",\"year\"];var a=[\"秒\",\"分钟\",\"小时\",\"天\",\"周\",\"个月\",\"年\"];function t(e,t){n[e]=t}function i(e){return n[e]||n.en_US}var n={},f=[60,60,24,7,365/7/12,12];function o(e){return e instanceof Date?e:!isNaN(e)||/^\\d+$/.test(e)?new Date(parseInt(e)):(e=(e||\"\").trim().replace(/\\.\\d+/,\"\").replace(/-/,\"/\").replace(/-/,\"/\").replace(/(\\d)T(\\d)/,\"$1 $2\").replace(/Z/,\" UTC\").replace(/([+-]\\d\\d):?(\\d\\d)/,\" $1$2\"),new Date(e))}function d(e,t){for(var n=e<0?1:0,r=e=Math.abs(e),a=0;e>=f[a]&&a<f.length;a++)e/=f[a];return(0===(a*=2)?9:1)<(e=Math.floor(e))&&(a+=1),t(e,a,r)[n].replace(\"%s\",e.toString())}function l(e,t){return((t?o(t):new Date)-o(e))/1e3}var s=\"timeago-id\";function h(e){return parseInt(e.getAttribute(s))}var p={},v=function(e){clearTimeout(e),delete p[e]};function m(e,t,n,r){v(h(e));var a=r.relativeDate,i=r.minInterval,o=l(t,a);e.innerText=d(o,n);var u,c=setTimeout(function(){m(e,t,n,r)},Math.min(1e3*Math.max(function(e){for(var t=1,n=0,r=Math.abs(e);e>=f[n]&&n<f.length;n++)e/=f[n],t*=f[n];return r=(r%=t)?t-r:t,Math.ceil(r)}(o),i||1),2147483647));p[c]=0,u=c,e.setAttribute(s,u)}t(\"en_US\",function(e,t){if(0===t)return[\"just now\",\"right now\"];var n=r[Math.floor(t/2)];return 1<e&&(n+=\"s\"),[e+\" \"+n+\" ago\",\"in \"+e+\" \"+n]}),t(\"zh_CN\",function(e,t){if(0===t)return[\"刚刚\",\"片刻后\"];var n=a[~~(t/2)];return[e+\" \"+n+\"前\",e+\" \"+n+\"后\"]}),e.cancel=function(e){e?v(h(e)):Object.keys(p).forEach(v)},e.format=function(e,t,n){return d(l(e,n&&n.relativeDate),i(t))},e.register=t,e.render=function(e,t,n){var r=e.length?e:[e];return r.forEach(function(e){m(e,e.getAttribute(\"datetime\"),i(t),n||{})}),r},Object.defineProperty(e,\"__esModule\",{value:!0})});"},{"path":"/js/tj-51.la.js","content":"(function(c){'use strict';var e=window,g=e['document'],h=encodeURIComponent,i=A('Object'),j=A('Number'),k=A('String'),m=A('Array'),n=A('Function'),o=A('RegExp');function q(t,u){return void 0x0!==t&&-0x1!==t['indexOf'](u);}function v(w,x){for(var y=0x0,z=w['length'];y<z;y++)if(w[y]==x)return y;return-0x1;}function A(B){return function(C){return Object['prototype']['toString']['call'](C)==='[object\\x20'['concat'](B,']');};}function D(){for(var E=0x0,F={};E<arguments['length'];E++){var G=arguments[E];for(var H in G)F[H]=G[H];}return F;}function I(J){return J['replace'](/&/g,'~_~');}function K(L){var M='';for(var N in L)''!==M&&(M+='&'),M+=N+'='+h(h(I(String(L[N]))));return M;}function O(P){return P['replace'](/^\\s+|\\s+$/g,'');}function Q(){return+new Date();}function R(S){var T=e['navigator']['userAgent'],U=new RegExp(/\\b(?:Chrome|CrMo|CriOS)\\/([\\d.]+)/)['exec'](T);return!(U&&U['length']&&U[0x1])||parseInt(U[0x1])>S;}var V={'root':e,'doc':g,'NFKivY':i,'SkKBjD':j,'qQXzeL':n,'QauvcB':o,'jPvmCm':k,'pWExzw':m,'xdaPuS':q,'extend':D,'NOwfJP':K,'trim':O,'now':Q,'arrayIndexOf':v,'checkChormeMoblie':R},W=function(){var X,Y=a2('meta'),Z=a2('title'),a0={'kw':'','ds':''};a0['tt']=V['trim'](Z['length']?Z[0x0]['innerHTML']:''),a0['tt']=a0['tt']['slice'](0x0,0x3e8);for(var a1=0x0;a1<Y['length'];a1++)Y[a1]['name']&&(X=Y[a1]['name']['toLowerCase'](),V['xdaPuS']('keywords',X)&&(a0['kw']=Y[a1]['content']),V['xdaPuS']('description',X)&&(a0['ds']=Y[a1]['content']['slice'](0x0,0x1e)));return a0;}();function a2(a3){return V['doc']['getElementsByTagName'](a3['toLowerCase']());}function a4(){var a5='';try{a5=V['root']['top']['document']['referrer'];}catch(a6){if(V['root']['parent'])try{a5=V['root']['parent']['document']['referrer'];}catch(a7){a5='';}}return''===a5&&(a5=V['doc']['referrer']),a5;}function a8(){var a9,aa=a2('meta'),ab=a2('title'),ac={'kw':'','ds':''};ac['tt']=V['trim'](ab['length']?ab[0x0]['innerHTML']:''),ac['tt']=ac['tt']['slice'](0x0,0x3e8);for(var ad=0x0;ad<aa['length'];ad++)aa[ad]['name']&&(a9=aa[ad]['name']['toLowerCase'](),V['xdaPuS']('keywords',a9)&&(ac['kw']=aa[ad]['content']),V['xdaPuS']('description',a9)&&(ac['ds']=aa[ad]['content']['slice'](0x0,0x1e)));return ac;}var ae={'ZNMTWj':W,'jcSWhb':a4,'getMeta1':a8},af=function(){var ag=String['fromCharCode'],ah={'dMsN':function(ai){return null==ai?'':ah['RCWS'](ai,0xf,function(ah){return ag(ah+0x20);})+'\\x20';},'QqPF':function(ag){for(var al=ah['Isoq'](ag),am=new Uint8Array(0x2*al['length']),an=0x0,ao=al['length'];an<ao;an++){var ap=al['charCodeAt'](an);am[0x2*an]=ap>>>0x8,am[0x2*an+0x1]=ap%0x100;}return am;},'zvqA':function(ag){return null==ag?'':ah['RCWS'](ag,0x6,function(ag){return'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$'['charAt'](ag);});},'Isoq':function(as){return ah['RCWS'](as,0x10,function(ah){return ag(ah);});},'RCWS':function(ag,ah,aw){if(null==ag)return'';var ax,ay,az,aA={},aB={},aC='',aD='',aE='',aF=0x2,aG=0x3,aH=0x2,aI=[],aJ=0x0,aK=0x0;for(az=0x0;az<ag['length'];az+=0x1)if(aC=ag['charAt'](az),Object['prototype']['hasOwnProperty']['call'](aA,aC)||(aA[aC]=aG++,aB[aC]=!0x0),aD=aE+aC,Object['prototype']['hasOwnProperty']['call'](aA,aD))aE=aD;else{if(Object['prototype']['hasOwnProperty']['call'](aB,aE)){if(aE['charCodeAt'](0x0)<0x100){for(ax=0x0;ax<aH;ax++)aJ<<=0x1,aK==ah-0x1?(aK=0x0,aI['push'](aw(aJ)),aJ=0x0):aK++;for(ay=aE['charCodeAt'](0x0),ax=0x0;ax<0x8;ax++)aJ=aJ<<0x1|0x1&ay,aK==ah-0x1?(aK=0x0,aI['push'](aw(aJ)),aJ=0x0):aK++,ay>>=0x1;}else{for(ay=0x1,ax=0x0;ax<aH;ax++)aJ=aJ<<0x1|ay,aK==ah-0x1?(aK=0x0,aI['push'](aw(aJ)),aJ=0x0):aK++,ay=0x0;for(ay=aE['charCodeAt'](0x0),ax=0x0;ax<0x10;ax++)aJ=aJ<<0x1|0x1&ay,aK==ah-0x1?(aK=0x0,aI['push'](aw(aJ)),aJ=0x0):aK++,ay>>=0x1;}0x0==--aF&&(aF=Math['pow'](0x2,aH),aH++),delete aB[aE];}else for(ay=aA[aE],ax=0x0;ax<aH;ax++)aJ=aJ<<0x1|0x1&ay,aK==ah-0x1?(aK=0x0,aI['push'](aw(aJ)),aJ=0x0):aK++,ay>>=0x1;0x0==--aF&&(aF=Math['pow'](0x2,aH),aH++),aA[aD]=aG++,aE=String(aC);}if(''!==aE){if(Object['prototype']['hasOwnProperty']['call'](aB,aE)){if(aE['charCodeAt'](0x0)<0x100){for(ax=0x0;ax<aH;ax++)aJ<<=0x1,aK==ah-0x1?(aK=0x0,aI['push'](aw(aJ)),aJ=0x0):aK++;for(ay=aE['charCodeAt'](0x0),ax=0x0;ax<0x8;ax++)aJ=aJ<<0x1|0x1&ay,aK==ah-0x1?(aK=0x0,aI['push'](aw(aJ)),aJ=0x0):aK++,ay>>=0x1;}else{for(ay=0x1,ax=0x0;ax<aH;ax++)aJ=aJ<<0x1|ay,aK==ah-0x1?(aK=0x0,aI['push'](aw(aJ)),aJ=0x0):aK++,ay=0x0;for(ay=aE['charCodeAt'](0x0),ax=0x0;ax<0x10;ax++)aJ=aJ<<0x1|0x1&ay,aK==ah-0x1?(aK=0x0,aI['push'](aw(aJ)),aJ=0x0):aK++,ay>>=0x1;}0x0==--aF&&(aF=Math['pow'](0x2,aH),aH++),delete aB[aE];}else for(ay=aA[aE],ax=0x0;ax<aH;ax++)aJ=aJ<<0x1|0x1&ay,aK==ah-0x1?(aK=0x0,aI['push'](aw(aJ)),aJ=0x0):aK++,ay>>=0x1;0x0==--aF&&(aF=Math['pow'](0x2,aH),aH++);}for(ay=0x2,ax=0x0;ax<aH;ax++)aJ=aJ<<0x1|0x1&ay,aK==ah-0x1?(aK=0x0,aI['push'](aw(aJ)),aJ=0x0):aK++,ay>>=0x1;for(;;){if(aJ<<=0x1,aK==ah-0x1){aI['push'](aw(aJ));break;}aK++;}return aI['join']('');}};return ah;}();function aL(aM){return(aL='function'==typeof Symbol&&'symbol'==typeof Symbol['iterator']?function(aM){return typeof aM;}:function(aM){return aM&&'function'==typeof Symbol&&aM['constructor']===Symbol&&aM!==Symbol['prototype']?'symbol':typeof aM;})(aM);}var aP={'parse':function gw(aV){return eval('('+aV+')');},'stringify':(aQ=Object['prototype']['toString'],aR=Object['prototype']['hasOwnProperty'],aS={'\"':'\\x5c\\x22','\\\\':'\\x5c\\x5c','\\b':'\\x5cb','\\f':'\\x5cf','\\n':'\\x5cn','\\r':'\\x5cr','\\t':'\\x5ct'},aT=function(aW){return aS[aW]||'\\x5cu'+(aW['charCodeAt'](0x0)+0x10000)['toString'](0x10)['substr'](0x1);},aU=/[\\\\\"\\u0000-\\u001F\\u2028\\u2029]/g,function t(aX){if(null==aX)return'null';if('number'==typeof aX)return isFinite(aX)?aX['toString']():'null';if('boolean'==typeof aX)return aX['toString']();if('object'===aL(aX)){if('function'==typeof aX['toJSON'])return t(aX['toJSON']());if(b2=aX,'[object\\x20Array]'===aQ['call'](b2)){for(var aY='[',aZ=0x0;aZ<aX['length'];aZ++)aY+=(aZ?',\\x20':'')+t(aX[aZ]);return aY+']';}if('[object\\x20Object]'===aQ['call'](aX)){var b0=[];for(var b1 in aX)aR['call'](aX,b1)&&b0['push'](t(b1)+':\\x20'+t(aX[b1]));return'{'+b0['join'](',\\x20')+'}';}}var b2;return'\\x22'+aX['toString']()['replace'](aU,aT)+'\\x22';})},aQ,aR,aS,aT,aU;function b3(){if('undefined'!=typeof Uint8Array&&null!==Uint8Array){var b4=Uint8Array,b5=Uint16Array,b6=Uint32Array,b7=new b4([0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x1,0x1,0x2,0x2,0x2,0x2,0x3,0x3,0x3,0x3,0x4,0x4,0x4,0x4,0x5,0x5,0x5,0x5,0x0,0x0,0x0,0x0]),b8=new b4([0x0,0x0,0x0,0x0,0x1,0x1,0x2,0x2,0x3,0x3,0x4,0x4,0x5,0x5,0x6,0x6,0x7,0x7,0x8,0x8,0x9,0x9,0xa,0xa,0xb,0xb,0xc,0xc,0xd,0xd,0x0,0x0]),b9=new b4([0x10,0x11,0x12,0x0,0x8,0x7,0x9,0x6,0xa,0x5,0xb,0x4,0xc,0x3,0xd,0x2,0xe,0x1,0xf]),ba=function(b4,b7){for(var b8=new b5(0x1f),b9=0x0;b9<0x1f;++b9)b8[b9]=b7+=0x1<<b4[b9-0x1];var ba=new b6(b8[0x1e]);for(b9=0x1;b9<0x1e;++b9)for(var bb=b8[b9];bb<b8[b9+0x1];++bb)ba[bb]=bb-b8[b9]<<0x5|b9;return[b8,ba];},bb=ba(b7,0x2),bc=bb[0x0],bd=bb[0x1];bc[0x1c]=0x102,bd[0x102]=0x1c;for(var bk=ba(b8,0x0),bl=(bk[0x0],bk[0x1]),bm=new b5(0x8000),bn=0x0;bn<0x8000;++bn){var bo=(0xaaaa&bn)>>>0x1|(0x5555&bn)<<0x1;bo=(0xf0f0&(bo=(0xcccc&bo)>>>0x2|(0x3333&bo)<<0x2))>>>0x4|(0xf0f&bo)<<0x4,bm[bn]=((0xff00&bo)>>>0x8|(0xff&bo)<<0x8)>>>0x1;}var bp=function(b4,b6,b7){for(var b8=b4['length'],b9=0x0,ba=new b5(b6);b9<b8;++b9)++ba[b4[b9]-0x1];var bb,bc=new b5(b6);for(b9=0x0;b9<b6;++b9)bc[b9]=bc[b9-0x1]+ba[b9-0x1]<<0x1;if(b7){bb=new b5(0x1<<b6);var bd=0xf-b6;for(b9=0x0;b9<b8;++b9)if(b4[b9])for(var bk=b9<<0x4|b4[b9],bl=b6-b4[b9],bn=bc[b4[b9]-0x1]++<<bl,bo=bn|(0x1<<bl)-0x1;bn<=bo;++bn)bb[bm[bn]>>>bd]=bk;}else for(bb=new b5(b8),b9=0x0;b9<b8;++b9)b4[b9]&&(bb[b9]=bm[bc[b4[b9]-0x1]++]>>>0xf-b4[b9]);return bb;},bq=new b4(0x120);for(bn=0x0;bn<0x90;++bn)bq[bn]=0x8;for(bn=0x90;bn<0x100;++bn)bq[bn]=0x9;for(bn=0x100;bn<0x118;++bn)bq[bn]=0x7;for(bn=0x118;bn<0x120;++bn)bq[bn]=0x8;var bE=new b4(0x20);for(bn=0x0;bn<0x20;++bn)bE[bn]=0x5;var bF=bp(bq,0x9,0x0),bG=bp(bE,0x5,0x0),bH=function(b4){return(b4/0x8|0x0)+(0x7&b4&&0x1);},bI=function(b7,b8,b9){(null==b8||b8<0x0)&&(b8=0x0),(null==b9||b9>b7['length'])&&(b9=b7['length']);var ba=new(b7 instanceof b5?b5:b7 instanceof b6?b6:b4)(b9-b8);return ba['set'](b7['subarray'](b8,b9)),ba;},bJ=function(b4,b5,b6){b6<<=0x7&b5;var b7=b5/0x8|0x0;b4[b7]|=b6,b4[b7+0x1]|=b6>>>0x8;},bK=function(b4,b5,b6){b6<<=0x7&b5;var b7=b5/0x8|0x0;b4[b7]|=b6,b4[b7+0x1]|=b6>>>0x8,b4[b7+0x2]|=b6>>>0x10;},bL=function(b6,b7){for(var b8=[],b9=0x0;b9<b6['length'];++b9)b6[b9]&&b8['push']({'s':b9,'f':b6[b9]});var ba=b8['length'],bb=b8['slice']();if(!ba)return[bS,0x0];if(0x1==ba){var bc=new b4(b8[0x0]['s']+0x1);return bc[b8[0x0]['s']]=0x1,[bc,0x1];}b8['sort'](function(b4,b5){return b4['f']-b5['f'];}),b8['push']({'s':-0x1,'f':0x61a9});var bd=b8[0x0],bk=b8[0x1],bl=0x0,bm=0x1,bn=0x2;for(b8[0x0]={'s':-0x1,'f':bd['f']+bk['f'],'l':bd,'r':bk};bm!=ba-0x1;)bd=b8[b8[bl]['f']<b8[bn]['f']?bl++:bn++],bk=b8[bl!=bm&&b8[bl]['f']<b8[bn]['f']?bl++:bn++],b8[bm++]={'s':-0x1,'f':bd['f']+bk['f'],'l':bd,'r':bk};var bo=bb[0x0]['s'];for(b9=0x1;b9<ba;++b9)bb[b9]['s']>bo&&(bo=bb[b9]['s']);var bp=new b5(bo+0x1),bq=bM(b8[bm-0x1],bp,0x0);if(bq>b7){b9=0x0;var bE=0x0,bF=bq-b7,bG=0x1<<bF;for(bb['sort'](function(b4,b5){return bp[b5['s']]-bp[b4['s']]||b4['f']-b5['f'];});b9<ba;++b9){var bH=bb[b9]['s'];if(!(bp[bH]>b7))break;bE+=bG-(0x1<<bq-bp[bH]),bp[bH]=b7;}for(bE>>>=bF;bE>0x0;){var bI=bb[b9]['s'];bp[bI]<b7?bE-=0x1<<b7-bp[bI]++-0x1:++b9;}for(;b9>=0x0&&bE;--b9){var bJ=bb[b9]['s'];bp[bJ]==b7&&(--bp[bJ],++bE);}bq=b7;}return[new b4(bp),bq];},bM=function b4(b5,b6,b7){return-0x1==b5['s']?Math['max'](b4(b5['l'],b6,b7+0x1),b4(b5['r'],b6,b7+0x1)):b6[b5['s']]=b7;},bN=function(b4){for(var b6=b4['length'];b6&&!b4[--b6];);for(var b7=new b5(++b6),b8=0x0,b9=b4[0x0],ba=0x1,bb=function(b4){b7[b8++]=b4;},bc=0x1;bc<=b6;++bc)if(b4[bc]==b9&&bc!=b6)++ba;else{if(!b9&&ba>0x2){for(;ba>0x8a;ba-=0x8a)bb(0x7ff2);ba>0x2&&(bb(ba>0xa?ba-0xb<<0x5|0x7012:ba-0x3<<0x5|0x3011),ba=0x0);}else if(ba>0x3){for(bb(b9),--ba;ba>0x6;ba-=0x6)bb(0x2070);ba>0x2&&(bb(ba-0x3<<0x5|0x2010),ba=0x0);}for(;ba--;)bb(b9);ba=0x1,b9=b4[bc];}return[b7['subarray'](0x0,b8),b6];},bO=function(b4,b5){for(var b6=0x0,b7=0x0;b7<b5['length'];++b7)b6+=b4[b7]*b5[b7];return b6;},bP=function(b4,b5,b6){var b7=b6['length'],b8=bH(b5+0x2);b4[b8]=0xff&b7,b4[b8+0x1]=b7>>>0x8,b4[b8+0x2]=0xff^b4[b8],b4[b8+0x3]=0xff^b4[b8+0x1];for(var b9=0x0;b9<b7;++b9)b4[b8+b9+0x4]=b6[b9];return 0x8*(b8+0x4+b7);},bQ=function(b4,b6,ba,bb,bc,bd,bk,bl,bm,bn,bo){bJ(b6,bo++,ba),++bc[0x100];for(var bH=bL(bc,0xf),bI=bH[0x0],bM=bH[0x1],bQ=bL(bd,0xf),bR=bQ[0x0],bS=bQ[0x1],bT=bN(bI),bU=bT[0x0],bV=bT[0x1],bW=bN(bR),bX=bW[0x0],bY=bW[0x1],bZ=new b5(0x13),c0=0x0;c0<bU['length'];++c0)bZ[0x1f&bU[c0]]++;for(c0=0x0;c0<bX['length'];++c0)bZ[0x1f&bX[c0]]++;for(var dw=bL(bZ,0x7),dx=dw[0x0],dy=dw[0x1],dz=0x13;dz>0x4&&!dx[b9[dz-0x1]];--dz);var dA,dB,dC,dD,dE=bn+0x5<<0x3,dF=bO(bc,bq)+bO(bd,bE)+bk,dG=bO(bc,bI)+bO(bd,bR)+bk+0xe+0x3*dz+bO(bZ,dx)+(0x2*bZ[0x10]+0x3*bZ[0x11]+0x7*bZ[0x12]);if(dE<=dF&&dE<=dG)return bP(b6,bo,b4['subarray'](bm,bm+bn));if(bJ(b6,bo,0x1+(dG<dF)),bo+=0x2,dG<dF){dA=bp(bI,bM,0x0),dB=bI,dC=bp(bR,bS,0x0),dD=bR;var dH=bp(dx,dy,0x0);bJ(b6,bo,bV-0x101),bJ(b6,bo+0x5,bY-0x1),bJ(b6,bo+0xa,dz-0x4),bo+=0xe;for(c0=0x0;c0<dz;++c0)bJ(b6,bo+0x3*c0,dx[b9[c0]]);bo+=0x3*dz;for(var dI=[bU,bX],dJ=0x0;dJ<0x2;++dJ){var dK=dI[dJ];for(c0=0x0;c0<dK['length'];++c0){var dL=0x1f&dK[c0];bJ(b6,bo,dH[dL]),bo+=dx[dL],dL>0xf&&(bJ(b6,bo,dK[c0]>>>0x5&0x7f),bo+=dK[c0]>>>0xc);}}}else dA=bF,dB=bq,dC=bG,dD=bE;for(c0=0x0;c0<bl;++c0)if(bb[c0]>0xff){dL=bb[c0]>>>0x12&0x1f;bK(b6,bo,dA[dL+0x101]),bo+=dB[dL+0x101],dL>0x7&&(bJ(b6,bo,bb[c0]>>>0x17&0x1f),bo+=b7[dL]);var dM=0x1f&bb[c0];bK(b6,bo,dC[dM]),bo+=dD[dM],dM>0x3&&(bK(b6,bo,bb[c0]>>>0x5&0x1fff),bo+=b8[dM]);}else bK(b6,bo,dA[bb[c0]]),bo+=dB[bb[c0]];return bK(b6,bo,dA[0x100]),bo+dB[0x100];},bR=new b6([0x10004,0x20008,0x20010,0x20020,0x40020,0x100080,0x100100,0x204400,0x205000]),bS=new b4(0x0),bT=function(){for(var b4=new Int32Array(0x100),b5=0x0;b5<0x100;++b5){for(var b6=b5,b7=0x9;--b7;)b6=(0x1&b6&&-0x12477ce0)^b6>>>0x1;b4[b5]=b6;}return b4;}(),bU=function(){var b4=-0x1;return{'p':function(b5){for(var b6=b4,b7=0x0;b7<b5['length'];++b7)b6=bT[0xff&b6^b5[b7]]^b6>>>0x8;b4=b6;},'d':function(){return~b4;}};},bV=function(b9,ba,bb,bc,bk){return function(b9,ba,bb,bc,bk,bm){var bn=b9['length'],bo=new b4(bc+bn+0x5*(0x1+Math['ceil'](bn/0x1b58))+bk),bp=bo['subarray'](bc,bo['length']-bk),bq=0x0;if(!ba||bn<0x8)for(var bE=0x0;bE<=bn;bE+=0xffff){var bF=bE+0xffff;bF<bn?bq=bP(bp,bq,b9['subarray'](bE,bF)):(bp[bE]=bm,bq=bP(bp,bq,b9['subarray'](bE,bn)));}else{for(var bG=bR[ba-0x1],bJ=bG>>>0xd,bK=0x1fff&bG,bL=(0x1<<bb)-0x1,bM=new b5(0x8000),bN=new b5(bL+0x1),bO=Math['ceil'](bb/0x3),bT=0x2*bO,bU=function(b4){return(b9[b4]^b9[b4+0x1]<<bO^b9[b4+0x2]<<bT)&bL;},bV=new b6(0x61a8),bW=new b5(0x120),bX=new b5(0x20),bY=0x0,bZ=0x0,c0=(bE=0x0,0x0),er=0x0,es=0x0;bE<bn;++bE){var eu=bU(bE),ev=0x7fff&bE,ew=bN[eu];if(bM[ev]=ew,bN[eu]=ev,er<=bE){var ex=bn-bE;if((bY>0x1b58||c0>0x6000)&&ex>0x1a7){bq=bQ(b9,bp,0x0,bV,bW,bX,bZ,c0,es,bE-es,bq),c0=bY=bZ=0x0,es=bE;for(var ey=0x0;ey<0x11e;++ey)bW[ey]=0x0;for(ey=0x0;ey<0x1e;++ey)bX[ey]=0x0;}var ez=0x2,eA=0x0,eB=bK,eC=ev-ew&0x7fff;if(ex>0x2&&eu==bU(bE-eC))for(var eD=Math['min'](bJ,ex)-0x1,eE=Math['min'](0x7fff,bE),eF=Math['min'](0x102,ex);eC<=eE&&--eB&&ev!=ew;){if(b9[bE+ez]==b9[bE+ez-eC]){for(var eG=0x0;eG<eF&&b9[bE+eG]==b9[bE+eG-eC];++eG);if(eG>ez){if(ez=eG,eA=eC,eG>eD)break;var eH=Math['min'](eC,eG-0x2),eI=0x0;for(ey=0x0;ey<eH;++ey){var eJ=bE-eC+ey+0x8000&0x7fff,eK=eJ-bM[eJ]+0x8000&0x7fff;eK>eI&&(eI=eK,ew=eJ);}}}eC+=(ev=ew)-(ew=bM[ev])+0x8000&0x7fff;}if(eA){bV[c0++]=0x10000000|bd[ez]<<0x12|bl[eA];var eL=0x1f&bd[ez],eM=0x1f&bl[eA];bZ+=b7[eL]+b8[eM],++bW[0x101+eL],++bX[eM],er=bE+ez,++bY;}else bV[c0++]=b9[bE],++bW[b9[bE]];}}bq=bQ(b9,bp,bm,bV,bW,bX,bZ,c0,es,bE-es,bq),!bm&&0x7&bq&&(bq=bP(bp,bq+0x1,bS));}return bI(bo,0x0,bc+bH(bq)+bk);}(b9,null==ba['level']?0x6:ba['level'],null==ba['mem']?Math['ceil'](1.5*Math['max'](0x8,Math['min'](0xd,Math['log'](b9['length'])))):0xc+ba['mem'],bb,bc,!bk);},bW=function(b4,b5,b6){for(;b6;++b5)b4[b5]=b6,b6>>>=0x8;},bX=function(b4,b5){var b6=b5['filename'];if(b4[0x0]=0x1f,b4[0x1]=0x8b,b4[0x2]=0x8,b4[0x8]=b5['level']<0x2?0x4:0x9==b5['level']?0x2:0x0,b4[0x9]=0x3,0x0!=b5['mtime']&&bW(b4,0x4,Math['floor'](new Date(b5['mtime']||Date['now']())/0x3e8)),b6){b4[0x3]=0x8;for(var b7=0x0;b7<=b6['length'];++b7)b4[b7+0xa]=b6['charCodeAt'](b7);}},bY=function(b4){return 0xa+(b4['filename']&&b4['filename']['length']+0x1||0x0);},bZ='undefined'!=typeof TextEncoder&&new TextEncoder(),c0='undefined'!=typeof TextDecoder&&new TextDecoder();try{c0['decode'](bS,{'stream':!0x0}),0x1;}catch(eV){}return{'gzipSync':function(b4,b5){b5||(b5={});var b6=bU(),b7=b4['length'];b6['p'](b4);var b8=bV(b4,b5,bY(b5),0x8),b9=b8['length'];return bX(b8,b5),bW(b8,b9-0x8,b6['d']()),bW(b8,b9-0x4,b7),b8;},'strToU8':function(b5,b6){if(b6){for(var b7=new b4(b5['length']),b8=0x0;b8<b5['length'];++b8)b7[b8]=b5['charCodeAt'](b8);return b7;}if(bZ)return bZ['encode'](b5);var b9=b5['length'],ba=new b4(b5['length']+(b5['length']>>0x1)),bb=0x0,bc=function(b4){ba[bb++]=b4;};for(b8=0x0;b8<b9;++b8){if(bb+0x5>ba['length']){var bd=new b4(bb+0x8+(b9-b8<<0x1));bd['set'](ba),ba=bd;}var bk=b5['charCodeAt'](b8);bk<0x80||b6?bc(bk):bk<0x800?(bc(0xc0|bk>>0x6),bc(0x80|0x3f&bk)):bk>0xd7ff&&bk<0xe000?(bc(0xf0|(bk=0x10000+(0xffc00&bk)|0x3ff&b5['charCodeAt'](++b8))>>0x12),bc(0x80|bk>>0xc&0x3f),bc(0x80|bk>>0x6&0x3f),bc(0x80|0x3f&bk)):(bc(0xe0|bk>>0xc),bc(0x80|bk>>0x6&0x3f),bc(0x80|0x3f&bk));}return bI(ba,0x0,bb);}};}return!0x1;}var fd=b3();function fe(){var ff,fg,fh,fi;return fi=V['root']['navigator']['userAgent'],V['root']['ActiveXObject']&&(fg=fi['indexOf']('MSIE\\x20'))>0x0?parseInt(fi['substring'](fg+0x5,fi['indexOf']('.',fg)),0xa):fi['indexOf']('Trident/')>0x0?(fh=fi['indexOf']('rv:'),parseInt(fi['substring'](fh+0x3,fi['indexOf']('.',fh)),0xa)):(ff=fi['indexOf']('Edge/'))>0x0&&parseInt(fi['substring'](ff+0x5,fi['indexOf']('.',ff)),0xa);}function fj(fk,fl,fm){var fn,fo,fp,fq,fr,fs,ft,fu=[],fv=[],fw=0x0,fx=fe()||NaN;function fy(fk,fl){var fm;return-0x1!==(fm=function(fk,fl){var fm,fn;if(null!=Array['prototype']['indexOf'])return fk['indexOf'](fl);for(fn=fk['length'],fm=-0x1;++fm<fn;)if(fk[fm]===fl)return fm;return-0x1;}(fv,fk))&&fv['splice'](fm,0x1),V['root']['laWaitTime']=new Date()['valueOf']()+0xa,''!==fl?fw-=0x12c:void 0x0;}function fG(fk,fl){return fk['onload']=null,fk['onerror']=null,fk['onabort']=null,fy(fk,fl);}return(fr=!!(fq=navigator['userAgent']['match'](/Chrom(e|ium)\\/([0-9]+)\\./))&&parseInt(fq[0x2],0xa))&&0x16>fr?fs=!0x1:(fs=!0x0,fp=navigator['userAgent'],'ArrayBufferView'in V['root']||(-0x1!==fp['indexOf']('Android')?fs=!0x1:-0x1!==fp['indexOf']('CPU\\x20OS\\x20')?(-0x1!==fp['indexOf']('CPU\\x20OS\\x206_')||-0x1!==fp['indexOf']('CPU\\x20OS\\x205_')||-0x1!==fp['indexOf']('CPU\\x20OS\\x204_')||-0x1!==fp['indexOf']('CPU\\x20OS\\x203_'))&&(fs=!0x1):-0x1!==fp['indexOf']('CPU\\x20iPhone\\x20OS\\x20')?(-0x1!==fp['indexOf']('iPhone\\x20OS\\x206_')||-0x1!==fp['indexOf']('iPhone\\x20OS\\x205_')||-0x1!==fp['indexOf']('iPhone\\x20OS\\x204_'))&&(fs=!0x1):-0x1!==fp['indexOf']('Intel\\x20Mac\\x20OS\\x20X')&&(-0x1!==fp['indexOf']('Mac\\x20OS\\x20X\\x2010_6')||-0x1!==fp['indexOf']('Mac\\x20OS\\x20X\\x2010_7'))&&(fs=!0x1))),fu=[],fv=[],ft='undefined'==typeof Uint8Array||null===Uint8Array?V['root']['XMLHttpRequest']&&0x7!==fx?af['dMsN'](aP['stringify'](fl)):af['zvqA'](aP['stringify'](fl)):fd['gzipSync'](fd['strToU8'](aP['stringify'](fl)),{'level':0x6,'mem':0x8}),fp=fk+(fk['indexOf']('?')<0x0?'?':'&')+'dt=4',V['root']['laWaitTime']=new Date()['valueOf']()+0x12c,V['root']['XMLHttpRequest']&&0x7!==fx?'withCredentials'in(fn=new XMLHttpRequest())?(fn['open']('POST',fp,!0x0),fn['withCredentials']=!0x0,fn['onreadystatechange']=function(){return 0x4===fn['readyState']&&(V['root']['laWaitTime']=new Date()['valueOf']()+0xa)&&function(fk){var fl;return-0x1!==(fl=fu['indexOf'](fk))?fu['splice'](fl,0x1):void 0x0;}(fn)&&0xc8===fn['status'];},fn['send']('undefined'!=typeof ArrayBuffer&&null!==ArrayBuffer?fs?ft:ft['buffer']:ft),fu['push'](fn)):'undefined'!=typeof XDomainRequest&&(fn=new XDomainRequest(),'http:'===document['location']['protocol']&&(fp=fk+(fk['indexOf']('?')<0x0?'?':'&')+'dt=1'),fn['open']('POST',fp),fn['onload']=function(){return fy(fn,fm);},fn['onerror']=function(fk){return fy(fn,fm);},fn['onprogress']=function(){return{};},fn['ontimeout']=function(){return{};},fn['send'](ft),fv['push'](fn)):('http:'===V['root']['location']['protocol']&&(fo=fk['replace']('https://','http://')+(fk['indexOf']('?')<0x0?'?':'&')+'dt=2&data='['concat'](ft)),fo['length']<=0x7f4&&function(fk,fl){var fm;return(fm=document['createElement']('img'))['width']=0x1,fm['height']=0x1,fm['onload']=function(){return fG(fm,fl);},fm['onerror']=fm['onabort']=function(){return fG(fm,fl);},fm['src']=fk,fv['push'](fm);}(fo,fm));}var fP={'report':fj},fQ={'get':function(fU){return decodeURIComponent(V['doc']['cookie']['replace'](new RegExp('(?:(?:^|.*;)\\x5cs*'+encodeURIComponent(fU)['replace'](/[-.+*]/g,'\\x5c$&')+'\\x5cs*\\x5c=s*([^;]*).*$)|^.*$'),'$1'))||null;},'set':function(fV,fW,fX,fY,fZ,g0){if(!fV||/^(?:expires|max-age|path|domain|secure)$/i['test'](fV))return!0x1;var g1='';if(fX)switch(fX['constructor']){case Number:g1=fX===0x1/0x0?';\\x20expires=Fri,\\x2031\\x20Dec\\x209999\\x2023:59:59\\x20GMT':';\\x20max-age='+fX;break;case String:g1=';\\x20expires='+fX;break;case Date:g1=';\\x20expires='+fX['toUTCString']();}return V['doc']['cookie']=encodeURIComponent(fV)+'='+encodeURIComponent(fW)+g1+(fZ?';\\x20domain='+fZ:'')+(fY?';\\x20path='+fY:'')+(g0?';\\x20secure':''),!0x0;}},fR={'get':function(g2){return aP['parse']((ae['isMobi']?V['root']['localStorage']['getItem'](g2):fQ['get'](g2))||'{}');},'set':function(g3,g4,g5,g6){return ae['isMobi']?V['root']['localStorage']['setItem'](g3,g4):fQ['set'](g3,g4,g5,g6);}},fS={'cookie':fQ,'store':fR},fT=V['doc']['addEventListener']?function(g7,g8,g9){g7['addEventListener'](g8,g9,!0x0);}:V['doc']['attachEvent']?function(ga,gb,gc){ga['attachEvent']('on'+gb,gc);}:function(gd,ge,gf){gd['on'+ge]=gf;};function gg(gh,gi,gj){for(var gk=gi['split']('\\x20'),gl=0x0,gm=gk['length'];gl<gm;gl++)fT(gh,gk[gl],gj);}var gn=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function go(gp){return'string'==typeof gp&&gn['test'](gp);}for(var gq=[],gr=0x0;gr<0x100;++gr)gq['push']((gr+0x100)['toString'](0x10)['substr'](0x1));function gs(gt){var gu=arguments['length']>0x1&&void 0x0!==arguments[0x1]?arguments[0x1]:0x0,gv=(gq[gt[gu+0x0]]+gq[gt[gu+0x1]]+gq[gt[gu+0x2]]+gq[gt[gu+0x3]]+'-'+gq[gt[gu+0x4]]+gq[gt[gu+0x5]]+'-'+gq[gt[gu+0x6]]+gq[gt[gu+0x7]]+'-'+gq[gt[gu+0x8]]+gq[gt[gu+0x9]]+'-'+gq[gt[gu+0xa]]+gq[gt[gu+0xb]]+gq[gt[gu+0xc]]+gq[gt[gu+0xd]]+gq[gt[gu+0xe]]+gq[gt[gu+0xf]])['toLowerCase']();if(!go(gv))throw TypeError('Stringified\\x20UUID\\x20is\\x20invalid');return gv;}function gw(gx){if(!go(gx))throw TypeError('Invalid\\x20UUID');var gy,gz=new Uint8Array(0x10);return gz[0x0]=(gy=parseInt(gx['slice'](0x0,0x8),0x10))>>>0x18,gz[0x1]=gy>>>0x10&0xff,gz[0x2]=gy>>>0x8&0xff,gz[0x3]=0xff&gy,gz[0x4]=(gy=parseInt(gx['slice'](0x9,0xd),0x10))>>>0x8,gz[0x5]=0xff&gy,gz[0x6]=(gy=parseInt(gx['slice'](0xe,0x12),0x10))>>>0x8,gz[0x7]=0xff&gy,gz[0x8]=(gy=parseInt(gx['slice'](0x13,0x17),0x10))>>>0x8,gz[0x9]=0xff&gy,gz[0xa]=(gy=parseInt(gx['slice'](0x18,0x24),0x10))/0x10000000000&0xff,gz[0xb]=gy/0x100000000&0xff,gz[0xc]=gy>>>0x18&0xff,gz[0xd]=gy>>>0x10&0xff,gz[0xe]=gy>>>0x8&0xff,gz[0xf]=0xff&gy,gz;}function gA(gB){gB=unescape(encodeURIComponent(gB));for(var gC=[],gD=0x0;gD<gB['length'];++gD)gC['push'](gB['charCodeAt'](gD));return gC;}var gE='6ba7b810-9dad-11d1-80b4-00c04fd430c8',gF='6ba7b811-9dad-11d1-80b4-00c04fd430c8';function gG(gH,gI,gJ){function gK(gH,gK,gN,gr){if('string'==typeof gH&&(gH=gA(gH)),'string'==typeof gK&&(gK=gw(gK)),0x10!==gK['length'])throw TypeError('Namespace\\x20must\\x20be\\x20array-like\\x20(16\\x20iterable\\x20integer\\x20values,\\x200-255)');var gP=new Uint8Array(0x10+gH['length']);if(gP['set'](gK),gP['set'](gH,gK['length']),(gP=gJ(gP))[0x6]=0xf&gP[0x6]|gI,gP[0x8]=0x3f&gP[0x8]|0x80,gN){gr=gr||0x0;for(var gQ=0x0;gQ<0x10;++gQ)gN[gr+gQ]=gP[gQ];return gN;}return gs(gP);}try{gK['name']=gH;}catch(gR){}return gK['DNS']=gE,gK['URL']=gF,gK;}function gS(gT,gU,gV,gW){switch(gT){case 0x0:return gU&gV^~gU&gW;case 0x1:return gU^gV^gW;case 0x2:return gU&gV^gU&gW^gV&gW;case 0x3:return gU^gV^gW;}}function gX(gY,gZ){return gY<<gZ|gY>>>0x20-gZ;}function h0(h1){var h2=[0x5a827999,0x6ed9eba1,0x8f1bbcdc,0xca62c1d6],h3=[0x67452301,0xefcdab89,0x98badcfe,0x10325476,0xc3d2e1f0];if('string'==typeof h1){var h4=unescape(encodeURIComponent(h1));h1=[];for(var h5=0x0;h5<h4['length'];++h5)h1['push'](h4['charCodeAt'](h5));}else Array['isArray'](h1)||(h1=Array['prototype']['slice']['call'](h1));h1['push'](0x80);for(var gr=h1['length']/0x4+0x2,h7=Math['ceil'](gr/0x10),h8=new Array(h7),h9=0x0;h9<h7;++h9){for(var ha=new Uint32Array(0x10),hb=0x0;hb<0x10;++hb)ha[hb]=h1[0x40*h9+0x4*hb]<<0x18|h1[0x40*h9+0x4*hb+0x1]<<0x10|h1[0x40*h9+0x4*hb+0x2]<<0x8|h1[0x40*h9+0x4*hb+0x3];h8[h9]=ha;}h8[h7-0x1][0xe]=0x8*(h1['length']-0x1)/Math['pow'](0x2,0x20),h8[h7-0x1][0xe]=Math['floor'](h8[h7-0x1][0xe]),h8[h7-0x1][0xf]=0x8*(h1['length']-0x1)&0xffffffff;for(var hc=0x0;hc<h7;++hc){for(var hd=new Uint32Array(0x50),he=0x0;he<0x10;++he)hd[he]=h8[hc][he];for(var hf=0x10;hf<0x50;++hf)hd[hf]=gX(hd[hf-0x3]^hd[hf-0x8]^hd[hf-0xe]^hd[hf-0x10],0x1);for(var hg=h3[0x0],hh=h3[0x1],hi=h3[0x2],hj=h3[0x3],hk=h3[0x4],hl=0x0;hl<0x50;++hl){var hm=Math['floor'](hl/0x14),hn=gX(hg,0x5)+gS(hm,hh,hi,hj)+hk+h2[hm]+hd[hl]>>>0x0;hk=hj,hj=hi,hi=gX(hh,0x1e)>>>0x0,hh=hg,hg=hn;}h3[0x0]=h3[0x0]+hg>>>0x0,h3[0x1]=h3[0x1]+hh>>>0x0,h3[0x2]=h3[0x2]+hi>>>0x0,h3[0x3]=h3[0x3]+hj>>>0x0,h3[0x4]=h3[0x4]+hk>>>0x0;}return[h3[0x0]>>0x18&0xff,h3[0x0]>>0x10&0xff,h3[0x0]>>0x8&0xff,0xff&h3[0x0],h3[0x1]>>0x18&0xff,h3[0x1]>>0x10&0xff,h3[0x1]>>0x8&0xff,0xff&h3[0x1],h3[0x2]>>0x18&0xff,h3[0x2]>>0x10&0xff,h3[0x2]>>0x8&0xff,0xff&h3[0x2],h3[0x3]>>0x18&0xff,h3[0x3]>>0x10&0xff,h3[0x3]>>0x8&0xff,0xff&h3[0x3],h3[0x4]>>0x18&0xff,h3[0x4]>>0x10&0xff,h3[0x4]>>0x8&0xff,0xff&h3[0x4]];}var ho=gG('v5',0x50,h0),hp=fS['store'];function hq(){return'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'['replace'](/[xy]/g,function(hr){var hs=0x10*Math['random']()|0x0;return('x'===hr?hs:0x3&hs|0x8)['toString'](0x10);})['toUpperCase']();}function ht(){return'placeholder'in document['createElement']('input');}function hu(){var hv=navigator['userAgent'];return!!(hv['indexOf']('compatible')>-0x1&&hv['indexOf']('MSIE')>-0x1)&&(new RegExp('MSIE\\x20(\\x5cd+\\x5c.\\x5cd+);')['test'](hv),parseFloat(RegExp['$1'])<0xa||!ht()||void 0x0);}function hw(){return'undefined'==typeof Uint8Array||null===Uint8Array;}function hx(hy){var hz=hy['connection']||hy['mozConnection']||hy['webkitConnection']||hy['oConnection'];return V['xdaPuS'](hy['userAgent'],'mobile')&&hz?hz['type']:'unknow';}function hA(hB,hC){var hD=new Date(new Date(new Date(new Date(new Date()['getTime']())['setHours'](0x0,0x0,0x0,0x0)))['getTime']()+0x5265c00-0x1)['getTime']();return hD-hB<=0x1b7740?hD:hB+hC;}function hE(hF,hG,hH){var hI,hJ=hA(hF,hG['SessionTimeout']),gr=hG['ck'];try{(hI=hp['get']('__vtins__'+gr))&&V['SkKBjD'](hI['expires'])&&hI['expires']<hF&&(hI=!0x1);}catch(hL){hI=!0x1;}var hM=hI&&V['jPvmCm'](hI['sid'])&&V['SkKBjD'](hI['expires'])&&hI['expires']>hF?0x0:0x1,hN=hM?0x1:hI['vd']+0x1,hO=hM?iE['xnFNCY']()||iE['noUint8Array']()?iE['KhuHSO']():ho('\\x0a\\x20\\x20\\x20\\x20'['concat'](gr,'\\x0a\\x20\\x20\\x20\\x20')['concat'](hH['userAgent'],'\\x0a\\x20\\x20\\x20\\x20')['concat'](hF,'\\x0a\\x20\\x20\\x20\\x20')['concat'](Math['random']()['toString'](0x24)['substr'](-0x8),'\\x0a\\x20\\x20'),iE['KhuHSO']()):hI['sid'],hP=hJ,gS=V['SkKBjD'](hI['ct'])&&parseInt(hF)-parseInt(hI['ct'])>0x0?parseInt(hF)-parseInt(hI['ct']):0x0,hR=V['SkKBjD'](hI['stt'])?parseInt(hI['stt'])+gS:gS;hp['set']('__vtins__'+gr,aP['stringify']({'sid':hO,'vd':hN,'stt':hR,'dr':gS,'expires':hP,'ct':hF}),null,'/');var hS=fS['cookie']['get']('__51uvsct__'+gr);return!V['SkKBjD'](parseInt(hS))||isNaN(parseInt(hS))?(fS['cookie']['set']('__51uvsct__'+gr,0x1,0x1/0x0,'/'),hS=0x1):0x0==gS&&(hS=parseInt(hS)+0x1,fS['cookie']['set']('__51uvsct__'+gr,hS,0x1/0x0,'/')),[hM,hM?hO:hp['get']('__vtins__'+gr)['sid'],hN,hR,gS,hS];}function hT(hU){return hU['language']||hU['browserLanguage'];}function hV(hW){var hX,hY,hZ='';return hX=V['root']['history']['pushState'],hY=V['root']['history']['replaceState'],null!=hX&&(V['root']['history']['pushState']=function(hY){return function(){return hY['prevUrl']=V['root']['location']['toString'](),hX['apply'](V['root']['history'],arguments),setTimeout(function(){return hW();},0x0);};}(this)),null!=hY&&(V['root']['history']['replaceState']=function(){return hZ=V['root']['location']['toString'](),hY['apply'](V['root']['history'],arguments),setTimeout(function(){return hW();},0x0);}),null!=hX&&(hZ=ae['jcSWhb'](),'function'==typeof Object['defineProperty']&&Object['defineProperty'](V['doc'],'referrer',{'get':function(){return hZ;},'configurable':!0x0}),gg(V['root'],'popstate',hW)),gg(V['root'],'hashchange',hW);}function i1(i2){if(null==i2)throw new TypeError('Cannot\\x20convert\\x20undefined\\x20or\\x20null\\x20to\\x20object');var i3=[];for(var i4 in i2)i2['hasOwnProperty'](i4)&&i3['push'](i4);return i3;}function i5(i6){return'[object\\x20Array]'==Object['prototype']['toString']['call'](i6);}function i7(i8,i9){if(i8['length']&&i5(i8)&&'function'==typeof i9){for(var ia=[],ib=0x0;ib<i8['length'];ib++){var ic=i8[ib];i9(ic,ib,i8)&&ia['push'](ic);}return ia;}return[];}function ie(ig,ih){if(!V['NFKivY'](ig)||!V['NFKivY'](ih))throw new Error('params\\x20error');for(var ii={},ij=[],ik=i7(i1(ig),function(ii){if(V['arrayIndexOf'](i1(ih),ii)>-0x1&&ih[ii]&&ih[ii](ig[ii]))return ij['push'](ii),!0x0;}),gr=0x0;gr<ik['length'];gr++)ii[ij[gr]]=ig[ij[gr]];return ii;}function io(ip){return new Date(ip)['toDateString']()===new Date()['toDateString']()||!(new Date(ip)<new Date())&&void 0x0;}function iq(){return!!navigator['userAgent']['match'](/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);}function ir(is){var it='';if(!(is['indexOf']('?')>-0x1))return null;var iu={};if(-0x1!=(it='?'['concat'](is['split']('?')[0x1]))['indexOf']('?'))for(var iv=it['substr'](0x1)['split']('&'),iw=0x0;iw<iv['length'];iw++){var gr=iv[iw]['split']('=')[0x0],iy=unescape(iv[iw]['split']('=')[0x1]);iu[gr]='true'===iy||'false'!==iy&&iy;}return iu;}function iz(iA,iB){iB=iB||window['location']['search'];var iC=new RegExp('(^|&)'+iA+'=([^&]*)(&|$)'),iD=iB['substr'](0x1)['match'](iC);return null!=iD?decodeURIComponent(iD[0x2]):'';}var iE={'hJdYQm':hx,'AczpQq':hE,'hKJlvN':hT,'DvIuqD':hV,'YCrNdE':ie,'ptHPZe':io,'KhuHSO':hq,'xnFNCY':hu,'noUint8Array':hw,'isMobile':iq,'GetQueryString':ir,'getQueryStringInURL':iz};function iF(iG,iH){var iI=fS['cookie']['get']('__51vcke__'+iG['ck']),iJ=fS['cookie']['get']('__51vuft__'+iG['ck']);try{fS['store']['get']('__vtins__'+iG['ck']);}catch(iK){!0x1;}var iL=V['now']();return iI?fS['cookie']['set']('__51vcke__'+iG['ck'],iI,0x1/0x0,'/'):(iI=iH,fS['cookie']['set']('__51vcke__'+iG['ck'],iH,0x1/0x0,'/')),iJ&&!isNaN(iJ)?(iJ=Number(iJ),fS['cookie']['set']('__51vuft__'+iG['ck'],iJ,0x1/0x0,'/')):(iJ=iL,fS['cookie']['set']('__51vuft__'+iG['ck'],iJ,0x1/0x0,'/')),iG['uid']=iI,iG['uft']=Number(iJ)||iL,iG;}function iM(iN,iO){var iP=!0x1,iQ=/sdk\\.51\\.la/['test'](iO),iR=document['getElementById']('LA_COLLECT');if(iR)iP=!iV(iU=iR['getAttribute']('src'));else for(var gr=document['getElementsByTagName']('script'),iT=0x0;iT<=gr['length']-0x1;iT++){var iU;if(iP=!0x0,(iU=gr[iT]['getAttribute']('src'))['indexOf']('js-sdk-pro.min.js')>=0x0){iP=!iV(iU);break;}}return iP?!iQ&&/^http[s]?/['test'](iO)?''['concat'](iO['replace'](/\\/$/,''),'/js-sdk-event.min.js?u=')['concat'](iN):!iQ&&/^\\/\\//['test'](iO)&&'//'!==iO?''['concat']('https:'===self['location']['protocol']?'https:':'http:')['concat'](iO['replace'](/\\/$/,''),'/js-sdk-event.min.js?u=')['concat'](iN):!iQ&&iO?'/'['concat'](iO['replace'](/\\/$/,'')['replace'](/^\\//,''),'/js-sdk-event.min.js?u=')['concat'](iN):'/js-sdk-event.min.js?u='['concat'](iN):('https:'===self['location']['protocol']?'https:':'http:')+'//sdk.51.la/event/js-sdk-event.min.js?u='['concat'](iN);}function iV(iW){return!!iW&&iW['indexOf']('sdk.51.la')>=0x0;}function iX(iY,iZ,j0){var j1=iM(iY,iZ?decodeURIComponent(iZ):''),j2=document['createElement']('script');j2['setAttribute']('id','LA_CODELESS'),j2['setAttribute']('src',j1),j2['setAttribute']('data-LA-ev',iY),j2['setAttribute']('crossorigin','anonymous'),j2['setAttribute']('charset','UTF-8'),document['getElementsByTagName']('head')[0x0]['appendChild'](j2),j2['readyState']?j2['onreadystatechange']=function(){('complete'==j2['readyState']||'loaded'==j2['readyState'])&&j0&&j0();}:j2['onload']=function(){j0&&j0();};}function j3(){var j4=arguments['length']>0x0&&void 0x0!==arguments[0x0]?arguments[0x0]:{};'{}'===aP['stringify'](j4)?V['root']['LA']&&(j4=V['root']['LA']['config']?V['extend'](j4,V['root']['LA']['config']):V['extend'](j4,V['root']['LA']['_config'])):V['root']['LA']['config']=j4;var j5=iE['YCrNdE'](j4,{'hashMode':function(j4){return'boolean'==typeof j4;},'SessionTimeout':function(j4){return!!(V['SkKBjD'](j4)&&j4>=0x1b7740&&j4<=0x6ddd00);},'autoTrack':function(j4){return'boolean'==typeof j4;},'prefix':function(j4){return'/'===j4?'':j4;}}),j6=V['root']['location'],j7=V['extend']({'url':('https:'===j6['protocol']?'https:':'http:')+'//collect-v6.51.la/v6/collect','id':j4['id'],'ck':j4['ck']||j4['id'],'hashMode':!0x1,'autoTrack':!0x1,'SessionTimeout':0x1b7740,'prefix':''},j5),j8=V['now'](),gr=V['root']['navigator'],ja=iE['AczpQq'](j8,j7,gr),jb=V['root']['screen'],jc=iE['xnFNCY']()||iE['noUint8Array']()?iE['KhuHSO']():ho('\\x0a\\x20\\x20\\x20\\x20'['concat'](j7['id'],'\\x0a\\x20\\x20\\x20\\x20')['concat'](gr['userAgent'],'\\x0a\\x20\\x20\\x20\\x20')['concat'](j8,'\\x0a\\x20\\x20\\x20\\x20')['concat'](ae['jcSWhb'](),'\\x0a\\x20\\x20\\x20\\x20')['concat'](jb['width']+'*'+jb['height'],'\\x0a\\x20\\x20\\x20\\x20')['concat'](ja[0x1],'\\x0a\\x20\\x20\\x20\\x20')['concat'](iE['hJdYQm'](gr),'\\x0a\\x20\\x20\\x20\\x20')['concat'](Math['random']()['toString'](0x24)['substr'](-0x8),'\\x0a\\x20\\x20'),iE['KhuHSO']()),jd=j6['href'],gS={'id':j7['id'],'rt':j8,'tt':ae['ZNMTWj']['tt'],'kw':ae['ZNMTWj']['kw'],'ds':ae['ZNMTWj']['ds'],'sid':ja[0x1],'cu':j6['href'],'pu':ae['jcSWhb'](),'rl':jb['width']+'*'+jb['height'],'lang':iE['hKJlvN'](gr),'ct':iE['hJdYQm'](gr),'svd':ja[0x2],'ce':gr['cookieEnabled']?0x1:0x0,'cd':jb['colorDepth']||jb['pixelDepth'],'stt':ja[0x3],'dr':ja[0x4],'uvsc':ja[0x5]},jf=iF(V['extend'](j7,gS),jc);gS['uid']=jf['uid'],gS['uft']=jf['uft'];var jk=iE['getQueryStringInURL']('LA_RM_TK')||'',jl=V['checkChormeMoblie'](0x2d);!jk&&jl&&fP['report'](j7['url'],gS,gS['uid']),j7['autoTrack']||!V['root']['LA']||V['root']['LA']['track']||(V['root']['LA']['track']=function(){V['root']['console']&&V['root']['console']['warn']&&console['warn']('自2022年5月1日起，51.LA事件分析功能将调整为默认不开启，如您需要继续使用，可查看配置教程进行开启->https://support.qq.com/products/400900/faqs/117264');}),j7['hashMode']&&iE['DvIuqD'](function(){if(jd!==V['root']['location']['href']){jd=V['root']['location']['href'];var j4=V['now'](),j5=iE['AczpQq'](j4,j7,gr),j6=ae['getMeta1'](),j8=(gS=V['extend'](gS,{'id':j7['id'],'pu':gS['cu'],'rt':j4,'tt':j6['tt'],'kw':j6['kw'],'ds':j6['ds'],'sid':j5[0x1],'svd':j5[0x2],'stt':j5[0x3],'dr':j5[0x4],'uvsc':j5[0x5],'cu':V['root']['location']['href']}))['uid']=iF(V['extend'](j7,gS),jc);gS['uid']=j8['uid'],gS['uft']=j8['uft'],jl&&fP['report'](j7['url'],gS,gS['uid']);}}),j7['autoTrack']&&jl&&iX(gS['id'],j7['prefix']);}V['root']['LA']&&V['root']['LA']['config']&&j3(),V['root']['LA']&&V['root']['LA']['ids']&&V['pWExzw'](V['root']['LA']['ids'])&&V['root']['LA']['ids']['length']>0x0&&(V['root']['LA']['_config']=V['root']['LA']['ids']['shift'](),j3());try{var jq=V['doc']['getElementById']('LA_COLLECT');if(jq){var jr=jq&&jq['getAttribute']('src')||'';if(jr){var js=iE['GetQueryString'](jr);js&&j3(js);}}}catch(jt){}c['init']=j3;}(this['LA']=this['LA']||{}));"},{"path":"/js/universe.js","content":"function dark() {\n    window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;\n    var n, e, i, h, t = .05,\n        s = document.getElementById(\"universe\"),\n        o = !0,\n        a = \"180,184,240\",\n        r = \"226,225,142\",\n        d = \"226,225,224\",\n        c = [];\n\n    function f() {\n        n = window.innerWidth, e = window.innerHeight, i = .216 * n, s.setAttribute(\"width\", n), s.setAttribute(\"height\", e)\n    }\n    function u() {\n        h.clearRect(0, 0, n, e);\n        for (var t = c.length, i = 0; i < t; i++) {\n            var s = c[i];\n            s.move(), s.fadeIn(), s.fadeOut(), s.draw()\n        }\n    }\n    function y() {\n        this.reset = function() {\n            this.giant = m(3), this.comet = !this.giant && !o && m(10), this.x = l(0, n - 10), this.y = l(0, e), this.r = l(1.1, 2.6), this.dx = l(t, 6 * t) + (this.comet + 1 - 1) * t * l(50, 120) + 2 * t, this.dy = -l(t, 6 * t) - (this.comet + 1 - 1) * t * l(50, 120), this.fadingOut = null, this.fadingIn = !0, this.opacity = 0, this.opacityTresh = l(.2, 1 - .4 * (this.comet + 1 - 1)), this.do = l(5e-4, .002) + .001 * (this.comet + 1 - 1)\n        }, this.fadeIn = function() {\n            this.fadingIn && (this.fadingIn = !(this.opacity > this.opacityTresh), this.opacity += this.do)\n        }, this.fadeOut = function() {\n            this.fadingOut && (this.fadingOut = !(this.opacity < 0), this.opacity -= this.do /2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle=\"rgba(\"+a+\",\"+this.opacity+\")\",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle=\"rgba(\"+d+\",\"+this.opacity+\")\",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle=\"rgba(\"+d+\",\"+(this.opacity-this.opacity/20 * t) + \")\", h.rect(this.x - this.dx / 4 * t, this.y - this.dy / 4 * t - 2, 2, 2), h.fill()\n        } else h.fillStyle = \"rgba(\" + r + \",\" + this.opacity + \")\", h.rect(this.x, this.y, this.r, this.r);\n            h.closePath(), h.fill()\n        }, this.move = function() {\n            this.x += this.dx, this.y += this.dy, !1 === this.fadingOut && this.reset(), (this.x > n - n / 4 || this.y < 0) && (this.fadingOut = !0)\n        }, setTimeout(function() {\n            o = !1\n        }, 50)\n    }\n    function m(t) {\n        return Math.floor(1e3 * Math.random()) + 1 < 10 * t\n    }\n    function l(t, i) {\n        return Math.random() * (i - t) + t\n    }\n    f(), window.addEventListener(\"resize\", f, !1), function() {\n        h = s.getContext(\"2d\");\n        for (var t = 0; t < i; t++) c[t] = new y, c[t].reset();\n        u()\n    }(), function t() {\n        document.getElementsByTagName('html')[0].getAttribute('data-theme') == 'dark' && u(), window.requestAnimationFrame(t)\n    }()\n};\ndark()"},{"title":"朋友文章","path":"/link/index.html","content":""},{"title":"留言板","path":"/liuyan/index.html","content":"有什么想说的都可以在这里评论哦！"},{"path":"/workbox-v5.1.3/workbox-background-sync.dev.js","content":"this.workbox = this.workbox || {};\nthis.workbox.backgroundSync = (function (exports, WorkboxError_js, logger_js, assert_js, getFriendlyURL_js, DBWrapper_js) {\n    'use strict';\n\n    try {\n      self['workbox:background-sync:5.1.3'] && _();\n    } catch (e) {}\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const DB_VERSION = 3;\n    const DB_NAME = 'workbox-background-sync';\n    const OBJECT_STORE_NAME = 'requests';\n    const INDEXED_PROP = 'queueName';\n    /**\n     * A class to manage storing requests from a Queue in IndexedDB,\n     * indexed by their queue name for easier access.\n     *\n     * @private\n     */\n\n    class QueueStore {\n      /**\n       * Associates this instance with a Queue instance, so entries added can be\n       * identified by their queue name.\n       *\n       * @param {string} queueName\n       * @private\n       */\n      constructor(queueName) {\n        this._queueName = queueName;\n        this._db = new DBWrapper_js.DBWrapper(DB_NAME, DB_VERSION, {\n          onupgradeneeded: this._upgradeDb\n        });\n      }\n      /**\n       * Append an entry last in the queue.\n       *\n       * @param {Object} entry\n       * @param {Object} entry.requestData\n       * @param {number} [entry.timestamp]\n       * @param {Object} [entry.metadata]\n       * @private\n       */\n\n\n      async pushEntry(entry) {\n        {\n          assert_js.assert.isType(entry, 'object', {\n            moduleName: 'workbox-background-sync',\n            className: 'QueueStore',\n            funcName: 'pushEntry',\n            paramName: 'entry'\n          });\n          assert_js.assert.isType(entry.requestData, 'object', {\n            moduleName: 'workbox-background-sync',\n            className: 'QueueStore',\n            funcName: 'pushEntry',\n            paramName: 'entry.requestData'\n          });\n        } // Don't specify an ID since one is automatically generated.\n\n\n        delete entry.id;\n        entry.queueName = this._queueName;\n        await this._db.add(OBJECT_STORE_NAME, entry);\n      }\n      /**\n       * Prepend an entry first in the queue.\n       *\n       * @param {Object} entry\n       * @param {Object} entry.requestData\n       * @param {number} [entry.timestamp]\n       * @param {Object} [entry.metadata]\n       * @private\n       */\n\n\n      async unshiftEntry(entry) {\n        {\n          assert_js.assert.isType(entry, 'object', {\n            moduleName: 'workbox-background-sync',\n            className: 'QueueStore',\n            funcName: 'unshiftEntry',\n            paramName: 'entry'\n          });\n          assert_js.assert.isType(entry.requestData, 'object', {\n            moduleName: 'workbox-background-sync',\n            className: 'QueueStore',\n            funcName: 'unshiftEntry',\n            paramName: 'entry.requestData'\n          });\n        }\n\n        const [firstEntry] = await this._db.getAllMatching(OBJECT_STORE_NAME, {\n          count: 1\n        });\n\n        if (firstEntry) {\n          // Pick an ID one less than the lowest ID in the object store.\n          entry.id = firstEntry.id - 1;\n        } else {\n          // Otherwise let the auto-incrementor assign the ID.\n          delete entry.id;\n        }\n\n        entry.queueName = this._queueName;\n        await this._db.add(OBJECT_STORE_NAME, entry);\n      }\n      /**\n       * Removes and returns the last entry in the queue matching the `queueName`.\n       *\n       * @return {Promise<Object>}\n       * @private\n       */\n\n\n      async popEntry() {\n        return this._removeEntry({\n          direction: 'prev'\n        });\n      }\n      /**\n       * Removes and returns the first entry in the queue matching the `queueName`.\n       *\n       * @return {Promise<Object>}\n       * @private\n       */\n\n\n      async shiftEntry() {\n        return this._removeEntry({\n          direction: 'next'\n        });\n      }\n      /**\n       * Returns all entries in the store matching the `queueName`.\n       *\n       * @param {Object} options See {@link module:workbox-background-sync.Queue~getAll}\n       * @return {Promise<Array<Object>>}\n       * @private\n       */\n\n\n      async getAll() {\n        return await this._db.getAllMatching(OBJECT_STORE_NAME, {\n          index: INDEXED_PROP,\n          query: IDBKeyRange.only(this._queueName)\n        });\n      }\n      /**\n       * Deletes the entry for the given ID.\n       *\n       * WARNING: this method does not ensure the deleted enry belongs to this\n       * queue (i.e. matches the `queueName`). But this limitation is acceptable\n       * as this class is not publicly exposed. An additional check would make\n       * this method slower than it needs to be.\n       *\n       * @private\n       * @param {number} id\n       */\n\n\n      async deleteEntry(id) {\n        await this._db.delete(OBJECT_STORE_NAME, id);\n      }\n      /**\n       * Removes and returns the first or last entry in the queue (based on the\n       * `direction` argument) matching the `queueName`.\n       *\n       * @return {Promise<Object>}\n       * @private\n       */\n\n\n      async _removeEntry({\n        direction\n      }) {\n        const [entry] = await this._db.getAllMatching(OBJECT_STORE_NAME, {\n          direction,\n          index: INDEXED_PROP,\n          query: IDBKeyRange.only(this._queueName),\n          count: 1\n        });\n\n        if (entry) {\n          await this.deleteEntry(entry.id);\n          return entry;\n        }\n      }\n      /**\n       * Upgrades the database given an `upgradeneeded` event.\n       *\n       * @param {Event} event\n       * @private\n       */\n\n\n      _upgradeDb(event) {\n        const db = event.target.result;\n\n        if (event.oldVersion > 0 && event.oldVersion < DB_VERSION) {\n          if (db.objectStoreNames.contains(OBJECT_STORE_NAME)) {\n            db.deleteObjectStore(OBJECT_STORE_NAME);\n          }\n        }\n\n        const objStore = db.createObjectStore(OBJECT_STORE_NAME, {\n          autoIncrement: true,\n          keyPath: 'id'\n        });\n        objStore.createIndex(INDEXED_PROP, INDEXED_PROP, {\n          unique: false\n        });\n      }\n\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const serializableProperties = ['method', 'referrer', 'referrerPolicy', 'mode', 'credentials', 'cache', 'redirect', 'integrity', 'keepalive'];\n    /**\n     * A class to make it easier to serialize and de-serialize requests so they\n     * can be stored in IndexedDB.\n     *\n     * @private\n     */\n\n    class StorableRequest {\n      /**\n       * Accepts an object of request data that can be used to construct a\n       * `Request` but can also be stored in IndexedDB.\n       *\n       * @param {Object} requestData An object of request data that includes the\n       *     `url` plus any relevant properties of\n       *     [requestInit]{@link https://fetch.spec.whatwg.org/#requestinit}.\n       * @private\n       */\n      constructor(requestData) {\n        {\n          assert_js.assert.isType(requestData, 'object', {\n            moduleName: 'workbox-background-sync',\n            className: 'StorableRequest',\n            funcName: 'constructor',\n            paramName: 'requestData'\n          });\n          assert_js.assert.isType(requestData.url, 'string', {\n            moduleName: 'workbox-background-sync',\n            className: 'StorableRequest',\n            funcName: 'constructor',\n            paramName: 'requestData.url'\n          });\n        } // If the request's mode is `navigate`, convert it to `same-origin` since\n        // navigation requests can't be constructed via script.\n\n\n        if (requestData['mode'] === 'navigate') {\n          requestData['mode'] = 'same-origin';\n        }\n\n        this._requestData = requestData;\n      }\n      /**\n       * Converts a Request object to a plain object that can be structured\n       * cloned or JSON-stringified.\n       *\n       * @param {Request} request\n       * @return {Promise<StorableRequest>}\n       *\n       * @private\n       */\n\n\n      static async fromRequest(request) {\n        const requestData = {\n          url: request.url,\n          headers: {}\n        }; // Set the body if present.\n\n        if (request.method !== 'GET') {\n          // Use ArrayBuffer to support non-text request bodies.\n          // NOTE: we can't use Blobs becuse Safari doesn't support storing\n          // Blobs in IndexedDB in some cases:\n          // https://github.com/dfahlander/Dexie.js/issues/618#issuecomment-398348457\n          requestData.body = await request.clone().arrayBuffer();\n        } // Convert the headers from an iterable to an object.\n\n\n        for (const [key, value] of request.headers.entries()) {\n          requestData.headers[key] = value;\n        } // Add all other serializable request properties\n\n\n        for (const prop of serializableProperties) {\n          if (request[prop] !== undefined) {\n            requestData[prop] = request[prop];\n          }\n        }\n\n        return new StorableRequest(requestData);\n      }\n      /**\n       * Returns a deep clone of the instances `_requestData` object.\n       *\n       * @return {Object}\n       *\n       * @private\n       */\n\n\n      toObject() {\n        const requestData = Object.assign({}, this._requestData);\n        requestData.headers = Object.assign({}, this._requestData.headers);\n\n        if (requestData.body) {\n          requestData.body = requestData.body.slice(0);\n        }\n\n        return requestData;\n      }\n      /**\n       * Converts this instance to a Request.\n       *\n       * @return {Request}\n       *\n       * @private\n       */\n\n\n      toRequest() {\n        return new Request(this._requestData.url, this._requestData);\n      }\n      /**\n       * Creates and returns a deep clone of the instance.\n       *\n       * @return {StorableRequest}\n       *\n       * @private\n       */\n\n\n      clone() {\n        return new StorableRequest(this.toObject());\n      }\n\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const TAG_PREFIX = 'workbox-background-sync';\n    const MAX_RETENTION_TIME = 60 * 24 * 7; // 7 days in minutes\n\n    const queueNames = new Set();\n    /**\n     * Converts a QueueStore entry into the format exposed by Queue. This entails\n     * converting the request data into a real request and omitting the `id` and\n     * `queueName` properties.\n     *\n     * @param {Object} queueStoreEntry\n     * @return {Object}\n     * @private\n     */\n\n    const convertEntry = queueStoreEntry => {\n      const queueEntry = {\n        request: new StorableRequest(queueStoreEntry.requestData).toRequest(),\n        timestamp: queueStoreEntry.timestamp\n      };\n\n      if (queueStoreEntry.metadata) {\n        queueEntry.metadata = queueStoreEntry.metadata;\n      }\n\n      return queueEntry;\n    };\n    /**\n     * A class to manage storing failed requests in IndexedDB and retrying them\n     * later. All parts of the storing and replaying process are observable via\n     * callbacks.\n     *\n     * @memberof module:workbox-background-sync\n     */\n\n\n    class Queue {\n      /**\n       * Creates an instance of Queue with the given options\n       *\n       * @param {string} name The unique name for this queue. This name must be\n       *     unique as it's used to register sync events and store requests\n       *     in IndexedDB specific to this instance. An error will be thrown if\n       *     a duplicate name is detected.\n       * @param {Object} [options]\n       * @param {Function} [options.onSync] A function that gets invoked whenever\n       *     the 'sync' event fires. The function is invoked with an object\n       *     containing the `queue` property (referencing this instance), and you\n       *     can use the callback to customize the replay behavior of the queue.\n       *     When not set the `replayRequests()` method is called.\n       *     Note: if the replay fails after a sync event, make sure you throw an\n       *     error, so the browser knows to retry the sync event later.\n       * @param {number} [options.maxRetentionTime=7 days] The amount of time (in\n       *     minutes) a request may be retried. After this amount of time has\n       *     passed, the request will be deleted from the queue.\n       */\n      constructor(name, {\n        onSync,\n        maxRetentionTime\n      } = {}) {\n        this._syncInProgress = false;\n        this._requestsAddedDuringSync = false; // Ensure the store name is not already being used\n\n        if (queueNames.has(name)) {\n          throw new WorkboxError_js.WorkboxError('duplicate-queue-name', {\n            name\n          });\n        } else {\n          queueNames.add(name);\n        }\n\n        this._name = name;\n        this._onSync = onSync || this.replayRequests;\n        this._maxRetentionTime = maxRetentionTime || MAX_RETENTION_TIME;\n        this._queueStore = new QueueStore(this._name);\n\n        this._addSyncListener();\n      }\n      /**\n       * @return {string}\n       */\n\n\n      get name() {\n        return this._name;\n      }\n      /**\n       * Stores the passed request in IndexedDB (with its timestamp and any\n       * metadata) at the end of the queue.\n       *\n       * @param {Object} entry\n       * @param {Request} entry.request The request to store in the queue.\n       * @param {Object} [entry.metadata] Any metadata you want associated with the\n       *     stored request. When requests are replayed you'll have access to this\n       *     metadata object in case you need to modify the request beforehand.\n       * @param {number} [entry.timestamp] The timestamp (Epoch time in\n       *     milliseconds) when the request was first added to the queue. This is\n       *     used along with `maxRetentionTime` to remove outdated requests. In\n       *     general you don't need to set this value, as it's automatically set\n       *     for you (defaulting to `Date.now()`), but you can update it if you\n       *     don't want particular requests to expire.\n       */\n\n\n      async pushRequest(entry) {\n        {\n          assert_js.assert.isType(entry, 'object', {\n            moduleName: 'workbox-background-sync',\n            className: 'Queue',\n            funcName: 'pushRequest',\n            paramName: 'entry'\n          });\n          assert_js.assert.isInstance(entry.request, Request, {\n            moduleName: 'workbox-background-sync',\n            className: 'Queue',\n            funcName: 'pushRequest',\n            paramName: 'entry.request'\n          });\n        }\n\n        await this._addRequest(entry, 'push');\n      }\n      /**\n       * Stores the passed request in IndexedDB (with its timestamp and any\n       * metadata) at the beginning of the queue.\n       *\n       * @param {Object} entry\n       * @param {Request} entry.request The request to store in the queue.\n       * @param {Object} [entry.metadata] Any metadata you want associated with the\n       *     stored request. When requests are replayed you'll have access to this\n       *     metadata object in case you need to modify the request beforehand.\n       * @param {number} [entry.timestamp] The timestamp (Epoch time in\n       *     milliseconds) when the request was first added to the queue. This is\n       *     used along with `maxRetentionTime` to remove outdated requests. In\n       *     general you don't need to set this value, as it's automatically set\n       *     for you (defaulting to `Date.now()`), but you can update it if you\n       *     don't want particular requests to expire.\n       */\n\n\n      async unshiftRequest(entry) {\n        {\n          assert_js.assert.isType(entry, 'object', {\n            moduleName: 'workbox-background-sync',\n            className: 'Queue',\n            funcName: 'unshiftRequest',\n            paramName: 'entry'\n          });\n          assert_js.assert.isInstance(entry.request, Request, {\n            moduleName: 'workbox-background-sync',\n            className: 'Queue',\n            funcName: 'unshiftRequest',\n            paramName: 'entry.request'\n          });\n        }\n\n        await this._addRequest(entry, 'unshift');\n      }\n      /**\n       * Removes and returns the last request in the queue (along with its\n       * timestamp and any metadata). The returned object takes the form:\n       * `{request, timestamp, metadata}`.\n       *\n       * @return {Promise<Object>}\n       */\n\n\n      async popRequest() {\n        return this._removeRequest('pop');\n      }\n      /**\n       * Removes and returns the first request in the queue (along with its\n       * timestamp and any metadata). The returned object takes the form:\n       * `{request, timestamp, metadata}`.\n       *\n       * @return {Promise<Object>}\n       */\n\n\n      async shiftRequest() {\n        return this._removeRequest('shift');\n      }\n      /**\n       * Returns all the entries that have not expired (per `maxRetentionTime`).\n       * Any expired entries are removed from the queue.\n       *\n       * @return {Promise<Array<Object>>}\n       */\n\n\n      async getAll() {\n        const allEntries = await this._queueStore.getAll();\n        const now = Date.now();\n        const unexpiredEntries = [];\n\n        for (const entry of allEntries) {\n          // Ignore requests older than maxRetentionTime. Call this function\n          // recursively until an unexpired request is found.\n          const maxRetentionTimeInMs = this._maxRetentionTime * 60 * 1000;\n\n          if (now - entry.timestamp > maxRetentionTimeInMs) {\n            await this._queueStore.deleteEntry(entry.id);\n          } else {\n            unexpiredEntries.push(convertEntry(entry));\n          }\n        }\n\n        return unexpiredEntries;\n      }\n      /**\n       * Adds the entry to the QueueStore and registers for a sync event.\n       *\n       * @param {Object} entry\n       * @param {Request} entry.request\n       * @param {Object} [entry.metadata]\n       * @param {number} [entry.timestamp=Date.now()]\n       * @param {string} operation ('push' or 'unshift')\n       * @private\n       */\n\n\n      async _addRequest({\n        request,\n        metadata,\n        timestamp = Date.now()\n      }, operation) {\n        const storableRequest = await StorableRequest.fromRequest(request.clone());\n        const entry = {\n          requestData: storableRequest.toObject(),\n          timestamp\n        }; // Only include metadata if it's present.\n\n        if (metadata) {\n          entry.metadata = metadata;\n        }\n\n        await this._queueStore[`${operation}Entry`](entry);\n\n        {\n          logger_js.logger.log(`Request for '${getFriendlyURL_js.getFriendlyURL(request.url)}' has ` + `been added to background sync queue '${this._name}'.`);\n        } // Don't register for a sync if we're in the middle of a sync. Instead,\n        // we wait until the sync is complete and call register if\n        // `this._requestsAddedDuringSync` is true.\n\n\n        if (this._syncInProgress) {\n          this._requestsAddedDuringSync = true;\n        } else {\n          await this.registerSync();\n        }\n      }\n      /**\n       * Removes and returns the first or last (depending on `operation`) entry\n       * from the QueueStore that's not older than the `maxRetentionTime`.\n       *\n       * @param {string} operation ('pop' or 'shift')\n       * @return {Object|undefined}\n       * @private\n       */\n\n\n      async _removeRequest(operation) {\n        const now = Date.now();\n        const entry = await this._queueStore[`${operation}Entry`]();\n\n        if (entry) {\n          // Ignore requests older than maxRetentionTime. Call this function\n          // recursively until an unexpired request is found.\n          const maxRetentionTimeInMs = this._maxRetentionTime * 60 * 1000;\n\n          if (now - entry.timestamp > maxRetentionTimeInMs) {\n            return this._removeRequest(operation);\n          }\n\n          return convertEntry(entry);\n        } else {\n          return undefined;\n        }\n      }\n      /**\n       * Loops through each request in the queue and attempts to re-fetch it.\n       * If any request fails to re-fetch, it's put back in the same position in\n       * the queue (which registers a retry for the next sync event).\n       */\n\n\n      async replayRequests() {\n        let entry;\n\n        while (entry = await this.shiftRequest()) {\n          try {\n            await fetch(entry.request.clone());\n\n            if (\"dev\" !== 'production') {\n              logger_js.logger.log(`Request for '${getFriendlyURL_js.getFriendlyURL(entry.request.url)}'` + `has been replayed in queue '${this._name}'`);\n            }\n          } catch (error) {\n            await this.unshiftRequest(entry);\n\n            {\n              logger_js.logger.log(`Request for '${getFriendlyURL_js.getFriendlyURL(entry.request.url)}'` + `failed to replay, putting it back in queue '${this._name}'`);\n            }\n\n            throw new WorkboxError_js.WorkboxError('queue-replay-failed', {\n              name: this._name\n            });\n          }\n        }\n\n        {\n          logger_js.logger.log(`All requests in queue '${this.name}' have successfully ` + `replayed; the queue is now empty!`);\n        }\n      }\n      /**\n       * Registers a sync event with a tag unique to this instance.\n       */\n\n\n      async registerSync() {\n        if ('sync' in self.registration) {\n          try {\n            await self.registration.sync.register(`${TAG_PREFIX}:${this._name}`);\n          } catch (err) {\n            // This means the registration failed for some reason, possibly due to\n            // the user disabling it.\n            {\n              logger_js.logger.warn(`Unable to register sync event for '${this._name}'.`, err);\n            }\n          }\n        }\n      }\n      /**\n       * In sync-supporting browsers, this adds a listener for the sync event.\n       * In non-sync-supporting browsers, this will retry the queue on service\n       * worker startup.\n       *\n       * @private\n       */\n\n\n      _addSyncListener() {\n        if ('sync' in self.registration) {\n          self.addEventListener('sync', event => {\n            if (event.tag === `${TAG_PREFIX}:${this._name}`) {\n              {\n                logger_js.logger.log(`Background sync for tag '${event.tag}'` + `has been received`);\n              }\n\n              const syncComplete = async () => {\n                this._syncInProgress = true;\n                let syncError;\n\n                try {\n                  await this._onSync({\n                    queue: this\n                  });\n                } catch (error) {\n                  syncError = error; // Rethrow the error. Note: the logic in the finally clause\n                  // will run before this gets rethrown.\n\n                  throw syncError;\n                } finally {\n                  // New items may have been added to the queue during the sync,\n                  // so we need to register for a new sync if that's happened...\n                  // Unless there was an error during the sync, in which\n                  // case the browser will automatically retry later, as long\n                  // as `event.lastChance` is not true.\n                  if (this._requestsAddedDuringSync && !(syncError && !event.lastChance)) {\n                    await this.registerSync();\n                  }\n\n                  this._syncInProgress = false;\n                  this._requestsAddedDuringSync = false;\n                }\n              };\n\n              event.waitUntil(syncComplete());\n            }\n          });\n        } else {\n          {\n            logger_js.logger.log(`Background sync replaying without background sync event`);\n          } // If the browser doesn't support background sync, retry\n          // every time the service worker starts up as a fallback.\n\n\n          this._onSync({\n            queue: this\n          });\n        }\n      }\n      /**\n       * Returns the set of queue names. This is primarily used to reset the list\n       * of queue names in tests.\n       *\n       * @return {Set}\n       *\n       * @private\n       */\n\n\n      static get _queueNames() {\n        return queueNames;\n      }\n\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * A class implementing the `fetchDidFail` lifecycle callback. This makes it\n     * easier to add failed requests to a background sync Queue.\n     *\n     * @memberof module:workbox-background-sync\n     */\n\n    class BackgroundSyncPlugin {\n      /**\n       * @param {string} name See the [Queue]{@link module:workbox-background-sync.Queue}\n       *     documentation for parameter details.\n       * @param {Object} [options] See the\n       *     [Queue]{@link module:workbox-background-sync.Queue} documentation for\n       *     parameter details.\n       */\n      constructor(name, options) {\n        /**\n         * @param {Object} options\n         * @param {Request} options.request\n         * @private\n         */\n        this.fetchDidFail = async ({\n          request\n        }) => {\n          await this._queue.pushRequest({\n            request\n          });\n        };\n\n        this._queue = new Queue(name, options);\n      }\n\n    }\n\n    exports.BackgroundSyncPlugin = BackgroundSyncPlugin;\n    exports.Queue = Queue;\n\n    return exports;\n\n}({}, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private));\n//# sourceMappingURL=workbox-background-sync.dev.js.map"},{"path":"/workbox-v5.1.3/workbox-background-sync.prod.js","content":"this.workbox=this.workbox||{},this.workbox.backgroundSync=function(t,e,s,i,n){\"use strict\";try{self[\"workbox:background-sync:5.1.3\"]&&_()}catch(t){}class a{constructor(t){this.t=t,this.s=new n.DBWrapper(\"workbox-background-sync\",3,{onupgradeneeded:this.i})}async pushEntry(t){delete t.id,t.queueName=this.t,await this.s.add(\"requests\",t)}async unshiftEntry(t){const[e]=await this.s.getAllMatching(\"requests\",{count:1});e?t.id=e.id-1:delete t.id,t.queueName=this.t,await this.s.add(\"requests\",t)}async popEntry(){return this.h({direction:\"prev\"})}async shiftEntry(){return this.h({direction:\"next\"})}async getAll(){return await this.s.getAllMatching(\"requests\",{index:\"queueName\",query:IDBKeyRange.only(this.t)})}async deleteEntry(t){await this.s.delete(\"requests\",t)}async h({direction:t}){const[e]=await this.s.getAllMatching(\"requests\",{direction:t,index:\"queueName\",query:IDBKeyRange.only(this.t),count:1});if(e)return await this.deleteEntry(e.id),e}i(t){const e=t.target.result;t.oldVersion>0&&t.oldVersion<3&&e.objectStoreNames.contains(\"requests\")&&e.deleteObjectStore(\"requests\"),e.createObjectStore(\"requests\",{autoIncrement:!0,keyPath:\"id\"}).createIndex(\"queueName\",\"queueName\",{unique:!1})}}const r=[\"method\",\"referrer\",\"referrerPolicy\",\"mode\",\"credentials\",\"cache\",\"redirect\",\"integrity\",\"keepalive\"];class c{constructor(t){\"navigate\"===t.mode&&(t.mode=\"same-origin\"),this.u=t}static async fromRequest(t){const e={url:t.url,headers:{}};\"GET\"!==t.method&&(e.body=await t.clone().arrayBuffer());for(const[s,i]of t.headers.entries())e.headers[s]=i;for(const s of r)void 0!==t[s]&&(e[s]=t[s]);return new c(e)}toObject(){const t=Object.assign({},this.u);return t.headers=Object.assign({},this.u.headers),t.body&&(t.body=t.body.slice(0)),t}toRequest(){return new Request(this.u.url,this.u)}clone(){return new c(this.toObject())}}const h=new Set,u=t=>{const e={request:new c(t.requestData).toRequest(),timestamp:t.timestamp};return t.metadata&&(e.metadata=t.metadata),e};class o{constructor(t,{onSync:s,maxRetentionTime:i}={}){if(this.o=!1,this.q=!1,h.has(t))throw new e.WorkboxError(\"duplicate-queue-name\",{name:t});h.add(t),this.l=t,this.m=s||this.replayRequests,this.p=i||10080,this.g=new a(this.l),this.R()}get name(){return this.l}async pushRequest(t){await this.k(t,\"push\")}async unshiftRequest(t){await this.k(t,\"unshift\")}async popRequest(){return this.D(\"pop\")}async shiftRequest(){return this.D(\"shift\")}async getAll(){const t=await this.g.getAll(),e=Date.now(),s=[];for(const i of t){const t=60*this.p*1e3;e-i.timestamp>t?await this.g.deleteEntry(i.id):s.push(u(i))}return s}async k({request:t,metadata:e,timestamp:s=Date.now()},i){const n={requestData:(await c.fromRequest(t.clone())).toObject(),timestamp:s};e&&(n.metadata=e),await this.g[`${i}Entry`](n),this.o?this.q=!0:await this.registerSync()}async D(t){const e=Date.now(),s=await this.g[`${t}Entry`]();if(s){const i=60*this.p*1e3;return e-s.timestamp>i?this.D(t):u(s)}}async replayRequests(){let t;for(;t=await this.shiftRequest();)try{await fetch(t.request.clone())}catch(s){throw await this.unshiftRequest(t),new e.WorkboxError(\"queue-replay-failed\",{name:this.l})}}async registerSync(){if(\"sync\"in self.registration)try{await self.registration.sync.register(`workbox-background-sync:${this.l}`)}catch(t){}}R(){\"sync\"in self.registration?self.addEventListener(\"sync\",t=>{if(t.tag===`workbox-background-sync:${this.l}`){const e=async()=>{let e;this.o=!0;try{await this.m({queue:this})}catch(t){throw e=t,e}finally{!this.q||e&&!t.lastChance||await this.registerSync(),this.o=!1,this.q=!1}};t.waitUntil(e())}}):this.m({queue:this})}static get _(){return h}}return t.BackgroundSyncPlugin=class{constructor(t,e){this.fetchDidFail=async({request:t})=>{await this.v.pushRequest({request:t})},this.v=new o(t,e)}},t.Queue=o,t}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private);\n//# sourceMappingURL=workbox-background-sync.prod.js.map"},{"path":"/workbox-v5.1.3/workbox-broadcast-update.dev.js","content":"this.workbox = this.workbox || {};\nthis.workbox.broadcastUpdate = (function (exports, assert_js, timeout_js, resultingClientExists_js, logger_js, WorkboxError_js, dontWaitFor_js) {\n    'use strict';\n\n    try {\n      self['workbox:broadcast-update:5.1.3'] && _();\n    } catch (e) {}\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Given two `Response's`, compares several header values to see if they are\n     * the same or not.\n     *\n     * @param {Response} firstResponse\n     * @param {Response} secondResponse\n     * @param {Array<string>} headersToCheck\n     * @return {boolean}\n     *\n     * @memberof module:workbox-broadcast-update\n     */\n\n    const responsesAreSame = (firstResponse, secondResponse, headersToCheck) => {\n      {\n        if (!(firstResponse instanceof Response && secondResponse instanceof Response)) {\n          throw new WorkboxError_js.WorkboxError('invalid-responses-are-same-args');\n        }\n      }\n\n      const atLeastOneHeaderAvailable = headersToCheck.some(header => {\n        return firstResponse.headers.has(header) && secondResponse.headers.has(header);\n      });\n\n      if (!atLeastOneHeaderAvailable) {\n        {\n          logger_js.logger.warn(`Unable to determine where the response has been updated ` + `because none of the headers that would be checked are present.`);\n          logger_js.logger.debug(`Attempting to compare the following: `, firstResponse, secondResponse, headersToCheck);\n        } // Just return true, indicating the that responses are the same, since we\n        // can't determine otherwise.\n\n\n        return true;\n      }\n\n      return headersToCheck.every(header => {\n        const headerStateComparison = firstResponse.headers.has(header) === secondResponse.headers.has(header);\n        const headerValueComparison = firstResponse.headers.get(header) === secondResponse.headers.get(header);\n        return headerStateComparison && headerValueComparison;\n      });\n    };\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const CACHE_UPDATED_MESSAGE_TYPE = 'CACHE_UPDATED';\n    const CACHE_UPDATED_MESSAGE_META = 'workbox-broadcast-update';\n    const DEFAULT_HEADERS_TO_CHECK = ['content-length', 'etag', 'last-modified'];\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    // TODO(philipwalton): remove once this Safari bug fix has been released.\n    // https://bugs.webkit.org/show_bug.cgi?id=201169\n\n    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n    /**\n     * Generates the default payload used in update messages. By default the\n     * payload includes the `cacheName` and `updatedURL` fields.\n     *\n     * @return Object\n     * @private\n     */\n\n    function defaultPayloadGenerator(data) {\n      return {\n        cacheName: data.cacheName,\n        updatedURL: data.request.url\n      };\n    }\n    /**\n     * Uses the `postMessage()` API to inform any open windows/tabs when a cached\n     * response has been updated.\n     *\n     * For efficiency's sake, the underlying response bodies are not compared;\n     * only specific response headers are checked.\n     *\n     * @memberof module:workbox-broadcast-update\n     */\n\n\n    class BroadcastCacheUpdate {\n      /**\n       * Construct a BroadcastCacheUpdate instance with a specific `channelName` to\n       * broadcast messages on\n       *\n       * @param {Object} options\n       * @param {Array<string>} [options.headersToCheck=['content-length', 'etag', 'last-modified']]\n       *     A list of headers that will be used to determine whether the responses\n       *     differ.\n       * @param {string} [options.generatePayload] A function whose return value\n       *     will be used as the `payload` field in any cache update messages sent\n       *     to the window clients.\n       */\n      constructor({\n        headersToCheck,\n        generatePayload\n      } = {}) {\n        this._headersToCheck = headersToCheck || DEFAULT_HEADERS_TO_CHECK;\n        this._generatePayload = generatePayload || defaultPayloadGenerator;\n      }\n      /**\n       * Compares two [Responses](https://developer.mozilla.org/en-US/docs/Web/API/Response)\n       * and sends a message (via `postMessage()`) to all window clients if the\n       * responses differ (note: neither of the Responses can be\n       * {@link http://stackoverflow.com/questions/39109789|opaque}).\n       *\n       * The message that's posted has the following format (where `payload` can\n       * be customized via the `generatePayload` option the instance is created\n       * with):\n       *\n       * ```\n       * {\n       *   type: 'CACHE_UPDATED',\n       *   meta: 'workbox-broadcast-update',\n       *   payload: {\n       *     cacheName: 'the-cache-name',\n       *     updatedURL: 'https://example.com/'\n       *   }\n       * }\n       * ```\n       *\n       * @param {Object} options\n       * @param {Response} [options.oldResponse] Cached response to compare.\n       * @param {Response} options.newResponse Possibly updated response to compare.\n       * @param {Request} options.request The request.\n       * @param {string} options.cacheName Name of the cache the responses belong\n       *     to. This is included in the broadcast message.\n       * @param {Event} [options.event] event An optional event that triggered\n       *     this possible cache update.\n       * @return {Promise} Resolves once the update is sent.\n       */\n\n\n      async notifyIfUpdated(options) {\n        {\n          assert_js.assert.isType(options.cacheName, 'string', {\n            moduleName: 'workbox-broadcast-update',\n            className: 'BroadcastCacheUpdate',\n            funcName: 'notifyIfUpdated',\n            paramName: 'cacheName'\n          });\n          assert_js.assert.isInstance(options.newResponse, Response, {\n            moduleName: 'workbox-broadcast-update',\n            className: 'BroadcastCacheUpdate',\n            funcName: 'notifyIfUpdated',\n            paramName: 'newResponse'\n          });\n          assert_js.assert.isInstance(options.request, Request, {\n            moduleName: 'workbox-broadcast-update',\n            className: 'BroadcastCacheUpdate',\n            funcName: 'notifyIfUpdated',\n            paramName: 'request'\n          });\n        } // Without two responses there is nothing to compare.\n\n\n        if (!options.oldResponse) {\n          return;\n        }\n\n        if (!responsesAreSame(options.oldResponse, options.newResponse, this._headersToCheck)) {\n          {\n            logger_js.logger.log(`Newer response found (and cached) for:`, options.request.url);\n          }\n\n          const messageData = {\n            type: CACHE_UPDATED_MESSAGE_TYPE,\n            meta: CACHE_UPDATED_MESSAGE_META,\n            payload: this._generatePayload(options)\n          }; // For navigation requests, wait until the new window client exists\n          // before sending the message\n\n          if (options.request.mode === 'navigate') {\n            let resultingClientId;\n\n            if (options.event instanceof FetchEvent) {\n              resultingClientId = options.event.resultingClientId;\n            }\n\n            const resultingWin = await resultingClientExists_js.resultingClientExists(resultingClientId); // Safari does not currently implement postMessage buffering and\n            // there's no good way to feature detect that, so to increase the\n            // chances of the message being delivered in Safari, we add a timeout.\n            // We also do this if `resultingClientExists()` didn't return a client,\n            // which means it timed out, so it's worth waiting a bit longer.\n\n            if (!resultingWin || isSafari) {\n              // 3500 is chosen because (according to CrUX data) 80% of mobile\n              // websites hit the DOMContentLoaded event in less than 3.5 seconds.\n              // And presumably sites implementing service worker are on the\n              // higher end of the performance spectrum.\n              await timeout_js.timeout(3500);\n            }\n          }\n\n          const windows = await self.clients.matchAll({\n            type: 'window'\n          });\n\n          for (const win of windows) {\n            win.postMessage(messageData);\n          }\n        }\n      }\n\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * This plugin will automatically broadcast a message whenever a cached response\n     * is updated.\n     *\n     * @memberof module:workbox-broadcast-update\n     */\n\n    class BroadcastUpdatePlugin {\n      /**\n       * Construct a BroadcastCacheUpdate instance with the passed options and\n       * calls its [`notifyIfUpdated()`]{@link module:workbox-broadcast-update.BroadcastCacheUpdate~notifyIfUpdated}\n       * method whenever the plugin's `cacheDidUpdate` callback is invoked.\n       *\n       * @param {Object} options\n       * @param {Array<string>} [options.headersToCheck=['content-length', 'etag', 'last-modified']]\n       *     A list of headers that will be used to determine whether the responses\n       *     differ.\n       * @param {string} [options.generatePayload] A function whose return value\n       *     will be used as the `payload` field in any cache update messages sent\n       *     to the window clients.\n       */\n      constructor(options) {\n        /**\n         * A \"lifecycle\" callback that will be triggered automatically by the\n         * `workbox-sw` and `workbox-runtime-caching` handlers when an entry is\n         * added to a cache.\n         *\n         * @private\n         * @param {Object} options The input object to this function.\n         * @param {string} options.cacheName Name of the cache being updated.\n         * @param {Response} [options.oldResponse] The previous cached value, if any.\n         * @param {Response} options.newResponse The new value in the cache.\n         * @param {Request} options.request The request that triggered the update.\n         * @param {Request} [options.event] The event that triggered the update.\n         */\n        this.cacheDidUpdate = async options => {\n          dontWaitFor_js.dontWaitFor(this._broadcastUpdate.notifyIfUpdated(options));\n        };\n\n        this._broadcastUpdate = new BroadcastCacheUpdate(options);\n      }\n\n    }\n\n    exports.BroadcastCacheUpdate = BroadcastCacheUpdate;\n    exports.BroadcastUpdatePlugin = BroadcastUpdatePlugin;\n    exports.responsesAreSame = responsesAreSame;\n\n    return exports;\n\n}({}, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private));\n//# sourceMappingURL=workbox-broadcast-update.dev.js.map"},{"path":"/workbox-v5.1.3/workbox-broadcast-update.prod.js","content":"this.workbox=this.workbox||{},this.workbox.broadcastUpdate=function(t,a,o,s){\"use strict\";try{self[\"workbox:broadcast-update:5.1.3\"]&&_()}catch(t){}const e=(t,a,o)=>!o.some(o=>t.headers.has(o)&&a.headers.has(o))||o.every(o=>{const s=t.headers.has(o)===a.headers.has(o),e=t.headers.get(o)===a.headers.get(o);return s&&e}),n=[\"content-length\",\"etag\",\"last-modified\"],i=/^((?!chrome|android).)*safari/i.test(navigator.userAgent);function c(t){return{cacheName:t.cacheName,updatedURL:t.request.url}}class r{constructor({headersToCheck:t,generatePayload:a}={}){this.t=t||n,this.o=a||c}async notifyIfUpdated(t){if(t.oldResponse&&!e(t.oldResponse,t.newResponse,this.t)){const s={type:\"CACHE_UPDATED\",meta:\"workbox-broadcast-update\",payload:this.o(t)};if(\"navigate\"===t.request.mode){let s;t.event instanceof FetchEvent&&(s=t.event.resultingClientId),await o.resultingClientExists(s)&&!i||await a.timeout(3500)}const e=await self.clients.matchAll({type:\"window\"});for(const t of e)t.postMessage(s)}}}return t.BroadcastCacheUpdate=r,t.BroadcastUpdatePlugin=class{constructor(t){this.cacheDidUpdate=async t=>{s.dontWaitFor(this.s.notifyIfUpdated(t))},this.s=new r(t)}},t.responsesAreSame=e,t}({},workbox.core._private,workbox.core._private,workbox.core._private);\n//# sourceMappingURL=workbox-broadcast-update.prod.js.map"},{"path":"/workbox-v5.1.3/workbox-cacheable-response.dev.js","content":"this.workbox = this.workbox || {};\nthis.workbox.cacheableResponse = (function (exports, assert_js, WorkboxError_js, getFriendlyURL_js, logger_js) {\n    'use strict';\n\n    try {\n      self['workbox:cacheable-response:5.1.3'] && _();\n    } catch (e) {}\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * This class allows you to set up rules determining what\n     * status codes and/or headers need to be present in order for a\n     * [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response)\n     * to be considered cacheable.\n     *\n     * @memberof module:workbox-cacheable-response\n     */\n\n    class CacheableResponse {\n      /**\n       * To construct a new CacheableResponse instance you must provide at least\n       * one of the `config` properties.\n       *\n       * If both `statuses` and `headers` are specified, then both conditions must\n       * be met for the `Response` to be considered cacheable.\n       *\n       * @param {Object} config\n       * @param {Array<number>} [config.statuses] One or more status codes that a\n       * `Response` can have and be considered cacheable.\n       * @param {Object<string,string>} [config.headers] A mapping of header names\n       * and expected values that a `Response` can have and be considered cacheable.\n       * If multiple headers are provided, only one needs to be present.\n       */\n      constructor(config = {}) {\n        {\n          if (!(config.statuses || config.headers)) {\n            throw new WorkboxError_js.WorkboxError('statuses-or-headers-required', {\n              moduleName: 'workbox-cacheable-response',\n              className: 'CacheableResponse',\n              funcName: 'constructor'\n            });\n          }\n\n          if (config.statuses) {\n            assert_js.assert.isArray(config.statuses, {\n              moduleName: 'workbox-cacheable-response',\n              className: 'CacheableResponse',\n              funcName: 'constructor',\n              paramName: 'config.statuses'\n            });\n          }\n\n          if (config.headers) {\n            assert_js.assert.isType(config.headers, 'object', {\n              moduleName: 'workbox-cacheable-response',\n              className: 'CacheableResponse',\n              funcName: 'constructor',\n              paramName: 'config.headers'\n            });\n          }\n        }\n\n        this._statuses = config.statuses;\n        this._headers = config.headers;\n      }\n      /**\n       * Checks a response to see whether it's cacheable or not, based on this\n       * object's configuration.\n       *\n       * @param {Response} response The response whose cacheability is being\n       * checked.\n       * @return {boolean} `true` if the `Response` is cacheable, and `false`\n       * otherwise.\n       */\n\n\n      isResponseCacheable(response) {\n        {\n          assert_js.assert.isInstance(response, Response, {\n            moduleName: 'workbox-cacheable-response',\n            className: 'CacheableResponse',\n            funcName: 'isResponseCacheable',\n            paramName: 'response'\n          });\n        }\n\n        let cacheable = true;\n\n        if (this._statuses) {\n          cacheable = this._statuses.includes(response.status);\n        }\n\n        if (this._headers && cacheable) {\n          cacheable = Object.keys(this._headers).some(headerName => {\n            return response.headers.get(headerName) === this._headers[headerName];\n          });\n        }\n\n        {\n          if (!cacheable) {\n            logger_js.logger.groupCollapsed(`The request for ` + `'${getFriendlyURL_js.getFriendlyURL(response.url)}' returned a response that does ` + `not meet the criteria for being cached.`);\n            logger_js.logger.groupCollapsed(`View cacheability criteria here.`);\n            logger_js.logger.log(`Cacheable statuses: ` + JSON.stringify(this._statuses));\n            logger_js.logger.log(`Cacheable headers: ` + JSON.stringify(this._headers, null, 2));\n            logger_js.logger.groupEnd();\n            const logFriendlyHeaders = {};\n            response.headers.forEach((value, key) => {\n              logFriendlyHeaders[key] = value;\n            });\n            logger_js.logger.groupCollapsed(`View response status and headers here.`);\n            logger_js.logger.log(`Response status: ` + response.status);\n            logger_js.logger.log(`Response headers: ` + JSON.stringify(logFriendlyHeaders, null, 2));\n            logger_js.logger.groupEnd();\n            logger_js.logger.groupCollapsed(`View full response details here.`);\n            logger_js.logger.log(response.headers);\n            logger_js.logger.log(response);\n            logger_js.logger.groupEnd();\n            logger_js.logger.groupEnd();\n          }\n        }\n\n        return cacheable;\n      }\n\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * A class implementing the `cacheWillUpdate` lifecycle callback. This makes it\n     * easier to add in cacheability checks to requests made via Workbox's built-in\n     * strategies.\n     *\n     * @memberof module:workbox-cacheable-response\n     */\n\n    class CacheableResponsePlugin {\n      /**\n       * To construct a new CacheableResponsePlugin instance you must provide at\n       * least one of the `config` properties.\n       *\n       * If both `statuses` and `headers` are specified, then both conditions must\n       * be met for the `Response` to be considered cacheable.\n       *\n       * @param {Object} config\n       * @param {Array<number>} [config.statuses] One or more status codes that a\n       * `Response` can have and be considered cacheable.\n       * @param {Object<string,string>} [config.headers] A mapping of header names\n       * and expected values that a `Response` can have and be considered cacheable.\n       * If multiple headers are provided, only one needs to be present.\n       */\n      constructor(config) {\n        /**\n         * @param {Object} options\n         * @param {Response} options.response\n         * @return {Response|null}\n         * @private\n         */\n        this.cacheWillUpdate = async ({\n          response\n        }) => {\n          if (this._cacheableResponse.isResponseCacheable(response)) {\n            return response;\n          }\n\n          return null;\n        };\n\n        this._cacheableResponse = new CacheableResponse(config);\n      }\n\n    }\n\n    exports.CacheableResponse = CacheableResponse;\n    exports.CacheableResponsePlugin = CacheableResponsePlugin;\n\n    return exports;\n\n}({}, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private));\n//# sourceMappingURL=workbox-cacheable-response.dev.js.map"},{"path":"/workbox-v5.1.3/workbox-cacheable-response.prod.js","content":"this.workbox=this.workbox||{},this.workbox.cacheableResponse=function(s){\"use strict\";try{self[\"workbox:cacheable-response:5.1.3\"]&&_()}catch(s){}class t{constructor(s={}){this.s=s.statuses,this.t=s.headers}isResponseCacheable(s){let t=!0;return this.s&&(t=this.s.includes(s.status)),this.t&&t&&(t=Object.keys(this.t).some(t=>s.headers.get(t)===this.t[t])),t}}return s.CacheableResponse=t,s.CacheableResponsePlugin=class{constructor(s){this.cacheWillUpdate=async({response:s})=>this.i.isResponseCacheable(s)?s:null,this.i=new t(s)}},s}({});\n//# sourceMappingURL=workbox-cacheable-response.prod.js.map"},{"path":"/workbox-v5.1.3/workbox-core.dev.js","content":"this.workbox = this.workbox || {};\nthis.workbox.core = (function (exports) {\n    'use strict';\n\n    try {\n      self['workbox:core:5.1.3'] && _();\n    } catch (e) {}\n\n    /*\n      Copyright 2019 Google LLC\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const logger =  (() => {\n      // Don't overwrite this value if it's already set.\n      // See https://github.com/GoogleChrome/workbox/pull/2284#issuecomment-560470923\n      if (!('__WB_DISABLE_DEV_LOGS' in self)) {\n        self.__WB_DISABLE_DEV_LOGS = false;\n      }\n\n      let inGroup = false;\n      const methodToColorMap = {\n        debug: `#7f8c8d`,\n        log: `#2ecc71`,\n        warn: `#f39c12`,\n        error: `#c0392b`,\n        groupCollapsed: `#3498db`,\n        groupEnd: null\n      };\n\n      const print = function (method, args) {\n        if (self.__WB_DISABLE_DEV_LOGS) {\n          return;\n        }\n\n        if (method === 'groupCollapsed') {\n          // Safari doesn't print all console.groupCollapsed() arguments:\n          // https://bugs.webkit.org/show_bug.cgi?id=182754\n          if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n            console[method](...args);\n            return;\n          }\n        }\n\n        const styles = [`background: ${methodToColorMap[method]}`, `border-radius: 0.5em`, `color: white`, `font-weight: bold`, `padding: 2px 0.5em`]; // When in a group, the workbox prefix is not displayed.\n\n        const logPrefix = inGroup ? [] : ['%cworkbox', styles.join(';')];\n        console[method](...logPrefix, ...args);\n\n        if (method === 'groupCollapsed') {\n          inGroup = true;\n        }\n\n        if (method === 'groupEnd') {\n          inGroup = false;\n        }\n      };\n\n      const api = {};\n      const loggerMethods = Object.keys(methodToColorMap);\n\n      for (const key of loggerMethods) {\n        const method = key;\n\n        api[method] = (...args) => {\n          print(method, args);\n        };\n      }\n\n      return api;\n    })();\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const messages = {\n      'invalid-value': ({\n        paramName,\n        validValueDescription,\n        value\n      }) => {\n        if (!paramName || !validValueDescription) {\n          throw new Error(`Unexpected input to 'invalid-value' error.`);\n        }\n\n        return `The '${paramName}' parameter was given a value with an ` + `unexpected value. ${validValueDescription} Received a value of ` + `${JSON.stringify(value)}.`;\n      },\n      'not-an-array': ({\n        moduleName,\n        className,\n        funcName,\n        paramName\n      }) => {\n        if (!moduleName || !className || !funcName || !paramName) {\n          throw new Error(`Unexpected input to 'not-an-array' error.`);\n        }\n\n        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${className}.${funcName}()' must be an array.`;\n      },\n      'incorrect-type': ({\n        expectedType,\n        paramName,\n        moduleName,\n        className,\n        funcName\n      }) => {\n        if (!expectedType || !paramName || !moduleName || !funcName) {\n          throw new Error(`Unexpected input to 'incorrect-type' error.`);\n        }\n\n        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${className ? className + '.' : ''}` + `${funcName}()' must be of type ${expectedType}.`;\n      },\n      'incorrect-class': ({\n        expectedClass,\n        paramName,\n        moduleName,\n        className,\n        funcName,\n        isReturnValueProblem\n      }) => {\n        if (!expectedClass || !moduleName || !funcName) {\n          throw new Error(`Unexpected input to 'incorrect-class' error.`);\n        }\n\n        if (isReturnValueProblem) {\n          return `The return value from ` + `'${moduleName}.${className ? className + '.' : ''}${funcName}()' ` + `must be an instance of class ${expectedClass.name}.`;\n        }\n\n        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${className ? className + '.' : ''}${funcName}()' ` + `must be an instance of class ${expectedClass.name}.`;\n      },\n      'missing-a-method': ({\n        expectedMethod,\n        paramName,\n        moduleName,\n        className,\n        funcName\n      }) => {\n        if (!expectedMethod || !paramName || !moduleName || !className || !funcName) {\n          throw new Error(`Unexpected input to 'missing-a-method' error.`);\n        }\n\n        return `${moduleName}.${className}.${funcName}() expected the ` + `'${paramName}' parameter to expose a '${expectedMethod}' method.`;\n      },\n      'add-to-cache-list-unexpected-type': ({\n        entry\n      }) => {\n        return `An unexpected entry was passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' The entry ` + `'${JSON.stringify(entry)}' isn't supported. You must supply an array of ` + `strings with one or more characters, objects with a url property or ` + `Request objects.`;\n      },\n      'add-to-cache-list-conflicting-entries': ({\n        firstEntry,\n        secondEntry\n      }) => {\n        if (!firstEntry || !secondEntry) {\n          throw new Error(`Unexpected input to ` + `'add-to-cache-list-duplicate-entries' error.`);\n        }\n\n        return `Two of the entries passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` + `${firstEntry._entryId} but different revision details. Workbox is ` + `unable to cache and version the asset correctly. Please remove one ` + `of the entries.`;\n      },\n      'plugin-error-request-will-fetch': ({\n        thrownError\n      }) => {\n        if (!thrownError) {\n          throw new Error(`Unexpected input to ` + `'plugin-error-request-will-fetch', error.`);\n        }\n\n        return `An error was thrown by a plugins 'requestWillFetch()' method. ` + `The thrown error message was: '${thrownError.message}'.`;\n      },\n      'invalid-cache-name': ({\n        cacheNameId,\n        value\n      }) => {\n        if (!cacheNameId) {\n          throw new Error(`Expected a 'cacheNameId' for error 'invalid-cache-name'`);\n        }\n\n        return `You must provide a name containing at least one character for ` + `setCacheDetails({${cacheNameId}: '...'}). Received a value of ` + `'${JSON.stringify(value)}'`;\n      },\n      'unregister-route-but-not-found-with-method': ({\n        method\n      }) => {\n        if (!method) {\n          throw new Error(`Unexpected input to ` + `'unregister-route-but-not-found-with-method' error.`);\n        }\n\n        return `The route you're trying to unregister was not  previously ` + `registered for the method type '${method}'.`;\n      },\n      'unregister-route-route-not-registered': () => {\n        return `The route you're trying to unregister was not previously ` + `registered.`;\n      },\n      'queue-replay-failed': ({\n        name\n      }) => {\n        return `Replaying the background sync queue '${name}' failed.`;\n      },\n      'duplicate-queue-name': ({\n        name\n      }) => {\n        return `The Queue name '${name}' is already being used. ` + `All instances of backgroundSync.Queue must be given unique names.`;\n      },\n      'expired-test-without-max-age': ({\n        methodName,\n        paramName\n      }) => {\n        return `The '${methodName}()' method can only be used when the ` + `'${paramName}' is used in the constructor.`;\n      },\n      'unsupported-route-type': ({\n        moduleName,\n        className,\n        funcName,\n        paramName\n      }) => {\n        return `The supplied '${paramName}' parameter was an unsupported type. ` + `Please check the docs for ${moduleName}.${className}.${funcName} for ` + `valid input types.`;\n      },\n      'not-array-of-class': ({\n        value,\n        expectedClass,\n        moduleName,\n        className,\n        funcName,\n        paramName\n      }) => {\n        return `The supplied '${paramName}' parameter must be an array of ` + `'${expectedClass}' objects. Received '${JSON.stringify(value)},'. ` + `Please check the call to ${moduleName}.${className}.${funcName}() ` + `to fix the issue.`;\n      },\n      'max-entries-or-age-required': ({\n        moduleName,\n        className,\n        funcName\n      }) => {\n        return `You must define either config.maxEntries or config.maxAgeSeconds` + `in ${moduleName}.${className}.${funcName}`;\n      },\n      'statuses-or-headers-required': ({\n        moduleName,\n        className,\n        funcName\n      }) => {\n        return `You must define either config.statuses or config.headers` + `in ${moduleName}.${className}.${funcName}`;\n      },\n      'invalid-string': ({\n        moduleName,\n        funcName,\n        paramName\n      }) => {\n        if (!paramName || !moduleName || !funcName) {\n          throw new Error(`Unexpected input to 'invalid-string' error.`);\n        }\n\n        return `When using strings, the '${paramName}' parameter must start with ` + `'http' (for cross-origin matches) or '/' (for same-origin matches). ` + `Please see the docs for ${moduleName}.${funcName}() for ` + `more info.`;\n      },\n      'channel-name-required': () => {\n        return `You must provide a channelName to construct a ` + `BroadcastCacheUpdate instance.`;\n      },\n      'invalid-responses-are-same-args': () => {\n        return `The arguments passed into responsesAreSame() appear to be ` + `invalid. Please ensure valid Responses are used.`;\n      },\n      'expire-custom-caches-only': () => {\n        return `You must provide a 'cacheName' property when using the ` + `expiration plugin with a runtime caching strategy.`;\n      },\n      'unit-must-be-bytes': ({\n        normalizedRangeHeader\n      }) => {\n        if (!normalizedRangeHeader) {\n          throw new Error(`Unexpected input to 'unit-must-be-bytes' error.`);\n        }\n\n        return `The 'unit' portion of the Range header must be set to 'bytes'. ` + `The Range header provided was \"${normalizedRangeHeader}\"`;\n      },\n      'single-range-only': ({\n        normalizedRangeHeader\n      }) => {\n        if (!normalizedRangeHeader) {\n          throw new Error(`Unexpected input to 'single-range-only' error.`);\n        }\n\n        return `Multiple ranges are not supported. Please use a  single start ` + `value, and optional end value. The Range header provided was ` + `\"${normalizedRangeHeader}\"`;\n      },\n      'invalid-range-values': ({\n        normalizedRangeHeader\n      }) => {\n        if (!normalizedRangeHeader) {\n          throw new Error(`Unexpected input to 'invalid-range-values' error.`);\n        }\n\n        return `The Range header is missing both start and end values. At least ` + `one of those values is needed. The Range header provided was ` + `\"${normalizedRangeHeader}\"`;\n      },\n      'no-range-header': () => {\n        return `No Range header was found in the Request provided.`;\n      },\n      'range-not-satisfiable': ({\n        size,\n        start,\n        end\n      }) => {\n        return `The start (${start}) and end (${end}) values in the Range are ` + `not satisfiable by the cached response, which is ${size} bytes.`;\n      },\n      'attempt-to-cache-non-get-request': ({\n        url,\n        method\n      }) => {\n        return `Unable to cache '${url}' because it is a '${method}' request and ` + `only 'GET' requests can be cached.`;\n      },\n      'cache-put-with-no-response': ({\n        url\n      }) => {\n        return `There was an attempt to cache '${url}' but the response was not ` + `defined.`;\n      },\n      'no-response': ({\n        url,\n        error\n      }) => {\n        let message = `The strategy could not generate a response for '${url}'.`;\n\n        if (error) {\n          message += ` The underlying error is ${error}.`;\n        }\n\n        return message;\n      },\n      'bad-precaching-response': ({\n        url,\n        status\n      }) => {\n        return `The precaching request for '${url}' failed with an HTTP ` + `status of ${status}.`;\n      },\n      'non-precached-url': ({\n        url\n      }) => {\n        return `createHandlerBoundToURL('${url}') was called, but that URL is ` + `not precached. Please pass in a URL that is precached instead.`;\n      },\n      'add-to-cache-list-conflicting-integrities': ({\n        url\n      }) => {\n        return `Two of the entries passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` + `${url} with different integrity values. Please remove one of them.`;\n      },\n      'missing-precache-entry': ({\n        cacheName,\n        url\n      }) => {\n        return `Unable to find a precached response in ${cacheName} for ${url}.`;\n      }\n    };\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n\n    const generatorFunction = (code, details = {}) => {\n      const message = messages[code];\n\n      if (!message) {\n        throw new Error(`Unable to find message for code '${code}'.`);\n      }\n\n      return message(details);\n    };\n\n    const messageGenerator =  generatorFunction;\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Workbox errors should be thrown with this class.\n     * This allows use to ensure the type easily in tests,\n     * helps developers identify errors from workbox\n     * easily and allows use to optimise error\n     * messages correctly.\n     *\n     * @private\n     */\n\n    class WorkboxError extends Error {\n      /**\n       *\n       * @param {string} errorCode The error code that\n       * identifies this particular error.\n       * @param {Object=} details Any relevant arguments\n       * that will help developers identify issues should\n       * be added as a key on the context object.\n       */\n      constructor(errorCode, details) {\n        const message = messageGenerator(errorCode, details);\n        super(message);\n        this.name = errorCode;\n        this.details = details;\n      }\n\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /*\n     * This method throws if the supplied value is not an array.\n     * The destructed values are required to produce a meaningful error for users.\n     * The destructed and restructured object is so it's clear what is\n     * needed.\n     */\n\n    const isArray = (value, details) => {\n      if (!Array.isArray(value)) {\n        throw new WorkboxError('not-an-array', details);\n      }\n    };\n\n    const hasMethod = (object, expectedMethod, details) => {\n      const type = typeof object[expectedMethod];\n\n      if (type !== 'function') {\n        details['expectedMethod'] = expectedMethod;\n        throw new WorkboxError('missing-a-method', details);\n      }\n    };\n\n    const isType = (object, expectedType, details) => {\n      if (typeof object !== expectedType) {\n        details['expectedType'] = expectedType;\n        throw new WorkboxError('incorrect-type', details);\n      }\n    };\n\n    const isInstance = (object, expectedClass, details) => {\n      if (!(object instanceof expectedClass)) {\n        details['expectedClass'] = expectedClass;\n        throw new WorkboxError('incorrect-class', details);\n      }\n    };\n\n    const isOneOf = (value, validValues, details) => {\n      if (!validValues.includes(value)) {\n        details['validValueDescription'] = `Valid values are ${JSON.stringify(validValues)}.`;\n        throw new WorkboxError('invalid-value', details);\n      }\n    };\n\n    const isArrayOfClass = (value, expectedClass, details) => {\n      const error = new WorkboxError('not-array-of-class', details);\n\n      if (!Array.isArray(value)) {\n        throw error;\n      }\n\n      for (const item of value) {\n        if (!(item instanceof expectedClass)) {\n          throw error;\n        }\n      }\n    };\n\n    const finalAssertExports =  {\n      hasMethod,\n      isArray,\n      isInstance,\n      isOneOf,\n      isType,\n      isArrayOfClass\n    };\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n\n    const quotaErrorCallbacks = new Set();\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Adds a function to the set of quotaErrorCallbacks that will be executed if\n     * there's a quota error.\n     *\n     * @param {Function} callback\n     * @memberof module:workbox-core\n     */\n\n    function registerQuotaErrorCallback(callback) {\n      {\n        finalAssertExports.isType(callback, 'function', {\n          moduleName: 'workbox-core',\n          funcName: 'register',\n          paramName: 'callback'\n        });\n      }\n\n      quotaErrorCallbacks.add(callback);\n\n      {\n        logger.log('Registered a callback to respond to quota errors.', callback);\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const _cacheNameDetails = {\n      googleAnalytics: 'googleAnalytics',\n      precache: 'precache-v2',\n      prefix: 'workbox',\n      runtime: 'runtime',\n      suffix: typeof registration !== 'undefined' ? registration.scope : ''\n    };\n\n    const _createCacheName = cacheName => {\n      return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix].filter(value => value && value.length > 0).join('-');\n    };\n\n    const eachCacheNameDetail = fn => {\n      for (const key of Object.keys(_cacheNameDetails)) {\n        fn(key);\n      }\n    };\n\n    const cacheNames = {\n      updateDetails: details => {\n        eachCacheNameDetail(key => {\n          if (typeof details[key] === 'string') {\n            _cacheNameDetails[key] = details[key];\n          }\n        });\n      },\n      getGoogleAnalyticsName: userCacheName => {\n        return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);\n      },\n      getPrecacheName: userCacheName => {\n        return userCacheName || _createCacheName(_cacheNameDetails.precache);\n      },\n      getPrefix: () => {\n        return _cacheNameDetails.prefix;\n      },\n      getRuntimeName: userCacheName => {\n        return userCacheName || _createCacheName(_cacheNameDetails.runtime);\n      },\n      getSuffix: () => {\n        return _cacheNameDetails.suffix;\n      }\n    };\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Runs all of the callback functions, one at a time sequentially, in the order\n     * in which they were registered.\n     *\n     * @memberof module:workbox-core\n     * @private\n     */\n\n    async function executeQuotaErrorCallbacks() {\n      {\n        logger.log(`About to run ${quotaErrorCallbacks.size} ` + `callbacks to clean up caches.`);\n      }\n\n      for (const callback of quotaErrorCallbacks) {\n        await callback();\n\n        {\n          logger.log(callback, 'is complete.');\n        }\n      }\n\n      {\n        logger.log('Finished running callbacks.');\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n\n    const getFriendlyURL = url => {\n      const urlObj = new URL(String(url), location.href); // See https://github.com/GoogleChrome/workbox/issues/2323\n      // We want to include everything, except for the origin if it's same-origin.\n\n      return urlObj.href.replace(new RegExp(`^${location.origin}`), '');\n    };\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const pluginUtils = {\n      filter: (plugins, callbackName) => {\n        return plugins.filter(plugin => callbackName in plugin);\n      }\n    };\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Checks the list of plugins for the cacheKeyWillBeUsed callback, and\n     * executes any of those callbacks found in sequence. The final `Request` object\n     * returned by the last plugin is treated as the cache key for cache reads\n     * and/or writes.\n     *\n     * @param {Object} options\n     * @param {Request} options.request\n     * @param {string} options.mode\n     * @param {Array<Object>} [options.plugins=[]]\n     * @return {Promise<Request>}\n     *\n     * @private\n     * @memberof module:workbox-core\n     */\n\n    const _getEffectiveRequest = async ({\n      request,\n      mode,\n      plugins = []\n    }) => {\n      const cacheKeyWillBeUsedPlugins = pluginUtils.filter(plugins, \"cacheKeyWillBeUsed\"\n      /* CACHE_KEY_WILL_BE_USED */\n      );\n      let effectiveRequest = request;\n\n      for (const plugin of cacheKeyWillBeUsedPlugins) {\n        effectiveRequest = await plugin[\"cacheKeyWillBeUsed\"\n        /* CACHE_KEY_WILL_BE_USED */\n        ].call(plugin, {\n          mode,\n          request: effectiveRequest\n        });\n\n        if (typeof effectiveRequest === 'string') {\n          effectiveRequest = new Request(effectiveRequest);\n        }\n\n        {\n          finalAssertExports.isInstance(effectiveRequest, Request, {\n            moduleName: 'Plugin',\n            funcName: \"cacheKeyWillBeUsed\"\n            /* CACHE_KEY_WILL_BE_USED */\n            ,\n            isReturnValueProblem: true\n          });\n        }\n      }\n\n      return effectiveRequest;\n    };\n    /**\n     * This method will call cacheWillUpdate on the available plugins (or use\n     * status === 200) to determine if the Response is safe and valid to cache.\n     *\n     * @param {Object} options\n     * @param {Request} options.request\n     * @param {Response} options.response\n     * @param {Event} [options.event]\n     * @param {Array<Object>} [options.plugins=[]]\n     * @return {Promise<Response>}\n     *\n     * @private\n     * @memberof module:workbox-core\n     */\n\n\n    const _isResponseSafeToCache = async ({\n      request,\n      response,\n      event,\n      plugins = []\n    }) => {\n      let responseToCache = response;\n      let pluginsUsed = false;\n\n      for (const plugin of plugins) {\n        if (\"cacheWillUpdate\"\n        /* CACHE_WILL_UPDATE */\n        in plugin) {\n          pluginsUsed = true;\n          const pluginMethod = plugin[\"cacheWillUpdate\"\n          /* CACHE_WILL_UPDATE */\n          ];\n          responseToCache = await pluginMethod.call(plugin, {\n            request,\n            response: responseToCache,\n            event\n          });\n\n          {\n            if (responseToCache) {\n              finalAssertExports.isInstance(responseToCache, Response, {\n                moduleName: 'Plugin',\n                funcName: \"cacheWillUpdate\"\n                /* CACHE_WILL_UPDATE */\n                ,\n                isReturnValueProblem: true\n              });\n            }\n          }\n\n          if (!responseToCache) {\n            break;\n          }\n        }\n      }\n\n      if (!pluginsUsed) {\n        {\n          if (responseToCache) {\n            if (responseToCache.status !== 200) {\n              if (responseToCache.status === 0) {\n                logger.warn(`The response for '${request.url}' is an opaque ` + `response. The caching strategy that you're using will not ` + `cache opaque responses by default.`);\n              } else {\n                logger.debug(`The response for '${request.url}' returned ` + `a status code of '${response.status}' and won't be cached as a ` + `result.`);\n              }\n            }\n          }\n        }\n\n        responseToCache = responseToCache && responseToCache.status === 200 ? responseToCache : undefined;\n      }\n\n      return responseToCache ? responseToCache : null;\n    };\n    /**\n     * This is a wrapper around cache.match().\n     *\n     * @param {Object} options\n     * @param {string} options.cacheName Name of the cache to match against.\n     * @param {Request} options.request The Request that will be used to look up\n     *     cache entries.\n     * @param {Event} [options.event] The event that prompted the action.\n     * @param {Object} [options.matchOptions] Options passed to cache.match().\n     * @param {Array<Object>} [options.plugins=[]] Array of plugins.\n     * @return {Response} A cached response if available.\n     *\n     * @private\n     * @memberof module:workbox-core\n     */\n\n\n    const matchWrapper = async ({\n      cacheName,\n      request,\n      event,\n      matchOptions,\n      plugins = []\n    }) => {\n      const cache = await self.caches.open(cacheName);\n      const effectiveRequest = await _getEffectiveRequest({\n        plugins,\n        request,\n        mode: 'read'\n      });\n      let cachedResponse = await cache.match(effectiveRequest, matchOptions);\n\n      {\n        if (cachedResponse) {\n          logger.debug(`Found a cached response in '${cacheName}'.`);\n        } else {\n          logger.debug(`No cached response found in '${cacheName}'.`);\n        }\n      }\n\n      for (const plugin of plugins) {\n        if (\"cachedResponseWillBeUsed\"\n        /* CACHED_RESPONSE_WILL_BE_USED */\n        in plugin) {\n          const pluginMethod = plugin[\"cachedResponseWillBeUsed\"\n          /* CACHED_RESPONSE_WILL_BE_USED */\n          ];\n          cachedResponse = await pluginMethod.call(plugin, {\n            cacheName,\n            event,\n            matchOptions,\n            cachedResponse,\n            request: effectiveRequest\n          });\n\n          {\n            if (cachedResponse) {\n              finalAssertExports.isInstance(cachedResponse, Response, {\n                moduleName: 'Plugin',\n                funcName: \"cachedResponseWillBeUsed\"\n                /* CACHED_RESPONSE_WILL_BE_USED */\n                ,\n                isReturnValueProblem: true\n              });\n            }\n          }\n        }\n      }\n\n      return cachedResponse;\n    };\n    /**\n     * Wrapper around cache.put().\n     *\n     * Will call `cacheDidUpdate` on plugins if the cache was updated, using\n     * `matchOptions` when determining what the old entry is.\n     *\n     * @param {Object} options\n     * @param {string} options.cacheName\n     * @param {Request} options.request\n     * @param {Response} options.response\n     * @param {Event} [options.event]\n     * @param {Array<Object>} [options.plugins=[]]\n     * @param {Object} [options.matchOptions]\n     *\n     * @private\n     * @memberof module:workbox-core\n     */\n\n\n    const putWrapper = async ({\n      cacheName,\n      request,\n      response,\n      event,\n      plugins = [],\n      matchOptions\n    }) => {\n      {\n        if (request.method && request.method !== 'GET') {\n          throw new WorkboxError('attempt-to-cache-non-get-request', {\n            url: getFriendlyURL(request.url),\n            method: request.method\n          });\n        }\n      }\n\n      const effectiveRequest = await _getEffectiveRequest({\n        plugins,\n        request,\n        mode: 'write'\n      });\n\n      if (!response) {\n        {\n          logger.error(`Cannot cache non-existent response for ` + `'${getFriendlyURL(effectiveRequest.url)}'.`);\n        }\n\n        throw new WorkboxError('cache-put-with-no-response', {\n          url: getFriendlyURL(effectiveRequest.url)\n        });\n      }\n\n      const responseToCache = await _isResponseSafeToCache({\n        event,\n        plugins,\n        response,\n        request: effectiveRequest\n      });\n\n      if (!responseToCache) {\n        {\n          logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' will ` + `not be cached.`, responseToCache);\n        }\n\n        return;\n      }\n\n      const cache = await self.caches.open(cacheName);\n      const updatePlugins = pluginUtils.filter(plugins, \"cacheDidUpdate\"\n      /* CACHE_DID_UPDATE */\n      );\n      const oldResponse = updatePlugins.length > 0 ? await matchWrapper({\n        cacheName,\n        matchOptions,\n        request: effectiveRequest\n      }) : null;\n\n      {\n        logger.debug(`Updating the '${cacheName}' cache with a new Response for ` + `${getFriendlyURL(effectiveRequest.url)}.`);\n      }\n\n      try {\n        await cache.put(effectiveRequest, responseToCache);\n      } catch (error) {\n        // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n        if (error.name === 'QuotaExceededError') {\n          await executeQuotaErrorCallbacks();\n        }\n\n        throw error;\n      }\n\n      for (const plugin of updatePlugins) {\n        await plugin[\"cacheDidUpdate\"\n        /* CACHE_DID_UPDATE */\n        ].call(plugin, {\n          cacheName,\n          event,\n          oldResponse,\n          newResponse: responseToCache,\n          request: effectiveRequest\n        });\n      }\n    };\n\n    const cacheWrapper = {\n      put: putWrapper,\n      match: matchWrapper\n    };\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    let supportStatus;\n    /**\n     * A utility function that determines whether the current browser supports\n     * constructing a [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/ReadableStream)\n     * object.\n     *\n     * @return {boolean} `true`, if the current browser can successfully\n     *     construct a `ReadableStream`, `false` otherwise.\n     *\n     * @private\n     */\n\n    function canConstructReadableStream() {\n      if (supportStatus === undefined) {\n        // See https://github.com/GoogleChrome/workbox/issues/1473\n        try {\n          new ReadableStream({\n            start() {}\n\n          });\n          supportStatus = true;\n        } catch (error) {\n          supportStatus = false;\n        }\n      }\n\n      return supportStatus;\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    let supportStatus$1;\n    /**\n     * A utility function that determines whether the current browser supports\n     * constructing a new `Response` from a `response.body` stream.\n     *\n     * @return {boolean} `true`, if the current browser can successfully\n     *     construct a `Response` from a `response.body` stream, `false` otherwise.\n     *\n     * @private\n     */\n\n    function canConstructResponseFromBodyStream() {\n      if (supportStatus$1 === undefined) {\n        const testResponse = new Response('');\n\n        if ('body' in testResponse) {\n          try {\n            new Response(testResponse.body);\n            supportStatus$1 = true;\n          } catch (error) {\n            supportStatus$1 = false;\n          }\n        }\n\n        supportStatus$1 = false;\n      }\n\n      return supportStatus$1;\n    }\n\n    /*\n      Copyright 2019 Google LLC\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * A helper function that prevents a promise from being flagged as unused.\n     *\n     * @private\n     **/\n\n    function dontWaitFor(promise) {\n      // Effective no-op.\n      promise.then(() => {});\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * A class that wraps common IndexedDB functionality in a promise-based API.\n     * It exposes all the underlying power and functionality of IndexedDB, but\n     * wraps the most commonly used features in a way that's much simpler to use.\n     *\n     * @private\n     */\n\n    class DBWrapper {\n      /**\n       * @param {string} name\n       * @param {number} version\n       * @param {Object=} [callback]\n       * @param {!Function} [callbacks.onupgradeneeded]\n       * @param {!Function} [callbacks.onversionchange] Defaults to\n       *     DBWrapper.prototype._onversionchange when not specified.\n       * @private\n       */\n      constructor(name, version, {\n        onupgradeneeded,\n        onversionchange\n      } = {}) {\n        this._db = null;\n        this._name = name;\n        this._version = version;\n        this._onupgradeneeded = onupgradeneeded;\n\n        this._onversionchange = onversionchange || (() => this.close());\n      }\n      /**\n       * Returns the IDBDatabase instance (not normally needed).\n       * @return {IDBDatabase|undefined}\n       *\n       * @private\n       */\n\n\n      get db() {\n        return this._db;\n      }\n      /**\n       * Opens a connected to an IDBDatabase, invokes any onupgradedneeded\n       * callback, and added an onversionchange callback to the database.\n       *\n       * @return {IDBDatabase}\n       * @private\n       */\n\n\n      async open() {\n        if (this._db) return;\n        this._db = await new Promise((resolve, reject) => {\n          // This flag is flipped to true if the timeout callback runs prior\n          // to the request failing or succeeding. Note: we use a timeout instead\n          // of an onblocked handler since there are cases where onblocked will\n          // never never run. A timeout better handles all possible scenarios:\n          // https://github.com/w3c/IndexedDB/issues/223\n          let openRequestTimedOut = false;\n          setTimeout(() => {\n            openRequestTimedOut = true;\n            reject(new Error('The open request was blocked and timed out'));\n          }, this.OPEN_TIMEOUT);\n          const openRequest = indexedDB.open(this._name, this._version);\n\n          openRequest.onerror = () => reject(openRequest.error);\n\n          openRequest.onupgradeneeded = evt => {\n            if (openRequestTimedOut) {\n              openRequest.transaction.abort();\n              openRequest.result.close();\n            } else if (typeof this._onupgradeneeded === 'function') {\n              this._onupgradeneeded(evt);\n            }\n          };\n\n          openRequest.onsuccess = () => {\n            const db = openRequest.result;\n\n            if (openRequestTimedOut) {\n              db.close();\n            } else {\n              db.onversionchange = this._onversionchange.bind(this);\n              resolve(db);\n            }\n          };\n        });\n        return this;\n      }\n      /**\n       * Polyfills the native `getKey()` method. Note, this is overridden at\n       * runtime if the browser supports the native method.\n       *\n       * @param {string} storeName\n       * @param {*} query\n       * @return {Array}\n       * @private\n       */\n\n\n      async getKey(storeName, query) {\n        return (await this.getAllKeys(storeName, query, 1))[0];\n      }\n      /**\n       * Polyfills the native `getAll()` method. Note, this is overridden at\n       * runtime if the browser supports the native method.\n       *\n       * @param {string} storeName\n       * @param {*} query\n       * @param {number} count\n       * @return {Array}\n       * @private\n       */\n\n\n      async getAll(storeName, query, count) {\n        return await this.getAllMatching(storeName, {\n          query,\n          count\n        });\n      }\n      /**\n       * Polyfills the native `getAllKeys()` method. Note, this is overridden at\n       * runtime if the browser supports the native method.\n       *\n       * @param {string} storeName\n       * @param {*} query\n       * @param {number} count\n       * @return {Array}\n       * @private\n       */\n\n\n      async getAllKeys(storeName, query, count) {\n        const entries = await this.getAllMatching(storeName, {\n          query,\n          count,\n          includeKeys: true\n        });\n        return entries.map(entry => entry.key);\n      }\n      /**\n       * Supports flexible lookup in an object store by specifying an index,\n       * query, direction, and count. This method returns an array of objects\n       * with the signature .\n       *\n       * @param {string} storeName\n       * @param {Object} [opts]\n       * @param {string} [opts.index] The index to use (if specified).\n       * @param {*} [opts.query]\n       * @param {IDBCursorDirection} [opts.direction]\n       * @param {number} [opts.count] The max number of results to return.\n       * @param {boolean} [opts.includeKeys] When true, the structure of the\n       *     returned objects is changed from an array of values to an array of\n       *     objects in the form {key, primaryKey, value}.\n       * @return {Array}\n       * @private\n       */\n\n\n      async getAllMatching(storeName, {\n        index,\n        query = null,\n        // IE/Edge errors if query === `undefined`.\n        direction = 'next',\n        count,\n        includeKeys = false\n      } = {}) {\n        return await this.transaction([storeName], 'readonly', (txn, done) => {\n          const store = txn.objectStore(storeName);\n          const target = index ? store.index(index) : store;\n          const results = [];\n          const request = target.openCursor(query, direction);\n\n          request.onsuccess = () => {\n            const cursor = request.result;\n\n            if (cursor) {\n              results.push(includeKeys ? cursor : cursor.value);\n\n              if (count && results.length >= count) {\n                done(results);\n              } else {\n                cursor.continue();\n              }\n            } else {\n              done(results);\n            }\n          };\n        });\n      }\n      /**\n       * Accepts a list of stores, a transaction type, and a callback and\n       * performs a transaction. A promise is returned that resolves to whatever\n       * value the callback chooses. The callback holds all the transaction logic\n       * and is invoked with two arguments:\n       *   1. The IDBTransaction object\n       *   2. A `done` function, that's used to resolve the promise when\n       *      when the transaction is done, if passed a value, the promise is\n       *      resolved to that value.\n       *\n       * @param {Array<string>} storeNames An array of object store names\n       *     involved in the transaction.\n       * @param {string} type Can be `readonly` or `readwrite`.\n       * @param {!Function} callback\n       * @return {*} The result of the transaction ran by the callback.\n       * @private\n       */\n\n\n      async transaction(storeNames, type, callback) {\n        await this.open();\n        return await new Promise((resolve, reject) => {\n          const txn = this._db.transaction(storeNames, type);\n\n          txn.onabort = () => reject(txn.error);\n\n          txn.oncomplete = () => resolve();\n\n          callback(txn, value => resolve(value));\n        });\n      }\n      /**\n       * Delegates async to a native IDBObjectStore method.\n       *\n       * @param {string} method The method name.\n       * @param {string} storeName The object store name.\n       * @param {string} type Can be `readonly` or `readwrite`.\n       * @param {...*} args The list of args to pass to the native method.\n       * @return {*} The result of the transaction.\n       * @private\n       */\n\n\n      async _call(method, storeName, type, ...args) {\n        const callback = (txn, done) => {\n          const objStore = txn.objectStore(storeName); // TODO(philipwalton): Fix this underlying TS2684 error.\n          // @ts-ignore\n\n          const request = objStore[method].apply(objStore, args);\n\n          request.onsuccess = () => done(request.result);\n        };\n\n        return await this.transaction([storeName], type, callback);\n      }\n      /**\n       * Closes the connection opened by `DBWrapper.open()`. Generally this method\n       * doesn't need to be called since:\n       *   1. It's usually better to keep a connection open since opening\n       *      a new connection is somewhat slow.\n       *   2. Connections are automatically closed when the reference is\n       *      garbage collected.\n       * The primary use case for needing to close a connection is when another\n       * reference (typically in another tab) needs to upgrade it and would be\n       * blocked by the current, open connection.\n       *\n       * @private\n       */\n\n\n      close() {\n        if (this._db) {\n          this._db.close();\n\n          this._db = null;\n        }\n      }\n\n    } // Exposed on the prototype to let users modify the default timeout on a\n    // per-instance or global basis.\n\n    DBWrapper.prototype.OPEN_TIMEOUT = 2000; // Wrap native IDBObjectStore methods according to their mode.\n\n    const methodsToWrap = {\n      readonly: ['get', 'count', 'getKey', 'getAll', 'getAllKeys'],\n      readwrite: ['add', 'put', 'clear', 'delete']\n    };\n\n    for (const [mode, methods] of Object.entries(methodsToWrap)) {\n      for (const method of methods) {\n        if (method in IDBObjectStore.prototype) {\n          // Don't use arrow functions here since we're outside of the class.\n          DBWrapper.prototype[method] = async function (storeName, ...args) {\n            return await this._call(method, storeName, mode, ...args);\n          };\n        }\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * The Deferred class composes Promises in a way that allows for them to be\n     * resolved or rejected from outside the constructor. In most cases promises\n     * should be used directly, but Deferreds can be necessary when the logic to\n     * resolve a promise must be separate.\n     *\n     * @private\n     */\n\n    class Deferred {\n      /**\n       * Creates a promise and exposes its resolve and reject functions as methods.\n       */\n      constructor() {\n        this.promise = new Promise((resolve, reject) => {\n          this.resolve = resolve;\n          this.reject = reject;\n        });\n      }\n\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Deletes the database.\n     * Note: this is exported separately from the DBWrapper module because most\n     * usages of IndexedDB in workbox dont need deleting, and this way it can be\n     * reused in tests to delete databases without creating DBWrapper instances.\n     *\n     * @param {string} name The database name.\n     * @private\n     */\n\n    const deleteDatabase = async name => {\n      await new Promise((resolve, reject) => {\n        const request = indexedDB.deleteDatabase(name);\n\n        request.onerror = () => {\n          reject(request.error);\n        };\n\n        request.onblocked = () => {\n          reject(new Error('Delete blocked'));\n        };\n\n        request.onsuccess = () => {\n          resolve();\n        };\n      });\n    };\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Wrapper around the fetch API.\n     *\n     * Will call requestWillFetch on available plugins.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request\n     * @param {Object} [options.fetchOptions]\n     * @param {ExtendableEvent} [options.event]\n     * @param {Array<Object>} [options.plugins=[]]\n     * @return {Promise<Response>}\n     *\n     * @private\n     * @memberof module:workbox-core\n     */\n\n    const wrappedFetch = async ({\n      request,\n      fetchOptions,\n      event,\n      plugins = []\n    }) => {\n      if (typeof request === 'string') {\n        request = new Request(request);\n      } // We *should* be able to call `await event.preloadResponse` even if it's\n      // undefined, but for some reason, doing so leads to errors in our Node unit\n      // tests. To work around that, explicitly check preloadResponse's value first.\n\n\n      if (event instanceof FetchEvent && event.preloadResponse) {\n        const possiblePreloadResponse = await event.preloadResponse;\n\n        if (possiblePreloadResponse) {\n          {\n            logger.log(`Using a preloaded navigation response for ` + `'${getFriendlyURL(request.url)}'`);\n          }\n\n          return possiblePreloadResponse;\n        }\n      }\n\n      {\n        finalAssertExports.isInstance(request, Request, {\n          paramName: 'request',\n          expectedClass: Request,\n          moduleName: 'workbox-core',\n          className: 'fetchWrapper',\n          funcName: 'wrappedFetch'\n        });\n      }\n\n      const failedFetchPlugins = pluginUtils.filter(plugins, \"fetchDidFail\"\n      /* FETCH_DID_FAIL */\n      ); // If there is a fetchDidFail plugin, we need to save a clone of the\n      // original request before it's either modified by a requestWillFetch\n      // plugin or before the original request's body is consumed via fetch().\n\n      const originalRequest = failedFetchPlugins.length > 0 ? request.clone() : null;\n\n      try {\n        for (const plugin of plugins) {\n          if (\"requestWillFetch\"\n          /* REQUEST_WILL_FETCH */\n          in plugin) {\n            const pluginMethod = plugin[\"requestWillFetch\"\n            /* REQUEST_WILL_FETCH */\n            ];\n            const requestClone = request.clone();\n            request = await pluginMethod.call(plugin, {\n              request: requestClone,\n              event\n            });\n\n            if (\"dev\" !== 'production') {\n              if (request) {\n                finalAssertExports.isInstance(request, Request, {\n                  moduleName: 'Plugin',\n                  funcName: \"cachedResponseWillBeUsed\"\n                  /* CACHED_RESPONSE_WILL_BE_USED */\n                  ,\n                  isReturnValueProblem: true\n                });\n              }\n            }\n          }\n        }\n      } catch (err) {\n        throw new WorkboxError('plugin-error-request-will-fetch', {\n          thrownError: err\n        });\n      } // The request can be altered by plugins with `requestWillFetch` making\n      // the original request (Most likely from a `fetch` event) to be different\n      // to the Request we make. Pass both to `fetchDidFail` to aid debugging.\n\n\n      const pluginFilteredRequest = request.clone();\n\n      try {\n        let fetchResponse; // See https://github.com/GoogleChrome/workbox/issues/1796\n\n        if (request.mode === 'navigate') {\n          fetchResponse = await fetch(request);\n        } else {\n          fetchResponse = await fetch(request, fetchOptions);\n        }\n\n        if (\"dev\" !== 'production') {\n          logger.debug(`Network request for ` + `'${getFriendlyURL(request.url)}' returned a response with ` + `status '${fetchResponse.status}'.`);\n        }\n\n        for (const plugin of plugins) {\n          if (\"fetchDidSucceed\"\n          /* FETCH_DID_SUCCEED */\n          in plugin) {\n            fetchResponse = await plugin[\"fetchDidSucceed\"\n            /* FETCH_DID_SUCCEED */\n            ].call(plugin, {\n              event,\n              request: pluginFilteredRequest,\n              response: fetchResponse\n            });\n\n            if (\"dev\" !== 'production') {\n              if (fetchResponse) {\n                finalAssertExports.isInstance(fetchResponse, Response, {\n                  moduleName: 'Plugin',\n                  funcName: \"fetchDidSucceed\"\n                  /* FETCH_DID_SUCCEED */\n                  ,\n                  isReturnValueProblem: true\n                });\n              }\n            }\n          }\n        }\n\n        return fetchResponse;\n      } catch (error) {\n        {\n          logger.error(`Network request for ` + `'${getFriendlyURL(request.url)}' threw an error.`, error);\n        }\n\n        for (const plugin of failedFetchPlugins) {\n          await plugin[\"fetchDidFail\"\n          /* FETCH_DID_FAIL */\n          ].call(plugin, {\n            error,\n            event,\n            originalRequest: originalRequest.clone(),\n            request: pluginFilteredRequest.clone()\n          });\n        }\n\n        throw error;\n      }\n    };\n\n    const fetchWrapper = {\n      fetch: wrappedFetch\n    };\n\n    /*\n      Copyright 2019 Google LLC\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Returns a promise that resolves and the passed number of milliseconds.\n     * This utility is an async/await-friendly version of `setTimeout`.\n     *\n     * @param {number} ms\n     * @return {Promise}\n     * @private\n     */\n\n    function timeout(ms) {\n      return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n    /*\n      Copyright 2019 Google LLC\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const MAX_RETRY_TIME = 2000;\n    /**\n     * Returns a promise that resolves to a window client matching the passed\n     * `resultingClientId`. For browsers that don't support `resultingClientId`\n     * or if waiting for the resulting client to apper takes too long, resolve to\n     * `undefined`.\n     *\n     * @param {string} [resultingClientId]\n     * @return {Promise<Client|undefined>}\n     * @private\n     */\n\n    async function resultingClientExists(resultingClientId) {\n      if (!resultingClientId) {\n        return;\n      }\n\n      let existingWindows = await self.clients.matchAll({\n        type: 'window'\n      });\n      const existingWindowIds = new Set(existingWindows.map(w => w.id));\n      let resultingWindow;\n      const startTime = performance.now(); // Only wait up to `MAX_RETRY_TIME` to find a matching client.\n\n      while (performance.now() - startTime < MAX_RETRY_TIME) {\n        existingWindows = await self.clients.matchAll({\n          type: 'window'\n        });\n        resultingWindow = existingWindows.find(w => {\n          if (resultingClientId) {\n            // If we have a `resultingClientId`, we can match on that.\n            return w.id === resultingClientId;\n          } else {\n            // Otherwise match on finding a window not in `existingWindowIds`.\n            return !existingWindowIds.has(w.id);\n          }\n        });\n\n        if (resultingWindow) {\n          break;\n        } // Sleep for 100ms and retry.\n\n\n        await timeout(100);\n      }\n\n      return resultingWindow;\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n\n    var _private = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        assert: finalAssertExports,\n        cacheNames: cacheNames,\n        cacheWrapper: cacheWrapper,\n        canConstructReadableStream: canConstructReadableStream,\n        canConstructResponseFromBodyStream: canConstructResponseFromBodyStream,\n        dontWaitFor: dontWaitFor,\n        DBWrapper: DBWrapper,\n        Deferred: Deferred,\n        deleteDatabase: deleteDatabase,\n        executeQuotaErrorCallbacks: executeQuotaErrorCallbacks,\n        fetchWrapper: fetchWrapper,\n        getFriendlyURL: getFriendlyURL,\n        logger: logger,\n        resultingClientExists: resultingClientExists,\n        timeout: timeout,\n        WorkboxError: WorkboxError\n    });\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Get the current cache names and prefix/suffix used by Workbox.\n     *\n     * `cacheNames.precache` is used for precached assets,\n     * `cacheNames.googleAnalytics` is used by `workbox-google-analytics` to\n     * store `analytics.js`, and `cacheNames.runtime` is used for everything else.\n     *\n     * `cacheNames.prefix` can be used to retrieve just the current prefix value.\n     * `cacheNames.suffix` can be used to retrieve just the current suffix value.\n     *\n     * @return {Object} An object with `precache`, `runtime`, `prefix`, and\n     *     `googleAnalytics` properties.\n     *\n     * @memberof module:workbox-core\n     */\n\n    const cacheNames$1 = {\n      get googleAnalytics() {\n        return cacheNames.getGoogleAnalyticsName();\n      },\n\n      get precache() {\n        return cacheNames.getPrecacheName();\n      },\n\n      get prefix() {\n        return cacheNames.getPrefix();\n      },\n\n      get runtime() {\n        return cacheNames.getRuntimeName();\n      },\n\n      get suffix() {\n        return cacheNames.getSuffix();\n      }\n\n    };\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Allows developers to copy a response and modify its `headers`, `status`,\n     * or `statusText` values (the values settable via a\n     * [`ResponseInit`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Response/Response#Syntax}\n     * object in the constructor).\n     * To modify these values, pass a function as the second argument. That\n     * function will be invoked with a single object with the response properties\n     * `{headers, status, statusText}`. The return value of this function will\n     * be used as the `ResponseInit` for the new `Response`. To change the values\n     * either modify the passed parameter(s) and return it, or return a totally\n     * new object.\n     *\n     * @param {Response} response\n     * @param {Function} modifier\n     * @memberof module:workbox-core\n     */\n\n    async function copyResponse(response, modifier) {\n      const clonedResponse = response.clone(); // Create a fresh `ResponseInit` object by cloning the headers.\n\n      const responseInit = {\n        headers: new Headers(clonedResponse.headers),\n        status: clonedResponse.status,\n        statusText: clonedResponse.statusText\n      }; // Apply any user modifications.\n\n      const modifiedResponseInit = modifier ? modifier(responseInit) : responseInit; // Create the new response from the body stream and `ResponseInit`\n      // modifications. Note: not all browsers support the Response.body stream,\n      // so fall back to reading the entire body into memory as a blob.\n\n      const body = canConstructResponseFromBodyStream() ? clonedResponse.body : await clonedResponse.blob();\n      return new Response(body, modifiedResponseInit);\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Claim any currently available clients once the service worker\n     * becomes active. This is normally used in conjunction with `skipWaiting()`.\n     *\n     * @memberof module:workbox-core\n     */\n\n    function clientsClaim() {\n      self.addEventListener('activate', () => self.clients.claim());\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Modifies the default cache names used by the Workbox packages.\n     * Cache names are generated as `<prefix>-<Cache Name>-<suffix>`.\n     *\n     * @param {Object} details\n     * @param {Object} [details.prefix] The string to add to the beginning of\n     *     the precache and runtime cache names.\n     * @param {Object} [details.suffix] The string to add to the end of\n     *     the precache and runtime cache names.\n     * @param {Object} [details.precache] The cache name to use for precache\n     *     caching.\n     * @param {Object} [details.runtime] The cache name to use for runtime caching.\n     * @param {Object} [details.googleAnalytics] The cache name to use for\n     *     `workbox-google-analytics` caching.\n     *\n     * @memberof module:workbox-core\n     */\n\n    function setCacheNameDetails(details) {\n      {\n        Object.keys(details).forEach(key => {\n          finalAssertExports.isType(details[key], 'string', {\n            moduleName: 'workbox-core',\n            funcName: 'setCacheNameDetails',\n            paramName: `details.${key}`\n          });\n        });\n\n        if ('precache' in details && details['precache'].length === 0) {\n          throw new WorkboxError('invalid-cache-name', {\n            cacheNameId: 'precache',\n            value: details['precache']\n          });\n        }\n\n        if ('runtime' in details && details['runtime'].length === 0) {\n          throw new WorkboxError('invalid-cache-name', {\n            cacheNameId: 'runtime',\n            value: details['runtime']\n          });\n        }\n\n        if ('googleAnalytics' in details && details['googleAnalytics'].length === 0) {\n          throw new WorkboxError('invalid-cache-name', {\n            cacheNameId: 'googleAnalytics',\n            value: details['googleAnalytics']\n          });\n        }\n      }\n\n      cacheNames.updateDetails(details);\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Force a service worker to activate immediately, instead of\n     * [waiting](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#waiting)\n     * for existing clients to close.\n     *\n     * @memberof module:workbox-core\n     */\n\n    function skipWaiting() {\n      // We need to explicitly call `self.skipWaiting()` here because we're\n      // shadowing `skipWaiting` with this local function.\n      self.addEventListener('install', () => self.skipWaiting());\n    }\n\n    exports._private = _private;\n    exports.cacheNames = cacheNames$1;\n    exports.clientsClaim = clientsClaim;\n    exports.copyResponse = copyResponse;\n    exports.registerQuotaErrorCallback = registerQuotaErrorCallback;\n    exports.setCacheNameDetails = setCacheNameDetails;\n    exports.skipWaiting = skipWaiting;\n\n    return exports;\n\n}({}));\n//# sourceMappingURL=workbox-core.dev.js.map"},{"path":"/workbox-v5.1.3/workbox-core.prod.js","content":"this.workbox=this.workbox||{},this.workbox.core=function(e){\"use strict\";try{self[\"workbox:core:5.1.3\"]&&_()}catch(e){}const t=(e,...t)=>{let n=e;return t.length>0&&(n+=` :: ${JSON.stringify(t)}`),n};class n extends Error{constructor(e,n){super(t(e,n)),this.name=e,this.details=n}}const s=new Set;const r={googleAnalytics:\"googleAnalytics\",precache:\"precache-v2\",prefix:\"workbox\",runtime:\"runtime\",suffix:\"undefined\"!=typeof registration?registration.scope:\"\"},i=e=>[r.prefix,e,r.suffix].filter(e=>e&&e.length>0).join(\"-\"),o={updateDetails:e=>{(e=>{for(const t of Object.keys(r))e(t)})(t=>{\"string\"==typeof e[t]&&(r[t]=e[t])})},getGoogleAnalyticsName:e=>e||i(r.googleAnalytics),getPrecacheName:e=>e||i(r.precache),getPrefix:()=>r.prefix,getRuntimeName:e=>e||i(r.runtime),getSuffix:()=>r.suffix};async function a(){for(const e of s)await e()}const c=e=>new URL(String(e),location.href).href.replace(new RegExp(`^${location.origin}`),\"\"),u=(e,t)=>e.filter(e=>t in e),l=async({request:e,mode:t,plugins:n=[]})=>{const s=u(n,\"cacheKeyWillBeUsed\");let r=e;for(const e of s)r=await e.cacheKeyWillBeUsed.call(e,{mode:t,request:r}),\"string\"==typeof r&&(r=new Request(r));return r},f=async({cacheName:e,request:t,event:n,matchOptions:s,plugins:r=[]})=>{const i=await self.caches.open(e),o=await l({plugins:r,request:t,mode:\"read\"});let a=await i.match(o,s);for(const t of r)if(\"cachedResponseWillBeUsed\"in t){const r=t.cachedResponseWillBeUsed;a=await r.call(t,{cacheName:e,event:n,matchOptions:s,cachedResponse:a,request:o})}return a},h={put:async({cacheName:e,request:t,response:s,event:r,plugins:i=[],matchOptions:o})=>{const h=await l({plugins:i,request:t,mode:\"write\"});if(!s)throw new n(\"cache-put-with-no-response\",{url:c(h.url)});const w=await(async({request:e,response:t,event:n,plugins:s=[]})=>{let r=t,i=!1;for(const t of s)if(\"cacheWillUpdate\"in t){i=!0;const s=t.cacheWillUpdate;if(r=await s.call(t,{request:e,response:r,event:n}),!r)break}return i||(r=r&&200===r.status?r:void 0),r||null})({event:r,plugins:i,response:s,request:h});if(!w)return;const p=await self.caches.open(e),d=u(i,\"cacheDidUpdate\"),g=d.length>0?await f({cacheName:e,matchOptions:o,request:h}):null;try{await p.put(h,w)}catch(e){throw\"QuotaExceededError\"===e.name&&await a(),e}for(const t of d)await t.cacheDidUpdate.call(t,{cacheName:e,event:r,oldResponse:g,newResponse:w,request:h})},match:f};let w,p;function d(){if(void 0===p){const e=new Response(\"\");if(\"body\"in e)try{new Response(e.body),p=!0}catch(e){p=!1}p=!1}return p}class g{constructor(e,t,{onupgradeneeded:n,onversionchange:s}={}){this.t=null,this.s=e,this.i=t,this.o=n,this.u=s||(()=>this.close())}get db(){return this.t}async open(){if(!this.t)return this.t=await new Promise((e,t)=>{let n=!1;setTimeout(()=>{n=!0,t(new Error(\"The open request was blocked and timed out\"))},this.OPEN_TIMEOUT);const s=indexedDB.open(this.s,this.i);s.onerror=()=>t(s.error),s.onupgradeneeded=e=>{n?(s.transaction.abort(),s.result.close()):\"function\"==typeof this.o&&this.o(e)},s.onsuccess=()=>{const t=s.result;n?t.close():(t.onversionchange=this.u.bind(this),e(t))}}),this}async getKey(e,t){return(await this.getAllKeys(e,t,1))[0]}async getAll(e,t,n){return await this.getAllMatching(e,{query:t,count:n})}async getAllKeys(e,t,n){return(await this.getAllMatching(e,{query:t,count:n,includeKeys:!0})).map(e=>e.key)}async getAllMatching(e,{index:t,query:n=null,direction:s=\"next\",count:r,includeKeys:i=!1}={}){return await this.transaction([e],\"readonly\",(o,a)=>{const c=o.objectStore(e),u=t?c.index(t):c,l=[],f=u.openCursor(n,s);f.onsuccess=()=>{const e=f.result;e?(l.push(i?e:e.value),r&&l.length>=r?a(l):e.continue()):a(l)}})}async transaction(e,t,n){return await this.open(),await new Promise((s,r)=>{const i=this.t.transaction(e,t);i.onabort=()=>r(i.error),i.oncomplete=()=>s(),n(i,e=>s(e))})}async l(e,t,n,...s){return await this.transaction([t],n,(n,r)=>{const i=n.objectStore(t),o=i[e].apply(i,s);o.onsuccess=()=>r(o.result)})}close(){this.t&&(this.t.close(),this.t=null)}}g.prototype.OPEN_TIMEOUT=2e3;const y={readonly:[\"get\",\"count\",\"getKey\",\"getAll\",\"getAllKeys\"],readwrite:[\"add\",\"put\",\"clear\",\"delete\"]};for(const[e,t]of Object.entries(y))for(const n of t)n in IDBObjectStore.prototype&&(g.prototype[n]=async function(t,...s){return await this.l(n,t,e,...s)});const m={fetch:async({request:e,fetchOptions:t,event:s,plugins:r=[]})=>{if(\"string\"==typeof e&&(e=new Request(e)),s instanceof FetchEvent&&s.preloadResponse){const e=await s.preloadResponse;if(e)return e}const i=u(r,\"fetchDidFail\"),o=i.length>0?e.clone():null;try{for(const t of r)if(\"requestWillFetch\"in t){const n=t.requestWillFetch,r=e.clone();e=await n.call(t,{request:r,event:s})}}catch(e){throw new n(\"plugin-error-request-will-fetch\",{thrownError:e})}const a=e.clone();try{let n;n=\"navigate\"===e.mode?await fetch(e):await fetch(e,t);for(const e of r)\"fetchDidSucceed\"in e&&(n=await e.fetchDidSucceed.call(e,{event:s,request:a,response:n}));return n}catch(e){for(const t of i)await t.fetchDidFail.call(t,{error:e,event:s,originalRequest:o.clone(),request:a.clone()});throw e}}};function q(e){return new Promise(t=>setTimeout(t,e))}var v=Object.freeze({__proto__:null,assert:null,cacheNames:o,cacheWrapper:h,canConstructReadableStream:function(){if(void 0===w)try{new ReadableStream({start(){}}),w=!0}catch(e){w=!1}return w},canConstructResponseFromBodyStream:d,dontWaitFor:function(e){e.then(()=>{})},DBWrapper:g,Deferred:class{constructor(){this.promise=new Promise((e,t)=>{this.resolve=e,this.reject=t})}},deleteDatabase:async e=>{await new Promise((t,n)=>{const s=indexedDB.deleteDatabase(e);s.onerror=()=>{n(s.error)},s.onblocked=()=>{n(new Error(\"Delete blocked\"))},s.onsuccess=()=>{t()}})},executeQuotaErrorCallbacks:a,fetchWrapper:m,getFriendlyURL:c,logger:null,resultingClientExists:async function(e){if(!e)return;let t=await self.clients.matchAll({type:\"window\"});const n=new Set(t.map(e=>e.id));let s;const r=performance.now();for(;performance.now()-r<2e3&&(t=await self.clients.matchAll({type:\"window\"}),s=t.find(t=>e?t.id===e:!n.has(t.id)),!s);)await q(100);return s},timeout:q,WorkboxError:n});const x={get googleAnalytics(){return o.getGoogleAnalyticsName()},get precache(){return o.getPrecacheName()},get prefix(){return o.getPrefix()},get runtime(){return o.getRuntimeName()},get suffix(){return o.getSuffix()}};return e._private=v,e.cacheNames=x,e.clientsClaim=function(){self.addEventListener(\"activate\",()=>self.clients.claim())},e.copyResponse=async function(e,t){const n=e.clone(),s={headers:new Headers(n.headers),status:n.status,statusText:n.statusText},r=t?t(s):s,i=d()?n.body:await n.blob();return new Response(i,r)},e.registerQuotaErrorCallback=function(e){s.add(e)},e.setCacheNameDetails=function(e){o.updateDetails(e)},e.skipWaiting=function(){self.addEventListener(\"install\",()=>self.skipWaiting())},e}({});\n//# sourceMappingURL=workbox-core.prod.js.map"},{"path":"/workbox-v5.1.3/workbox-expiration.dev.js","content":"this.workbox = this.workbox || {};\nthis.workbox.expiration = (function (exports, assert_js, dontWaitFor_js, logger_js, WorkboxError_js, DBWrapper_js, deleteDatabase_js, cacheNames_js, getFriendlyURL_js, registerQuotaErrorCallback_js) {\n    'use strict';\n\n    try {\n      self['workbox:expiration:5.1.3'] && _();\n    } catch (e) {}\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const DB_NAME = 'workbox-expiration';\n    const OBJECT_STORE_NAME = 'cache-entries';\n\n    const normalizeURL = unNormalizedUrl => {\n      const url = new URL(unNormalizedUrl, location.href);\n      url.hash = '';\n      return url.href;\n    };\n    /**\n     * Returns the timestamp model.\n     *\n     * @private\n     */\n\n\n    class CacheTimestampsModel {\n      /**\n       *\n       * @param {string} cacheName\n       *\n       * @private\n       */\n      constructor(cacheName) {\n        this._cacheName = cacheName;\n        this._db = new DBWrapper_js.DBWrapper(DB_NAME, 1, {\n          onupgradeneeded: event => this._handleUpgrade(event)\n        });\n      }\n      /**\n       * Should perform an upgrade of indexedDB.\n       *\n       * @param {Event} event\n       *\n       * @private\n       */\n\n\n      _handleUpgrade(event) {\n        const db = event.target.result; // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we\n        // have to use the `id` keyPath here and create our own values (a\n        // concatenation of `url + cacheName`) instead of simply using\n        // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.\n\n        const objStore = db.createObjectStore(OBJECT_STORE_NAME, {\n          keyPath: 'id'\n        }); // TODO(philipwalton): once we don't have to support EdgeHTML, we can\n        // create a single index with the keyPath `['cacheName', 'timestamp']`\n        // instead of doing both these indexes.\n\n        objStore.createIndex('cacheName', 'cacheName', {\n          unique: false\n        });\n        objStore.createIndex('timestamp', 'timestamp', {\n          unique: false\n        }); // Previous versions of `workbox-expiration` used `this._cacheName`\n        // as the IDBDatabase name.\n\n        deleteDatabase_js.deleteDatabase(this._cacheName);\n      }\n      /**\n       * @param {string} url\n       * @param {number} timestamp\n       *\n       * @private\n       */\n\n\n      async setTimestamp(url, timestamp) {\n        url = normalizeURL(url);\n        const entry = {\n          url,\n          timestamp,\n          cacheName: this._cacheName,\n          // Creating an ID from the URL and cache name won't be necessary once\n          // Edge switches to Chromium and all browsers we support work with\n          // array keyPaths.\n          id: this._getId(url)\n        };\n        await this._db.put(OBJECT_STORE_NAME, entry);\n      }\n      /**\n       * Returns the timestamp stored for a given URL.\n       *\n       * @param {string} url\n       * @return {number}\n       *\n       * @private\n       */\n\n\n      async getTimestamp(url) {\n        const entry = await this._db.get(OBJECT_STORE_NAME, this._getId(url));\n        return entry.timestamp;\n      }\n      /**\n       * Iterates through all the entries in the object store (from newest to\n       * oldest) and removes entries once either `maxCount` is reached or the\n       * entry's timestamp is less than `minTimestamp`.\n       *\n       * @param {number} minTimestamp\n       * @param {number} maxCount\n       * @return {Array<string>}\n       *\n       * @private\n       */\n\n\n      async expireEntries(minTimestamp, maxCount) {\n        const entriesToDelete = await this._db.transaction(OBJECT_STORE_NAME, 'readwrite', (txn, done) => {\n          const store = txn.objectStore(OBJECT_STORE_NAME);\n          const request = store.index('timestamp').openCursor(null, 'prev');\n          const entriesToDelete = [];\n          let entriesNotDeletedCount = 0;\n\n          request.onsuccess = () => {\n            const cursor = request.result;\n\n            if (cursor) {\n              const result = cursor.value; // TODO(philipwalton): once we can use a multi-key index, we\n              // won't have to check `cacheName` here.\n\n              if (result.cacheName === this._cacheName) {\n                // Delete an entry if it's older than the max age or\n                // if we already have the max number allowed.\n                if (minTimestamp && result.timestamp < minTimestamp || maxCount && entriesNotDeletedCount >= maxCount) {\n                  // TODO(philipwalton): we should be able to delete the\n                  // entry right here, but doing so causes an iteration\n                  // bug in Safari stable (fixed in TP). Instead we can\n                  // store the keys of the entries to delete, and then\n                  // delete the separate transactions.\n                  // https://github.com/GoogleChrome/workbox/issues/1978\n                  // cursor.delete();\n                  // We only need to return the URL, not the whole entry.\n                  entriesToDelete.push(cursor.value);\n                } else {\n                  entriesNotDeletedCount++;\n                }\n              }\n\n              cursor.continue();\n            } else {\n              done(entriesToDelete);\n            }\n          };\n        }); // TODO(philipwalton): once the Safari bug in the following issue is fixed,\n        // we should be able to remove this loop and do the entry deletion in the\n        // cursor loop above:\n        // https://github.com/GoogleChrome/workbox/issues/1978\n\n        const urlsDeleted = [];\n\n        for (const entry of entriesToDelete) {\n          await this._db.delete(OBJECT_STORE_NAME, entry.id);\n          urlsDeleted.push(entry.url);\n        }\n\n        return urlsDeleted;\n      }\n      /**\n       * Takes a URL and returns an ID that will be unique in the object store.\n       *\n       * @param {string} url\n       * @return {string}\n       *\n       * @private\n       */\n\n\n      _getId(url) {\n        // Creating an ID from the URL and cache name won't be necessary once\n        // Edge switches to Chromium and all browsers we support work with\n        // array keyPaths.\n        return this._cacheName + '|' + normalizeURL(url);\n      }\n\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * The `CacheExpiration` class allows you define an expiration and / or\n     * limit on the number of responses stored in a\n     * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n     *\n     * @memberof module:workbox-expiration\n     */\n\n    class CacheExpiration {\n      /**\n       * To construct a new CacheExpiration instance you must provide at least\n       * one of the `config` properties.\n       *\n       * @param {string} cacheName Name of the cache to apply restrictions to.\n       * @param {Object} config\n       * @param {number} [config.maxEntries] The maximum number of entries to cache.\n       * Entries used the least will be removed as the maximum is reached.\n       * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n       * it's treated as stale and removed.\n       */\n      constructor(cacheName, config = {}) {\n        this._isRunning = false;\n        this._rerunRequested = false;\n\n        {\n          assert_js.assert.isType(cacheName, 'string', {\n            moduleName: 'workbox-expiration',\n            className: 'CacheExpiration',\n            funcName: 'constructor',\n            paramName: 'cacheName'\n          });\n\n          if (!(config.maxEntries || config.maxAgeSeconds)) {\n            throw new WorkboxError_js.WorkboxError('max-entries-or-age-required', {\n              moduleName: 'workbox-expiration',\n              className: 'CacheExpiration',\n              funcName: 'constructor'\n            });\n          }\n\n          if (config.maxEntries) {\n            assert_js.assert.isType(config.maxEntries, 'number', {\n              moduleName: 'workbox-expiration',\n              className: 'CacheExpiration',\n              funcName: 'constructor',\n              paramName: 'config.maxEntries'\n            }); // TODO: Assert is positive\n          }\n\n          if (config.maxAgeSeconds) {\n            assert_js.assert.isType(config.maxAgeSeconds, 'number', {\n              moduleName: 'workbox-expiration',\n              className: 'CacheExpiration',\n              funcName: 'constructor',\n              paramName: 'config.maxAgeSeconds'\n            }); // TODO: Assert is positive\n          }\n        }\n\n        this._maxEntries = config.maxEntries;\n        this._maxAgeSeconds = config.maxAgeSeconds;\n        this._cacheName = cacheName;\n        this._timestampModel = new CacheTimestampsModel(cacheName);\n      }\n      /**\n       * Expires entries for the given cache and given criteria.\n       */\n\n\n      async expireEntries() {\n        if (this._isRunning) {\n          this._rerunRequested = true;\n          return;\n        }\n\n        this._isRunning = true;\n        const minTimestamp = this._maxAgeSeconds ? Date.now() - this._maxAgeSeconds * 1000 : 0;\n        const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries); // Delete URLs from the cache\n\n        const cache = await self.caches.open(this._cacheName);\n\n        for (const url of urlsExpired) {\n          await cache.delete(url);\n        }\n\n        {\n          if (urlsExpired.length > 0) {\n            logger_js.logger.groupCollapsed(`Expired ${urlsExpired.length} ` + `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` + `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` + `'${this._cacheName}' cache.`);\n            logger_js.logger.log(`Expired the following ${urlsExpired.length === 1 ? 'URL' : 'URLs'}:`);\n            urlsExpired.forEach(url => logger_js.logger.log(`    ${url}`));\n            logger_js.logger.groupEnd();\n          } else {\n            logger_js.logger.debug(`Cache expiration ran and found no entries to remove.`);\n          }\n        }\n\n        this._isRunning = false;\n\n        if (this._rerunRequested) {\n          this._rerunRequested = false;\n          dontWaitFor_js.dontWaitFor(this.expireEntries());\n        }\n      }\n      /**\n       * Update the timestamp for the given URL. This ensures the when\n       * removing entries based on maximum entries, most recently used\n       * is accurate or when expiring, the timestamp is up-to-date.\n       *\n       * @param {string} url\n       */\n\n\n      async updateTimestamp(url) {\n        {\n          assert_js.assert.isType(url, 'string', {\n            moduleName: 'workbox-expiration',\n            className: 'CacheExpiration',\n            funcName: 'updateTimestamp',\n            paramName: 'url'\n          });\n        }\n\n        await this._timestampModel.setTimestamp(url, Date.now());\n      }\n      /**\n       * Can be used to check if a URL has expired or not before it's used.\n       *\n       * This requires a look up from IndexedDB, so can be slow.\n       *\n       * Note: This method will not remove the cached entry, call\n       * `expireEntries()` to remove indexedDB and Cache entries.\n       *\n       * @param {string} url\n       * @return {boolean}\n       */\n\n\n      async isURLExpired(url) {\n        if (!this._maxAgeSeconds) {\n          {\n            throw new WorkboxError_js.WorkboxError(`expired-test-without-max-age`, {\n              methodName: 'isURLExpired',\n              paramName: 'maxAgeSeconds'\n            });\n          }\n        } else {\n          const timestamp = await this._timestampModel.getTimestamp(url);\n          const expireOlderThan = Date.now() - this._maxAgeSeconds * 1000;\n          return timestamp < expireOlderThan;\n        }\n      }\n      /**\n       * Removes the IndexedDB object store used to keep track of cache expiration\n       * metadata.\n       */\n\n\n      async delete() {\n        // Make sure we don't attempt another rerun if we're called in the middle of\n        // a cache expiration.\n        this._rerunRequested = false;\n        await this._timestampModel.expireEntries(Infinity); // Expires all.\n      }\n\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * This plugin can be used in the Workbox APIs to regularly enforce a\n     * limit on the age and / or the number of cached requests.\n     *\n     * Whenever a cached request is used or updated, this plugin will look\n     * at the used Cache and remove any old or extra requests.\n     *\n     * When using `maxAgeSeconds`, requests may be used *once* after expiring\n     * because the expiration clean up will not have occurred until *after* the\n     * cached request has been used. If the request has a \"Date\" header, then\n     * a light weight expiration check is performed and the request will not be\n     * used immediately.\n     *\n     * When using `maxEntries`, the entry least-recently requested will be removed\n     * from the cache first.\n     *\n     * @memberof module:workbox-expiration\n     */\n\n    class ExpirationPlugin {\n      /**\n       * @param {Object} config\n       * @param {number} [config.maxEntries] The maximum number of entries to cache.\n       * Entries used the least will be removed as the maximum is reached.\n       * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n       * it's treated as stale and removed.\n       * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\n       * automatic deletion if the available storage quota has been exceeded.\n       */\n      constructor(config = {}) {\n        /**\n         * A \"lifecycle\" callback that will be triggered automatically by the\n         * `workbox-strategies` handlers when a `Response` is about to be returned\n         * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\n         * the handler. It allows the `Response` to be inspected for freshness and\n         * prevents it from being used if the `Response`'s `Date` header value is\n         * older than the configured `maxAgeSeconds`.\n         *\n         * @param {Object} options\n         * @param {string} options.cacheName Name of the cache the response is in.\n         * @param {Response} options.cachedResponse The `Response` object that's been\n         *     read from a cache and whose freshness should be checked.\n         * @return {Response} Either the `cachedResponse`, if it's\n         *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\n         *\n         * @private\n         */\n        this.cachedResponseWillBeUsed = async ({\n          event,\n          request,\n          cacheName,\n          cachedResponse\n        }) => {\n          if (!cachedResponse) {\n            return null;\n          }\n\n          const isFresh = this._isResponseDateFresh(cachedResponse); // Expire entries to ensure that even if the expiration date has\n          // expired, it'll only be used once.\n\n\n          const cacheExpiration = this._getCacheExpiration(cacheName);\n\n          dontWaitFor_js.dontWaitFor(cacheExpiration.expireEntries()); // Update the metadata for the request URL to the current timestamp,\n          // but don't `await` it as we don't want to block the response.\n\n          const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\n\n          if (event) {\n            try {\n              event.waitUntil(updateTimestampDone);\n            } catch (error) {\n              {\n                // The event may not be a fetch event; only log the URL if it is.\n                if ('request' in event) {\n                  logger_js.logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache entry for ` + `'${getFriendlyURL_js.getFriendlyURL(event.request.url)}'.`);\n                }\n              }\n            }\n          }\n\n          return isFresh ? cachedResponse : null;\n        };\n        /**\n         * A \"lifecycle\" callback that will be triggered automatically by the\n         * `workbox-strategies` handlers when an entry is added to a cache.\n         *\n         * @param {Object} options\n         * @param {string} options.cacheName Name of the cache that was updated.\n         * @param {string} options.request The Request for the cached entry.\n         *\n         * @private\n         */\n\n\n        this.cacheDidUpdate = async ({\n          cacheName,\n          request\n        }) => {\n          {\n            assert_js.assert.isType(cacheName, 'string', {\n              moduleName: 'workbox-expiration',\n              className: 'Plugin',\n              funcName: 'cacheDidUpdate',\n              paramName: 'cacheName'\n            });\n            assert_js.assert.isInstance(request, Request, {\n              moduleName: 'workbox-expiration',\n              className: 'Plugin',\n              funcName: 'cacheDidUpdate',\n              paramName: 'request'\n            });\n          }\n\n          const cacheExpiration = this._getCacheExpiration(cacheName);\n\n          await cacheExpiration.updateTimestamp(request.url);\n          await cacheExpiration.expireEntries();\n        };\n\n        {\n          if (!(config.maxEntries || config.maxAgeSeconds)) {\n            throw new WorkboxError_js.WorkboxError('max-entries-or-age-required', {\n              moduleName: 'workbox-expiration',\n              className: 'Plugin',\n              funcName: 'constructor'\n            });\n          }\n\n          if (config.maxEntries) {\n            assert_js.assert.isType(config.maxEntries, 'number', {\n              moduleName: 'workbox-expiration',\n              className: 'Plugin',\n              funcName: 'constructor',\n              paramName: 'config.maxEntries'\n            });\n          }\n\n          if (config.maxAgeSeconds) {\n            assert_js.assert.isType(config.maxAgeSeconds, 'number', {\n              moduleName: 'workbox-expiration',\n              className: 'Plugin',\n              funcName: 'constructor',\n              paramName: 'config.maxAgeSeconds'\n            });\n          }\n        }\n\n        this._config = config;\n        this._maxAgeSeconds = config.maxAgeSeconds;\n        this._cacheExpirations = new Map();\n\n        if (config.purgeOnQuotaError) {\n          registerQuotaErrorCallback_js.registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());\n        }\n      }\n      /**\n       * A simple helper method to return a CacheExpiration instance for a given\n       * cache name.\n       *\n       * @param {string} cacheName\n       * @return {CacheExpiration}\n       *\n       * @private\n       */\n\n\n      _getCacheExpiration(cacheName) {\n        if (cacheName === cacheNames_js.cacheNames.getRuntimeName()) {\n          throw new WorkboxError_js.WorkboxError('expire-custom-caches-only');\n        }\n\n        let cacheExpiration = this._cacheExpirations.get(cacheName);\n\n        if (!cacheExpiration) {\n          cacheExpiration = new CacheExpiration(cacheName, this._config);\n\n          this._cacheExpirations.set(cacheName, cacheExpiration);\n        }\n\n        return cacheExpiration;\n      }\n      /**\n       * @param {Response} cachedResponse\n       * @return {boolean}\n       *\n       * @private\n       */\n\n\n      _isResponseDateFresh(cachedResponse) {\n        if (!this._maxAgeSeconds) {\n          // We aren't expiring by age, so return true, it's fresh\n          return true;\n        } // Check if the 'date' header will suffice a quick expiration check.\n        // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\n        // discussion.\n\n\n        const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\n\n        if (dateHeaderTimestamp === null) {\n          // Unable to parse date, so assume it's fresh.\n          return true;\n        } // If we have a valid headerTime, then our response is fresh iff the\n        // headerTime plus maxAgeSeconds is greater than the current time.\n\n\n        const now = Date.now();\n        return dateHeaderTimestamp >= now - this._maxAgeSeconds * 1000;\n      }\n      /**\n       * This method will extract the data header and parse it into a useful\n       * value.\n       *\n       * @param {Response} cachedResponse\n       * @return {number|null}\n       *\n       * @private\n       */\n\n\n      _getDateHeaderTimestamp(cachedResponse) {\n        if (!cachedResponse.headers.has('date')) {\n          return null;\n        }\n\n        const dateHeader = cachedResponse.headers.get('date');\n        const parsedDate = new Date(dateHeader);\n        const headerTime = parsedDate.getTime(); // If the Date header was invalid for some reason, parsedDate.getTime()\n        // will return NaN.\n\n        if (isNaN(headerTime)) {\n          return null;\n        }\n\n        return headerTime;\n      }\n      /**\n       * This is a helper method that performs two operations:\n       *\n       * - Deletes *all* the underlying Cache instances associated with this plugin\n       * instance, by calling caches.delete() on your behalf.\n       * - Deletes the metadata from IndexedDB used to keep track of expiration\n       * details for each Cache instance.\n       *\n       * When using cache expiration, calling this method is preferable to calling\n       * `caches.delete()` directly, since this will ensure that the IndexedDB\n       * metadata is also cleanly removed and open IndexedDB instances are deleted.\n       *\n       * Note that if you're *not* using cache expiration for a given cache, calling\n       * `caches.delete()` and passing in the cache's name should be sufficient.\n       * There is no Workbox-specific method needed for cleanup in that case.\n       */\n\n\n      async deleteCacheAndMetadata() {\n        // Do this one at a time instead of all at once via `Promise.all()` to\n        // reduce the chance of inconsistency if a promise rejects.\n        for (const [cacheName, cacheExpiration] of this._cacheExpirations) {\n          await self.caches.delete(cacheName);\n          await cacheExpiration.delete();\n        } // Reset this._cacheExpirations to its initial state.\n\n\n        this._cacheExpirations = new Map();\n      }\n\n    }\n\n    exports.CacheExpiration = CacheExpiration;\n    exports.ExpirationPlugin = ExpirationPlugin;\n\n    return exports;\n\n}({}, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core));\n//# sourceMappingURL=workbox-expiration.dev.js.map"},{"path":"/workbox-v5.1.3/workbox-expiration.prod.js","content":"this.workbox=this.workbox||{},this.workbox.expiration=function(t,e,s,i,a,n,h){\"use strict\";try{self[\"workbox:expiration:5.1.3\"]&&_()}catch(t){}const r=t=>{const e=new URL(t,location.href);return e.hash=\"\",e.href};class c{constructor(t){this.t=t,this.s=new i.DBWrapper(\"workbox-expiration\",1,{onupgradeneeded:t=>this.i(t)})}i(t){const e=t.target.result.createObjectStore(\"cache-entries\",{keyPath:\"id\"});e.createIndex(\"cacheName\",\"cacheName\",{unique:!1}),e.createIndex(\"timestamp\",\"timestamp\",{unique:!1}),a.deleteDatabase(this.t)}async setTimestamp(t,e){const s={url:t=r(t),timestamp:e,cacheName:this.t,id:this.h(t)};await this.s.put(\"cache-entries\",s)}async getTimestamp(t){return(await this.s.get(\"cache-entries\",this.h(t))).timestamp}async expireEntries(t,e){const s=await this.s.transaction(\"cache-entries\",\"readwrite\",(s,i)=>{const a=s.objectStore(\"cache-entries\").index(\"timestamp\").openCursor(null,\"prev\"),n=[];let h=0;a.onsuccess=()=>{const s=a.result;if(s){const i=s.value;i.cacheName===this.t&&(t&&i.timestamp<t||e&&h>=e?n.push(s.value):h++),s.continue()}else i(n)}}),i=[];for(const t of s)await this.s.delete(\"cache-entries\",t.id),i.push(t.url);return i}h(t){return this.t+\"|\"+r(t)}}class o{constructor(t,e={}){this.o=!1,this.u=!1,this.l=e.maxEntries,this.m=e.maxAgeSeconds,this.t=t,this.p=new c(t)}async expireEntries(){if(this.o)return void(this.u=!0);this.o=!0;const t=this.m?Date.now()-1e3*this.m:0,s=await this.p.expireEntries(t,this.l),i=await self.caches.open(this.t);for(const t of s)await i.delete(t);this.o=!1,this.u&&(this.u=!1,e.dontWaitFor(this.expireEntries()))}async updateTimestamp(t){await this.p.setTimestamp(t,Date.now())}async isURLExpired(t){if(this.m){return await this.p.getTimestamp(t)<Date.now()-1e3*this.m}return!1}async delete(){this.u=!1,await this.p.expireEntries(1/0)}}return t.CacheExpiration=o,t.ExpirationPlugin=class{constructor(t={}){this.cachedResponseWillBeUsed=async({event:t,request:s,cacheName:i,cachedResponse:a})=>{if(!a)return null;const n=this.k(a),h=this.D(i);e.dontWaitFor(h.expireEntries());const r=h.updateTimestamp(s.url);if(t)try{t.waitUntil(r)}catch(t){}return n?a:null},this.cacheDidUpdate=async({cacheName:t,request:e})=>{const s=this.D(t);await s.updateTimestamp(e.url),await s.expireEntries()},this.N=t,this.m=t.maxAgeSeconds,this.g=new Map,t.purgeOnQuotaError&&h.registerQuotaErrorCallback(()=>this.deleteCacheAndMetadata())}D(t){if(t===n.cacheNames.getRuntimeName())throw new s.WorkboxError(\"expire-custom-caches-only\");let e=this.g.get(t);return e||(e=new o(t,this.N),this.g.set(t,e)),e}k(t){if(!this.m)return!0;const e=this._(t);return null===e||e>=Date.now()-1e3*this.m}_(t){if(!t.headers.has(\"date\"))return null;const e=t.headers.get(\"date\"),s=new Date(e).getTime();return isNaN(s)?null:s}async deleteCacheAndMetadata(){for(const[t,e]of this.g)await self.caches.delete(t),await e.delete();this.g=new Map}},t}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core);\n//# sourceMappingURL=workbox-expiration.prod.js.map"},{"path":"/workbox-v5.1.3/workbox-navigation-preload.dev.js","content":"this.workbox = this.workbox || {};\nthis.workbox.navigationPreload = (function (exports, logger_js) {\n    'use strict';\n\n    try {\n      self['workbox:navigation-preload:5.1.3'] && _();\n    } catch (e) {}\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * @return {boolean} Whether or not the current browser supports enabling\n     * navigation preload.\n     *\n     * @memberof module:workbox-navigation-preload\n     */\n\n    function isSupported() {\n      return Boolean(self.registration && self.registration.navigationPreload);\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * If the browser supports Navigation Preload, then this will disable it.\n     *\n     * @memberof module:workbox-navigation-preload\n     */\n\n    function disable() {\n      if (isSupported()) {\n        self.addEventListener('activate', event => {\n          event.waitUntil(self.registration.navigationPreload.disable().then(() => {\n            {\n              logger_js.logger.log(`Navigation preload is disabled.`);\n            }\n          }));\n        });\n      } else {\n        {\n          logger_js.logger.log(`Navigation preload is not supported in this browser.`);\n        }\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * If the browser supports Navigation Preload, then this will enable it.\n     *\n     * @param {string} [headerValue] Optionally, allows developers to\n     * [override](https://developers.google.com/web/updates/2017/02/navigation-preload#changing_the_header)\n     * the value of the `Service-Worker-Navigation-Preload` header which will be\n     * sent to the server when making the navigation request.\n     *\n     * @memberof module:workbox-navigation-preload\n     */\n\n    function enable(headerValue) {\n      if (isSupported()) {\n        self.addEventListener('activate', event => {\n          event.waitUntil(self.registration.navigationPreload.enable().then(() => {\n            // Defaults to Service-Worker-Navigation-Preload: true if not set.\n            if (headerValue) {\n              self.registration.navigationPreload.setHeaderValue(headerValue);\n            }\n\n            {\n              logger_js.logger.log(`Navigation preload is enabled.`);\n            }\n          }));\n        });\n      } else {\n        {\n          logger_js.logger.log(`Navigation preload is not supported in this browser.`);\n        }\n      }\n    }\n\n    exports.disable = disable;\n    exports.enable = enable;\n    exports.isSupported = isSupported;\n\n    return exports;\n\n}({}, workbox.core._private));\n//# sourceMappingURL=workbox-navigation-preload.dev.js.map"},{"path":"/workbox-v5.1.3/workbox-navigation-preload.prod.js","content":"this.workbox=this.workbox||{},this.workbox.navigationPreload=function(t){\"use strict\";try{self[\"workbox:navigation-preload:5.1.3\"]&&_()}catch(t){}function e(){return Boolean(self.registration&&self.registration.navigationPreload)}return t.disable=function(){e()&&self.addEventListener(\"activate\",t=>{t.waitUntil(self.registration.navigationPreload.disable().then(()=>{}))})},t.enable=function(t){e()&&self.addEventListener(\"activate\",e=>{e.waitUntil(self.registration.navigationPreload.enable().then(()=>{t&&self.registration.navigationPreload.setHeaderValue(t)}))})},t.isSupported=e,t}({});\n//# sourceMappingURL=workbox-navigation-preload.prod.js.map"},{"path":"/workbox-v5.1.3/workbox-offline-ga.dev.js","content":"this.workbox = this.workbox || {};\nthis.workbox.googleAnalytics = (function (exports, BackgroundSyncPlugin_js, cacheNames_js, getFriendlyURL_js, logger_js, Route_js, Router_js, NetworkFirst_js, NetworkOnly_js) {\n    'use strict';\n\n    try {\n      self['workbox:google-analytics:5.1.3'] && _();\n    } catch (e) {}\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const QUEUE_NAME = 'workbox-google-analytics';\n    const MAX_RETENTION_TIME = 60 * 48; // Two days in minutes\n\n    const GOOGLE_ANALYTICS_HOST = 'www.google-analytics.com';\n    const GTM_HOST = 'www.googletagmanager.com';\n    const ANALYTICS_JS_PATH = '/analytics.js';\n    const GTAG_JS_PATH = '/gtag/js';\n    const GTM_JS_PATH = '/gtm.js';\n    // endpoints. Most of the time the default path (/collect) is used, but\n    // occasionally an experimental endpoint is used when testing new features,\n    // (e.g. /r/collect or /j/collect)\n\n    const COLLECT_PATHS_REGEX = /^\\/(\\w+\\/)?collect/;\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Creates the requestWillDequeue callback to be used with the background\n     * sync plugin. The callback takes the failed request and adds the\n     * `qt` param based on the current time, as well as applies any other\n     * user-defined hit modifications.\n     *\n     * @param {Object} config See {@link module:workbox-google-analytics.initialize}.\n     * @return {Function} The requestWillDequeue callback function.\n     *\n     * @private\n     */\n\n    const createOnSyncCallback = config => {\n      return async ({\n        queue\n      }) => {\n        let entry;\n\n        while (entry = await queue.shiftRequest()) {\n          const {\n            request,\n            timestamp\n          } = entry;\n          const url = new URL(request.url);\n\n          try {\n            // Measurement protocol requests can set their payload parameters in\n            // either the URL query string (for GET requests) or the POST body.\n            const params = request.method === 'POST' ? new URLSearchParams((await request.clone().text())) : url.searchParams; // Calculate the qt param, accounting for the fact that an existing\n            // qt param may be present and should be updated rather than replaced.\n\n            const originalHitTime = timestamp - (Number(params.get('qt')) || 0);\n            const queueTime = Date.now() - originalHitTime; // Set the qt param prior to applying hitFilter or parameterOverrides.\n\n            params.set('qt', String(queueTime)); // Apply `parameterOverrides`, if set.\n\n            if (config.parameterOverrides) {\n              for (const param of Object.keys(config.parameterOverrides)) {\n                const value = config.parameterOverrides[param];\n                params.set(param, value);\n              }\n            } // Apply `hitFilter`, if set.\n\n\n            if (typeof config.hitFilter === 'function') {\n              config.hitFilter.call(null, params);\n            } // Retry the fetch. Ignore URL search params from the URL as they're\n            // now in the post body.\n\n\n            await fetch(new Request(url.origin + url.pathname, {\n              body: params.toString(),\n              method: 'POST',\n              mode: 'cors',\n              credentials: 'omit',\n              headers: {\n                'Content-Type': 'text/plain'\n              }\n            }));\n\n            if (\"dev\" !== 'production') {\n              logger_js.logger.log(`Request for '${getFriendlyURL_js.getFriendlyURL(url.href)}'` + `has been replayed`);\n            }\n          } catch (err) {\n            await queue.unshiftRequest(entry);\n\n            {\n              logger_js.logger.log(`Request for '${getFriendlyURL_js.getFriendlyURL(url.href)}'` + `failed to replay, putting it back in the queue.`);\n            }\n\n            throw err;\n          }\n        }\n\n        {\n          logger_js.logger.log(`All Google Analytics request successfully replayed; ` + `the queue is now empty!`);\n        }\n      };\n    };\n    /**\n     * Creates GET and POST routes to catch failed Measurement Protocol hits.\n     *\n     * @param {BackgroundSyncPlugin} bgSyncPlugin\n     * @return {Array<Route>} The created routes.\n     *\n     * @private\n     */\n\n\n    const createCollectRoutes = bgSyncPlugin => {\n      const match = ({\n        url\n      }) => url.hostname === GOOGLE_ANALYTICS_HOST && COLLECT_PATHS_REGEX.test(url.pathname);\n\n      const handler = new NetworkOnly_js.NetworkOnly({\n        plugins: [bgSyncPlugin]\n      });\n      return [new Route_js.Route(match, handler, 'GET'), new Route_js.Route(match, handler, 'POST')];\n    };\n    /**\n     * Creates a route with a network first strategy for the analytics.js script.\n     *\n     * @param {string} cacheName\n     * @return {Route} The created route.\n     *\n     * @private\n     */\n\n\n    const createAnalyticsJsRoute = cacheName => {\n      const match = ({\n        url\n      }) => url.hostname === GOOGLE_ANALYTICS_HOST && url.pathname === ANALYTICS_JS_PATH;\n\n      const handler = new NetworkFirst_js.NetworkFirst({\n        cacheName\n      });\n      return new Route_js.Route(match, handler, 'GET');\n    };\n    /**\n     * Creates a route with a network first strategy for the gtag.js script.\n     *\n     * @param {string} cacheName\n     * @return {Route} The created route.\n     *\n     * @private\n     */\n\n\n    const createGtagJsRoute = cacheName => {\n      const match = ({\n        url\n      }) => url.hostname === GTM_HOST && url.pathname === GTAG_JS_PATH;\n\n      const handler = new NetworkFirst_js.NetworkFirst({\n        cacheName\n      });\n      return new Route_js.Route(match, handler, 'GET');\n    };\n    /**\n     * Creates a route with a network first strategy for the gtm.js script.\n     *\n     * @param {string} cacheName\n     * @return {Route} The created route.\n     *\n     * @private\n     */\n\n\n    const createGtmJsRoute = cacheName => {\n      const match = ({\n        url\n      }) => url.hostname === GTM_HOST && url.pathname === GTM_JS_PATH;\n\n      const handler = new NetworkFirst_js.NetworkFirst({\n        cacheName\n      });\n      return new Route_js.Route(match, handler, 'GET');\n    };\n    /**\n     * @param {Object=} [options]\n     * @param {Object} [options.cacheName] The cache name to store and retrieve\n     *     analytics.js. Defaults to the cache names provided by `workbox-core`.\n     * @param {Object} [options.parameterOverrides]\n     *     [Measurement Protocol parameters](https://developers.google.com/analytics/devguides/collection/protocol/v1/parameters),\n     *     expressed as key/value pairs, to be added to replayed Google Analytics\n     *     requests. This can be used to, e.g., set a custom dimension indicating\n     *     that the request was replayed.\n     * @param {Function} [options.hitFilter] A function that allows you to modify\n     *     the hit parameters prior to replaying\n     *     the hit. The function is invoked with the original hit's URLSearchParams\n     *     object as its only argument.\n     *\n     * @memberof module:workbox-google-analytics\n     */\n\n\n    const initialize = (options = {}) => {\n      const cacheName = cacheNames_js.cacheNames.getGoogleAnalyticsName(options.cacheName);\n      const bgSyncPlugin = new BackgroundSyncPlugin_js.BackgroundSyncPlugin(QUEUE_NAME, {\n        maxRetentionTime: MAX_RETENTION_TIME,\n        onSync: createOnSyncCallback(options)\n      });\n      const routes = [createGtmJsRoute(cacheName), createAnalyticsJsRoute(cacheName), createGtagJsRoute(cacheName), ...createCollectRoutes(bgSyncPlugin)];\n      const router = new Router_js.Router();\n\n      for (const route of routes) {\n        router.registerRoute(route);\n      }\n\n      router.addFetchListener();\n    };\n\n    exports.initialize = initialize;\n\n    return exports;\n\n}({}, workbox.backgroundSync, workbox.core._private, workbox.core._private, workbox.core._private, workbox.routing, workbox.routing, workbox.strategies, workbox.strategies));\n//# sourceMappingURL=workbox-offline-ga.dev.js.map"},{"path":"/workbox-v5.1.3/workbox-offline-ga.prod.js","content":"this.workbox=this.workbox||{},this.workbox.googleAnalytics=function(t,o,e,n,a,c,r,w,s){\"use strict\";try{self[\"workbox:google-analytics:5.1.3\"]&&_()}catch(t){}const i=/^\\/(\\w+\\/)?collect/,l=t=>{const o=({url:t})=>\"www.google-analytics.com\"===t.hostname&&i.test(t.pathname),e=new s.NetworkOnly({plugins:[t]});return[new c.Route(o,e,\"GET\"),new c.Route(o,e,\"POST\")]},g=t=>{const o=new w.NetworkFirst({cacheName:t});return new c.Route(({url:t})=>\"www.google-analytics.com\"===t.hostname&&\"/analytics.js\"===t.pathname,o,\"GET\")},m=t=>{const o=new w.NetworkFirst({cacheName:t});return new c.Route(({url:t})=>\"www.googletagmanager.com\"===t.hostname&&\"/gtag/js\"===t.pathname,o,\"GET\")},u=t=>{const o=new w.NetworkFirst({cacheName:t});return new c.Route(({url:t})=>\"www.googletagmanager.com\"===t.hostname&&\"/gtm.js\"===t.pathname,o,\"GET\")};return t.initialize=(t={})=>{const n=e.cacheNames.getGoogleAnalyticsName(t.cacheName),a=new o.BackgroundSyncPlugin(\"workbox-google-analytics\",{maxRetentionTime:2880,onSync:(c=t,async({queue:t})=>{let o;for(;o=await t.shiftRequest();){const{request:e,timestamp:n}=o,a=new URL(e.url);try{const t=\"POST\"===e.method?new URLSearchParams(await e.clone().text()):a.searchParams,o=n-(Number(t.get(\"qt\"))||0),r=Date.now()-o;if(t.set(\"qt\",String(r)),c.parameterOverrides)for(const o of Object.keys(c.parameterOverrides)){const e=c.parameterOverrides[o];t.set(o,e)}\"function\"==typeof c.hitFilter&&c.hitFilter.call(null,t),await fetch(new Request(a.origin+a.pathname,{body:t.toString(),method:\"POST\",mode:\"cors\",credentials:\"omit\",headers:{\"Content-Type\":\"text/plain\"}}))}catch(e){throw await t.unshiftRequest(o),e}}})});var c;const w=[u(n),g(n),m(n),...l(a)],s=new r.Router;for(const t of w)s.registerRoute(t);s.addFetchListener()},t}({},workbox.backgroundSync,workbox.core._private,workbox.core._private,workbox.core._private,workbox.routing,workbox.routing,workbox.strategies,workbox.strategies);\n//# sourceMappingURL=workbox-offline-ga.prod.js.map"},{"path":"/workbox-v5.1.3/workbox-precaching.dev.js","content":"this.workbox = this.workbox || {};\nthis.workbox.precaching = (function (exports, cacheNames_js, getFriendlyURL_js, logger_js, assert_js, cacheWrapper_js, fetchWrapper_js, WorkboxError_js, copyResponse_js) {\n    'use strict';\n\n    try {\n      self['workbox:precaching:5.1.3'] && _();\n    } catch (e) {}\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const plugins = [];\n    const precachePlugins = {\n      /*\n       * @return {Array}\n       * @private\n       */\n      get() {\n        return plugins;\n      },\n\n      /*\n       * @param {Array} newPlugins\n       * @private\n       */\n      add(newPlugins) {\n        plugins.push(...newPlugins);\n      }\n\n    };\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Adds plugins to precaching.\n     *\n     * @param {Array<Object>} newPlugins\n     *\n     * @memberof module:workbox-precaching\n     */\n\n    function addPlugins(newPlugins) {\n      precachePlugins.add(newPlugins);\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n\n    const REVISION_SEARCH_PARAM = '__WB_REVISION__';\n    /**\n     * Converts a manifest entry into a versioned URL suitable for precaching.\n     *\n     * @param {Object|string} entry\n     * @return {string} A URL with versioning info.\n     *\n     * @private\n     * @memberof module:workbox-precaching\n     */\n\n    function createCacheKey(entry) {\n      if (!entry) {\n        throw new WorkboxError_js.WorkboxError('add-to-cache-list-unexpected-type', {\n          entry\n        });\n      } // If a precache manifest entry is a string, it's assumed to be a versioned\n      // URL, like '/app.abcd1234.js'. Return as-is.\n\n\n      if (typeof entry === 'string') {\n        const urlObject = new URL(entry, location.href);\n        return {\n          cacheKey: urlObject.href,\n          url: urlObject.href\n        };\n      }\n\n      const {\n        revision,\n        url\n      } = entry;\n\n      if (!url) {\n        throw new WorkboxError_js.WorkboxError('add-to-cache-list-unexpected-type', {\n          entry\n        });\n      } // If there's just a URL and no revision, then it's also assumed to be a\n      // versioned URL.\n\n\n      if (!revision) {\n        const urlObject = new URL(url, location.href);\n        return {\n          cacheKey: urlObject.href,\n          url: urlObject.href\n        };\n      } // Otherwise, construct a properly versioned URL using the custom Workbox\n      // search parameter along with the revision info.\n\n\n      const cacheKeyURL = new URL(url, location.href);\n      const originalURL = new URL(url, location.href);\n      cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM, revision);\n      return {\n        cacheKey: cacheKeyURL.href,\n        url: originalURL.href\n      };\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * @param {string} groupTitle\n     * @param {Array<string>} deletedURLs\n     *\n     * @private\n     */\n\n    const logGroup = (groupTitle, deletedURLs) => {\n      logger_js.logger.groupCollapsed(groupTitle);\n\n      for (const url of deletedURLs) {\n        logger_js.logger.log(url);\n      }\n\n      logger_js.logger.groupEnd();\n    };\n    /**\n     * @param {Array<string>} deletedURLs\n     *\n     * @private\n     * @memberof module:workbox-precaching\n     */\n\n\n    function printCleanupDetails(deletedURLs) {\n      const deletionCount = deletedURLs.length;\n\n      if (deletionCount > 0) {\n        logger_js.logger.groupCollapsed(`During precaching cleanup, ` + `${deletionCount} cached ` + `request${deletionCount === 1 ? ' was' : 's were'} deleted.`);\n        logGroup('Deleted Cache Requests', deletedURLs);\n        logger_js.logger.groupEnd();\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * @param {string} groupTitle\n     * @param {Array<string>} urls\n     *\n     * @private\n     */\n\n    function _nestedGroup(groupTitle, urls) {\n      if (urls.length === 0) {\n        return;\n      }\n\n      logger_js.logger.groupCollapsed(groupTitle);\n\n      for (const url of urls) {\n        logger_js.logger.log(url);\n      }\n\n      logger_js.logger.groupEnd();\n    }\n    /**\n     * @param {Array<string>} urlsToPrecache\n     * @param {Array<string>} urlsAlreadyPrecached\n     *\n     * @private\n     * @memberof module:workbox-precaching\n     */\n\n\n    function printInstallDetails(urlsToPrecache, urlsAlreadyPrecached) {\n      const precachedCount = urlsToPrecache.length;\n      const alreadyPrecachedCount = urlsAlreadyPrecached.length;\n\n      if (precachedCount || alreadyPrecachedCount) {\n        let message = `Precaching ${precachedCount} file${precachedCount === 1 ? '' : 's'}.`;\n\n        if (alreadyPrecachedCount > 0) {\n          message += ` ${alreadyPrecachedCount} ` + `file${alreadyPrecachedCount === 1 ? ' is' : 's are'} already cached.`;\n        }\n\n        logger_js.logger.groupCollapsed(message);\n\n        _nestedGroup(`View newly precached URLs.`, urlsToPrecache);\n\n        _nestedGroup(`View previously precached URLs.`, urlsAlreadyPrecached);\n\n        logger_js.logger.groupEnd();\n      }\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Performs efficient precaching of assets.\n     *\n     * @memberof module:workbox-precaching\n     */\n\n    class PrecacheController {\n      /**\n       * Create a new PrecacheController.\n       *\n       * @param {string} [cacheName] An optional name for the cache, to override\n       * the default precache name.\n       */\n      constructor(cacheName) {\n        this._cacheName = cacheNames_js.cacheNames.getPrecacheName(cacheName);\n        this._urlsToCacheKeys = new Map();\n        this._urlsToCacheModes = new Map();\n        this._cacheKeysToIntegrities = new Map();\n      }\n      /**\n       * This method will add items to the precache list, removing duplicates\n       * and ensuring the information is valid.\n       *\n       * @param {\n       * Array<module:workbox-precaching.PrecacheController.PrecacheEntry|string>\n       * } entries Array of entries to precache.\n       */\n\n\n      addToCacheList(entries) {\n        {\n          assert_js.assert.isArray(entries, {\n            moduleName: 'workbox-precaching',\n            className: 'PrecacheController',\n            funcName: 'addToCacheList',\n            paramName: 'entries'\n          });\n        }\n\n        const urlsToWarnAbout = [];\n\n        for (const entry of entries) {\n          // See https://github.com/GoogleChrome/workbox/issues/2259\n          if (typeof entry === 'string') {\n            urlsToWarnAbout.push(entry);\n          } else if (entry && entry.revision === undefined) {\n            urlsToWarnAbout.push(entry.url);\n          }\n\n          const {\n            cacheKey,\n            url\n          } = createCacheKey(entry);\n          const cacheMode = typeof entry !== 'string' && entry.revision ? 'reload' : 'default';\n\n          if (this._urlsToCacheKeys.has(url) && this._urlsToCacheKeys.get(url) !== cacheKey) {\n            throw new WorkboxError_js.WorkboxError('add-to-cache-list-conflicting-entries', {\n              firstEntry: this._urlsToCacheKeys.get(url),\n              secondEntry: cacheKey\n            });\n          }\n\n          if (typeof entry !== 'string' && entry.integrity) {\n            if (this._cacheKeysToIntegrities.has(cacheKey) && this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n              throw new WorkboxError_js.WorkboxError('add-to-cache-list-conflicting-integrities', {\n                url\n              });\n            }\n\n            this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n          }\n\n          this._urlsToCacheKeys.set(url, cacheKey);\n\n          this._urlsToCacheModes.set(url, cacheMode);\n\n          if (urlsToWarnAbout.length > 0) {\n            const warningMessage = `Workbox is precaching URLs without revision ` + `info: ${urlsToWarnAbout.join(', ')}\\nThis is generally NOT safe. ` + `Learn more at https://bit.ly/wb-precache`;\n\n            {\n              logger_js.logger.warn(warningMessage);\n            }\n          }\n        }\n      }\n      /**\n       * Precaches new and updated assets. Call this method from the service worker\n       * install event.\n       *\n       * @param {Object} options\n       * @param {Event} [options.event] The install event (if needed).\n       * @param {Array<Object>} [options.plugins] Plugins to be used for fetching\n       * and caching during install.\n       * @return {Promise<module:workbox-precaching.InstallResult>}\n       */\n\n\n      async install({\n        event,\n        plugins\n      } = {}) {\n        {\n          if (plugins) {\n            assert_js.assert.isArray(plugins, {\n              moduleName: 'workbox-precaching',\n              className: 'PrecacheController',\n              funcName: 'install',\n              paramName: 'plugins'\n            });\n          }\n        }\n\n        const toBePrecached = [];\n        const alreadyPrecached = [];\n        const cache = await self.caches.open(this._cacheName);\n        const alreadyCachedRequests = await cache.keys();\n        const existingCacheKeys = new Set(alreadyCachedRequests.map(request => request.url));\n\n        for (const [url, cacheKey] of this._urlsToCacheKeys) {\n          if (existingCacheKeys.has(cacheKey)) {\n            alreadyPrecached.push(url);\n          } else {\n            toBePrecached.push({\n              cacheKey,\n              url\n            });\n          }\n        }\n\n        const precacheRequests = toBePrecached.map(({\n          cacheKey,\n          url\n        }) => {\n          const integrity = this._cacheKeysToIntegrities.get(cacheKey);\n\n          const cacheMode = this._urlsToCacheModes.get(url);\n\n          return this._addURLToCache({\n            cacheKey,\n            cacheMode,\n            event,\n            integrity,\n            plugins,\n            url\n          });\n        });\n        await Promise.all(precacheRequests);\n        const updatedURLs = toBePrecached.map(item => item.url);\n\n        {\n          printInstallDetails(updatedURLs, alreadyPrecached);\n        }\n\n        return {\n          updatedURLs,\n          notUpdatedURLs: alreadyPrecached\n        };\n      }\n      /**\n       * Deletes assets that are no longer present in the current precache manifest.\n       * Call this method from the service worker activate event.\n       *\n       * @return {Promise<module:workbox-precaching.CleanupResult>}\n       */\n\n\n      async activate() {\n        const cache = await self.caches.open(this._cacheName);\n        const currentlyCachedRequests = await cache.keys();\n        const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n        const deletedURLs = [];\n\n        for (const request of currentlyCachedRequests) {\n          if (!expectedCacheKeys.has(request.url)) {\n            await cache.delete(request);\n            deletedURLs.push(request.url);\n          }\n        }\n\n        {\n          printCleanupDetails(deletedURLs);\n        }\n\n        return {\n          deletedURLs\n        };\n      }\n      /**\n       * Requests the entry and saves it to the cache if the response is valid.\n       * By default, any response with a status code of less than 400 (including\n       * opaque responses) is considered valid.\n       *\n       * If you need to use custom criteria to determine what's valid and what\n       * isn't, then pass in an item in `options.plugins` that implements the\n       * `cacheWillUpdate()` lifecycle event.\n       *\n       * @private\n       * @param {Object} options\n       * @param {string} options.cacheKey The string to use a cache key.\n       * @param {string} options.url The URL to fetch and cache.\n       * @param {string} [options.cacheMode] The cache mode for the network request.\n       * @param {Event} [options.event] The install event (if passed).\n       * @param {Array<Object>} [options.plugins] An array of plugins to apply to\n       * fetch and caching.\n       * @param {string} [options.integrity] The value to use for the `integrity`\n       * field when making the request.\n       */\n\n\n      async _addURLToCache({\n        cacheKey,\n        url,\n        cacheMode,\n        event,\n        plugins,\n        integrity\n      }) {\n        const request = new Request(url, {\n          integrity,\n          cache: cacheMode,\n          credentials: 'same-origin'\n        });\n        let response = await fetchWrapper_js.fetchWrapper.fetch({\n          event,\n          plugins,\n          request\n        }); // Allow developers to override the default logic about what is and isn't\n        // valid by passing in a plugin implementing cacheWillUpdate(), e.g.\n        // a `CacheableResponsePlugin` instance.\n\n        let cacheWillUpdatePlugin;\n\n        for (const plugin of plugins || []) {\n          if ('cacheWillUpdate' in plugin) {\n            cacheWillUpdatePlugin = plugin;\n          }\n        }\n\n        const isValidResponse = cacheWillUpdatePlugin ? // Use a callback if provided. It returns a truthy value if valid.\n        // NOTE: invoke the method on the plugin instance so the `this` context\n        // is correct.\n        await cacheWillUpdatePlugin.cacheWillUpdate({\n          event,\n          request,\n          response\n        }) : // Otherwise, default to considering any response status under 400 valid.\n        // This includes, by default, considering opaque responses valid.\n        response.status < 400; // Consider this a failure, leading to the `install` handler failing, if\n        // we get back an invalid response.\n\n        if (!isValidResponse) {\n          throw new WorkboxError_js.WorkboxError('bad-precaching-response', {\n            url,\n            status: response.status\n          });\n        } // Redirected responses cannot be used to satisfy a navigation request, so\n        // any redirected response must be \"copied\" rather than cloned, so the new\n        // response doesn't contain the `redirected` flag. See:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1\n\n\n        if (response.redirected) {\n          response = await copyResponse_js.copyResponse(response);\n        }\n\n        await cacheWrapper_js.cacheWrapper.put({\n          event,\n          plugins,\n          response,\n          // `request` already uses `url`. We may be able to reuse it.\n          request: cacheKey === url ? request : new Request(cacheKey),\n          cacheName: this._cacheName,\n          matchOptions: {\n            ignoreSearch: true\n          }\n        });\n      }\n      /**\n       * Returns a mapping of a precached URL to the corresponding cache key, taking\n       * into account the revision information for the URL.\n       *\n       * @return {Map<string, string>} A URL to cache key mapping.\n       */\n\n\n      getURLsToCacheKeys() {\n        return this._urlsToCacheKeys;\n      }\n      /**\n       * Returns a list of all the URLs that have been precached by the current\n       * service worker.\n       *\n       * @return {Array<string>} The precached URLs.\n       */\n\n\n      getCachedURLs() {\n        return [...this._urlsToCacheKeys.keys()];\n      }\n      /**\n       * Returns the cache key used for storing a given URL. If that URL is\n       * unversioned, like `/index.html', then the cache key will be the original\n       * URL with a search parameter appended to it.\n       *\n       * @param {string} url A URL whose cache key you want to look up.\n       * @return {string} The versioned URL that corresponds to a cache key\n       * for the original URL, or undefined if that URL isn't precached.\n       */\n\n\n      getCacheKeyForURL(url) {\n        const urlObject = new URL(url, location.href);\n        return this._urlsToCacheKeys.get(urlObject.href);\n      }\n      /**\n       * This acts as a drop-in replacement for [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)\n       * with the following differences:\n       *\n       * - It knows what the name of the precache is, and only checks in that cache.\n       * - It allows you to pass in an \"original\" URL without versioning parameters,\n       * and it will automatically look up the correct cache key for the currently\n       * active revision of that URL.\n       *\n       * E.g., `matchPrecache('index.html')` will find the correct precached\n       * response for the currently active service worker, even if the actual cache\n       * key is `'/index.html?__WB_REVISION__=1234abcd'`.\n       *\n       * @param {string|Request} request The key (without revisioning parameters)\n       * to look up in the precache.\n       * @return {Promise<Response|undefined>}\n       */\n\n\n      async matchPrecache(request) {\n        const url = request instanceof Request ? request.url : request;\n        const cacheKey = this.getCacheKeyForURL(url);\n\n        if (cacheKey) {\n          const cache = await self.caches.open(this._cacheName);\n          return cache.match(cacheKey);\n        }\n\n        return undefined;\n      }\n      /**\n       * Returns a function that can be used within a\n       * {@link module:workbox-routing.Route} that will find a response for the\n       * incoming request against the precache.\n       *\n       * If for an unexpected reason there is a cache miss for the request,\n       * this will fall back to retrieving the `Response` via `fetch()` when\n       * `fallbackToNetwork` is `true`.\n       *\n       * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the\n       * response from the network if there's a precache miss.\n       * @return {module:workbox-routing~handlerCallback}\n       */\n\n\n      createHandler(fallbackToNetwork = true) {\n        return async ({\n          request\n        }) => {\n          try {\n            const response = await this.matchPrecache(request);\n\n            if (response) {\n              return response;\n            } // This shouldn't normally happen, but there are edge cases:\n            // https://github.com/GoogleChrome/workbox/issues/1441\n\n\n            throw new WorkboxError_js.WorkboxError('missing-precache-entry', {\n              cacheName: this._cacheName,\n              url: request instanceof Request ? request.url : request\n            });\n          } catch (error) {\n            if (fallbackToNetwork) {\n              {\n                logger_js.logger.debug(`Unable to respond with precached response. ` + `Falling back to network.`, error);\n              }\n\n              return fetch(request);\n            }\n\n            throw error;\n          }\n        };\n      }\n      /**\n       * Returns a function that looks up `url` in the precache (taking into\n       * account revision information), and returns the corresponding `Response`.\n       *\n       * If for an unexpected reason there is a cache miss when looking up `url`,\n       * this will fall back to retrieving the `Response` via `fetch()` when\n       * `fallbackToNetwork` is `true`.\n       *\n       * @param {string} url The precached URL which will be used to lookup the\n       * `Response`.\n       * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the\n       * response from the network if there's a precache miss.\n       * @return {module:workbox-routing~handlerCallback}\n       */\n\n\n      createHandlerBoundToURL(url, fallbackToNetwork = true) {\n        const cacheKey = this.getCacheKeyForURL(url);\n\n        if (!cacheKey) {\n          throw new WorkboxError_js.WorkboxError('non-precached-url', {\n            url\n          });\n        }\n\n        const handler = this.createHandler(fallbackToNetwork);\n        const request = new Request(url);\n        return () => handler({\n          request\n        });\n      }\n\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    let precacheController;\n    /**\n     * @return {PrecacheController}\n     * @private\n     */\n\n    const getOrCreatePrecacheController = () => {\n      if (!precacheController) {\n        precacheController = new PrecacheController();\n      }\n\n      return precacheController;\n    };\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Removes any URL search parameters that should be ignored.\n     *\n     * @param {URL} urlObject The original URL.\n     * @param {Array<RegExp>} ignoreURLParametersMatching RegExps to test against\n     * each search parameter name. Matches mean that the search parameter should be\n     * ignored.\n     * @return {URL} The URL with any ignored search parameters removed.\n     *\n     * @private\n     * @memberof module:workbox-precaching\n     */\n\n    function removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching = []) {\n      // Convert the iterable into an array at the start of the loop to make sure\n      // deletion doesn't mess up iteration.\n      for (const paramName of [...urlObject.searchParams.keys()]) {\n        if (ignoreURLParametersMatching.some(regExp => regExp.test(paramName))) {\n          urlObject.searchParams.delete(paramName);\n        }\n      }\n\n      return urlObject;\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Generator function that yields possible variations on the original URL to\n     * check, one at a time.\n     *\n     * @param {string} url\n     * @param {Object} options\n     *\n     * @private\n     * @memberof module:workbox-precaching\n     */\n\n    function* generateURLVariations(url, {\n      ignoreURLParametersMatching,\n      directoryIndex,\n      cleanURLs,\n      urlManipulation\n    } = {}) {\n      const urlObject = new URL(url, location.href);\n      urlObject.hash = '';\n      yield urlObject.href;\n      const urlWithoutIgnoredParams = removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching);\n      yield urlWithoutIgnoredParams.href;\n\n      if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith('/')) {\n        const directoryURL = new URL(urlWithoutIgnoredParams.href);\n        directoryURL.pathname += directoryIndex;\n        yield directoryURL.href;\n      }\n\n      if (cleanURLs) {\n        const cleanURL = new URL(urlWithoutIgnoredParams.href);\n        cleanURL.pathname += '.html';\n        yield cleanURL.href;\n      }\n\n      if (urlManipulation) {\n        const additionalURLs = urlManipulation({\n          url: urlObject\n        });\n\n        for (const urlToAttempt of additionalURLs) {\n          yield urlToAttempt.href;\n        }\n      }\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * This function will take the request URL and manipulate it based on the\n     * configuration options.\n     *\n     * @param {string} url\n     * @param {Object} options\n     * @return {string} Returns the URL in the cache that matches the request,\n     * if possible.\n     *\n     * @private\n     */\n\n    const getCacheKeyForURL = (url, options) => {\n      const precacheController = getOrCreatePrecacheController();\n      const urlsToCacheKeys = precacheController.getURLsToCacheKeys();\n\n      for (const possibleURL of generateURLVariations(url, options)) {\n        const possibleCacheKey = urlsToCacheKeys.get(possibleURL);\n\n        if (possibleCacheKey) {\n          return possibleCacheKey;\n        }\n      }\n    };\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Adds a `fetch` listener to the service worker that will\n     * respond to\n     * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}\n     * with precached assets.\n     *\n     * Requests for assets that aren't precached, the `FetchEvent` will not be\n     * responded to, allowing the event to fall through to other `fetch` event\n     * listeners.\n     *\n     * NOTE: when called more than once this method will replace the previously set\n     * configuration options. Calling it more than once is not recommended outside\n     * of tests.\n     *\n     * @private\n     * @param {Object} [options]\n     * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\n     * check cache entries for a URLs ending with '/' to see if there is a hit when\n     * appending the `directoryIndex` value.\n     * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/]] An\n     * array of regex's to remove search params when looking for a cache match.\n     * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will\n     * check the cache for the URL with a `.html` added to the end of the end.\n     * @param {workbox.precaching~urlManipulation} [options.urlManipulation]\n     * This is a function that should take a URL and return an array of\n     * alternative URLs that should be checked for precache matches.\n     */\n\n    const addFetchListener = ({\n      ignoreURLParametersMatching = [/^utm_/],\n      directoryIndex = 'index.html',\n      cleanURLs = true,\n      urlManipulation\n    } = {}) => {\n      const cacheName = cacheNames_js.cacheNames.getPrecacheName(); // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n\n      self.addEventListener('fetch', event => {\n        const precachedURL = getCacheKeyForURL(event.request.url, {\n          cleanURLs,\n          directoryIndex,\n          ignoreURLParametersMatching,\n          urlManipulation\n        });\n\n        if (!precachedURL) {\n          {\n            logger_js.logger.debug(`Precaching did not find a match for ` + getFriendlyURL_js.getFriendlyURL(event.request.url));\n          }\n\n          return;\n        }\n\n        let responsePromise = self.caches.open(cacheName).then(cache => {\n          return cache.match(precachedURL);\n        }).then(cachedResponse => {\n          if (cachedResponse) {\n            return cachedResponse;\n          } // Fall back to the network if we don't have a cached response\n          // (perhaps due to manual cache cleanup).\n\n\n          {\n            logger_js.logger.warn(`The precached response for ` + `${getFriendlyURL_js.getFriendlyURL(precachedURL)} in ${cacheName} was not found. ` + `Falling back to the network instead.`);\n          }\n\n          return fetch(precachedURL);\n        });\n\n        {\n          responsePromise = responsePromise.then(response => {\n            // Workbox is going to handle the route.\n            // print the routing details to the console.\n            logger_js.logger.groupCollapsed(`Precaching is responding to: ` + getFriendlyURL_js.getFriendlyURL(event.request.url));\n            logger_js.logger.log(`Serving the precached url: ${precachedURL}`);\n            logger_js.logger.groupCollapsed(`View request details here.`);\n            logger_js.logger.log(event.request);\n            logger_js.logger.groupEnd();\n            logger_js.logger.groupCollapsed(`View response details here.`);\n            logger_js.logger.log(response);\n            logger_js.logger.groupEnd();\n            logger_js.logger.groupEnd();\n            return response;\n          });\n        }\n\n        event.respondWith(responsePromise);\n      });\n    };\n\n    /*\n      Copyright 2019 Google LLC\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    let listenerAdded = false;\n    /**\n     * Add a `fetch` listener to the service worker that will\n     * respond to\n     * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}\n     * with precached assets.\n     *\n     * Requests for assets that aren't precached, the `FetchEvent` will not be\n     * responded to, allowing the event to fall through to other `fetch` event\n     * listeners.\n     *\n     * @param {Object} [options]\n     * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\n     * check cache entries for a URLs ending with '/' to see if there is a hit when\n     * appending the `directoryIndex` value.\n     * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/]] An\n     * array of regex's to remove search params when looking for a cache match.\n     * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will\n     * check the cache for the URL with a `.html` added to the end of the end.\n     * @param {module:workbox-precaching~urlManipulation} [options.urlManipulation]\n     * This is a function that should take a URL and return an array of\n     * alternative URLs that should be checked for precache matches.\n     *\n     * @memberof module:workbox-precaching\n     */\n\n    function addRoute(options) {\n      if (!listenerAdded) {\n        addFetchListener(options);\n        listenerAdded = true;\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const SUBSTRING_TO_FIND = '-precache-';\n    /**\n     * Cleans up incompatible precaches that were created by older versions of\n     * Workbox, by a service worker registered under the current scope.\n     *\n     * This is meant to be called as part of the `activate` event.\n     *\n     * This should be safe to use as long as you don't include `substringToFind`\n     * (defaulting to `-precache-`) in your non-precache cache names.\n     *\n     * @param {string} currentPrecacheName The cache name currently in use for\n     * precaching. This cache won't be deleted.\n     * @param {string} [substringToFind='-precache-'] Cache names which include this\n     * substring will be deleted (excluding `currentPrecacheName`).\n     * @return {Array<string>} A list of all the cache names that were deleted.\n     *\n     * @private\n     * @memberof module:workbox-precaching\n     */\n\n    const deleteOutdatedCaches = async (currentPrecacheName, substringToFind = SUBSTRING_TO_FIND) => {\n      const cacheNames = await self.caches.keys();\n      const cacheNamesToDelete = cacheNames.filter(cacheName => {\n        return cacheName.includes(substringToFind) && cacheName.includes(self.registration.scope) && cacheName !== currentPrecacheName;\n      });\n      await Promise.all(cacheNamesToDelete.map(cacheName => self.caches.delete(cacheName)));\n      return cacheNamesToDelete;\n    };\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Adds an `activate` event listener which will clean up incompatible\n     * precaches that were created by older versions of Workbox.\n     *\n     * @memberof module:workbox-precaching\n     */\n\n    function cleanupOutdatedCaches() {\n      // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n      self.addEventListener('activate', event => {\n        const cacheName = cacheNames_js.cacheNames.getPrecacheName();\n        event.waitUntil(deleteOutdatedCaches(cacheName).then(cachesDeleted => {\n          {\n            if (cachesDeleted.length > 0) {\n              logger_js.logger.log(`The following out-of-date precaches were cleaned up ` + `automatically:`, cachesDeleted);\n            }\n          }\n        }));\n      });\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Helper function that calls\n     * {@link PrecacheController#createHandler} on the default\n     * {@link PrecacheController} instance.\n     *\n     * If you are creating your own {@link PrecacheController}, then call the\n     * {@link PrecacheController#createHandler} on that instance,\n     * instead of using this function.\n     *\n     * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the\n     * response from the network if there's a precache miss.\n     * @return {module:workbox-routing~handlerCallback}\n     *\n     * @memberof module:workbox-precaching\n     */\n\n    function createHandler(fallbackToNetwork = true) {\n      const precacheController = getOrCreatePrecacheController();\n      return precacheController.createHandler(fallbackToNetwork);\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Helper function that calls\n     * {@link PrecacheController#createHandlerBoundToURL} on the default\n     * {@link PrecacheController} instance.\n     *\n     * If you are creating your own {@link PrecacheController}, then call the\n     * {@link PrecacheController#createHandlerBoundToURL} on that instance,\n     * instead of using this function.\n     *\n     * @param {string} url The precached URL which will be used to lookup the\n     * `Response`.\n     * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the\n     * response from the network if there's a precache miss.\n     * @return {module:workbox-routing~handlerCallback}\n     *\n     * @memberof module:workbox-precaching\n     */\n\n    function createHandlerBoundToURL(url) {\n      const precacheController = getOrCreatePrecacheController();\n      return precacheController.createHandlerBoundToURL(url);\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Takes in a URL, and returns the corresponding URL that could be used to\n     * lookup the entry in the precache.\n     *\n     * If a relative URL is provided, the location of the service worker file will\n     * be used as the base.\n     *\n     * For precached entries without revision information, the cache key will be the\n     * same as the original URL.\n     *\n     * For precached entries with revision information, the cache key will be the\n     * original URL with the addition of a query parameter used for keeping track of\n     * the revision info.\n     *\n     * @param {string} url The URL whose cache key to look up.\n     * @return {string} The cache key that corresponds to that URL.\n     *\n     * @memberof module:workbox-precaching\n     */\n\n    function getCacheKeyForURL$1(url) {\n      const precacheController = getOrCreatePrecacheController();\n      return precacheController.getCacheKeyForURL(url);\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Helper function that calls\n     * {@link PrecacheController#matchPrecache} on the default\n     * {@link PrecacheController} instance.\n     *\n     * If you are creating your own {@link PrecacheController}, then call\n     * {@link PrecacheController#matchPrecache} on that instance,\n     * instead of using this function.\n     *\n     * @param {string|Request} request The key (without revisioning parameters)\n     * to look up in the precache.\n     * @return {Promise<Response|undefined>}\n     *\n     * @memberof module:workbox-precaching\n     */\n\n    function matchPrecache(request) {\n      const precacheController = getOrCreatePrecacheController();\n      return precacheController.matchPrecache(request);\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n\n    const installListener = event => {\n      const precacheController = getOrCreatePrecacheController();\n      const plugins = precachePlugins.get();\n      event.waitUntil(precacheController.install({\n        event,\n        plugins\n      }).catch(error => {\n        {\n          logger_js.logger.error(`Service worker installation failed. It will ` + `be retried automatically during the next navigation.`);\n        } // Re-throw the error to ensure installation fails.\n\n\n        throw error;\n      }));\n    };\n\n    const activateListener = event => {\n      const precacheController = getOrCreatePrecacheController();\n      event.waitUntil(precacheController.activate());\n    };\n    /**\n     * Adds items to the precache list, removing any duplicates and\n     * stores the files in the\n     * [\"precache cache\"]{@link module:workbox-core.cacheNames} when the service\n     * worker installs.\n     *\n     * This method can be called multiple times.\n     *\n     * Please note: This method **will not** serve any of the cached files for you.\n     * It only precaches files. To respond to a network request you call\n     * [addRoute()]{@link module:workbox-precaching.addRoute}.\n     *\n     * If you have a single array of files to precache, you can just call\n     * [precacheAndRoute()]{@link module:workbox-precaching.precacheAndRoute}.\n     *\n     * @param {Array<Object|string>} [entries=[]] Array of entries to precache.\n     *\n     * @memberof module:workbox-precaching\n     */\n\n\n    function precache(entries) {\n      const precacheController = getOrCreatePrecacheController();\n      precacheController.addToCacheList(entries);\n\n      if (entries.length > 0) {\n        // NOTE: these listeners will only be added once (even if the `precache()`\n        // method is called multiple times) because event listeners are implemented\n        // as a set, where each listener must be unique.\n        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n        self.addEventListener('install', installListener);\n        self.addEventListener('activate', activateListener);\n      }\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * This method will add entries to the precache list and add a route to\n     * respond to fetch events.\n     *\n     * This is a convenience method that will call\n     * [precache()]{@link module:workbox-precaching.precache} and\n     * [addRoute()]{@link module:workbox-precaching.addRoute} in a single call.\n     *\n     * @param {Array<Object|string>} entries Array of entries to precache.\n     * @param {Object} [options] See\n     * [addRoute() options]{@link module:workbox-precaching.addRoute}.\n     *\n     * @memberof module:workbox-precaching\n     */\n\n    function precacheAndRoute(entries, options) {\n      precache(entries);\n      addRoute(options);\n    }\n\n    exports.PrecacheController = PrecacheController;\n    exports.addPlugins = addPlugins;\n    exports.addRoute = addRoute;\n    exports.cleanupOutdatedCaches = cleanupOutdatedCaches;\n    exports.createHandler = createHandler;\n    exports.createHandlerBoundToURL = createHandlerBoundToURL;\n    exports.getCacheKeyForURL = getCacheKeyForURL$1;\n    exports.matchPrecache = matchPrecache;\n    exports.precache = precache;\n    exports.precacheAndRoute = precacheAndRoute;\n\n    return exports;\n\n}({}, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core));\n//# sourceMappingURL=workbox-precaching.dev.js.map"},{"path":"/workbox-v5.1.3/workbox-precaching.prod.js","content":"this.workbox=this.workbox||{},this.workbox.precaching=function(t,e,n,i,s,c){\"use strict\";try{self[\"workbox:precaching:5.1.3\"]&&_()}catch(t){}const r=[],o={get:()=>r,add(t){r.push(...t)}};function a(t){if(!t)throw new s.WorkboxError(\"add-to-cache-list-unexpected-type\",{entry:t});if(\"string\"==typeof t){const e=new URL(t,location.href);return{cacheKey:e.href,url:e.href}}const{revision:e,url:n}=t;if(!n)throw new s.WorkboxError(\"add-to-cache-list-unexpected-type\",{entry:t});if(!e){const t=new URL(n,location.href);return{cacheKey:t.href,url:t.href}}const i=new URL(n,location.href),c=new URL(n,location.href);return i.searchParams.set(\"__WB_REVISION__\",e),{cacheKey:i.href,url:c.href}}class h{constructor(t){this.t=e.cacheNames.getPrecacheName(t),this.i=new Map,this.s=new Map,this.o=new Map}addToCacheList(t){const e=[];for(const n of t){\"string\"==typeof n?e.push(n):n&&void 0===n.revision&&e.push(n.url);const{cacheKey:t,url:i}=a(n),c=\"string\"!=typeof n&&n.revision?\"reload\":\"default\";if(this.i.has(i)&&this.i.get(i)!==t)throw new s.WorkboxError(\"add-to-cache-list-conflicting-entries\",{firstEntry:this.i.get(i),secondEntry:t});if(\"string\"!=typeof n&&n.integrity){if(this.o.has(t)&&this.o.get(t)!==n.integrity)throw new s.WorkboxError(\"add-to-cache-list-conflicting-integrities\",{url:i});this.o.set(t,n.integrity)}if(this.i.set(i,t),this.s.set(i,c),e.length>0){const t=\"Workbox is precaching URLs without revision \"+`info: ${e.join(\", \")}\\nThis is generally NOT safe. `+\"Learn more at https://bit.ly/wb-precache\";console.warn(t)}}}async install({event:t,plugins:e}={}){const n=[],i=[],s=await self.caches.open(this.t),c=await s.keys(),r=new Set(c.map(t=>t.url));for(const[t,e]of this.i)r.has(e)?i.push(t):n.push({cacheKey:e,url:t});const o=n.map(({cacheKey:n,url:i})=>{const s=this.o.get(n),c=this.s.get(i);return this.h({cacheKey:n,cacheMode:c,event:t,integrity:s,plugins:e,url:i})});return await Promise.all(o),{updatedURLs:n.map(t=>t.url),notUpdatedURLs:i}}async activate(){const t=await self.caches.open(this.t),e=await t.keys(),n=new Set(this.i.values()),i=[];for(const s of e)n.has(s.url)||(await t.delete(s),i.push(s.url));return{deletedURLs:i}}async h({cacheKey:t,url:e,cacheMode:r,event:o,plugins:a,integrity:h}){const u=new Request(e,{integrity:h,cache:r,credentials:\"same-origin\"});let l,f=await i.fetchWrapper.fetch({event:o,plugins:a,request:u});for(const t of a||[])\"cacheWillUpdate\"in t&&(l=t);if(!(l?await l.cacheWillUpdate({event:o,request:u,response:f}):f.status<400))throw new s.WorkboxError(\"bad-precaching-response\",{url:e,status:f.status});f.redirected&&(f=await c.copyResponse(f)),await n.cacheWrapper.put({event:o,plugins:a,response:f,request:t===e?u:new Request(t),cacheName:this.t,matchOptions:{ignoreSearch:!0}})}getURLsToCacheKeys(){return this.i}getCachedURLs(){return[...this.i.keys()]}getCacheKeyForURL(t){const e=new URL(t,location.href);return this.i.get(e.href)}async matchPrecache(t){const e=t instanceof Request?t.url:t,n=this.getCacheKeyForURL(e);if(n){return(await self.caches.open(this.t)).match(n)}}createHandler(t=!0){return async({request:e})=>{try{const t=await this.matchPrecache(e);if(t)return t;throw new s.WorkboxError(\"missing-precache-entry\",{cacheName:this.t,url:e instanceof Request?e.url:e})}catch(n){if(t)return fetch(e);throw n}}}createHandlerBoundToURL(t,e=!0){if(!this.getCacheKeyForURL(t))throw new s.WorkboxError(\"non-precached-url\",{url:t});const n=this.createHandler(e),i=new Request(t);return()=>n({request:i})}}let u;const l=()=>(u||(u=new h),u);const f=(t,e)=>{const n=l().getURLsToCacheKeys();for(const i of function*(t,{ignoreURLParametersMatching:e,directoryIndex:n,cleanURLs:i,urlManipulation:s}={}){const c=new URL(t,location.href);c.hash=\"\",yield c.href;const r=function(t,e=[]){for(const n of[...t.searchParams.keys()])e.some(t=>t.test(n))&&t.searchParams.delete(n);return t}(c,e);if(yield r.href,n&&r.pathname.endsWith(\"/\")){const t=new URL(r.href);t.pathname+=n,yield t.href}if(i){const t=new URL(r.href);t.pathname+=\".html\",yield t.href}if(s){const t=s({url:c});for(const e of t)yield e.href}}(t,e)){const t=n.get(i);if(t)return t}};let w=!1;function d(t){w||((({ignoreURLParametersMatching:t=[/^utm_/],directoryIndex:n=\"index.html\",cleanURLs:i=!0,urlManipulation:s}={})=>{const c=e.cacheNames.getPrecacheName();self.addEventListener(\"fetch\",e=>{const r=f(e.request.url,{cleanURLs:i,directoryIndex:n,ignoreURLParametersMatching:t,urlManipulation:s});if(!r)return;let o=self.caches.open(c).then(t=>t.match(r)).then(t=>t||fetch(r));e.respondWith(o)})})(t),w=!0)}const y=t=>{const e=l(),n=o.get();t.waitUntil(e.install({event:t,plugins:n}).catch(t=>{throw t}))},p=t=>{const e=l();t.waitUntil(e.activate())};function g(t){l().addToCacheList(t),t.length>0&&(self.addEventListener(\"install\",y),self.addEventListener(\"activate\",p))}return t.PrecacheController=h,t.addPlugins=function(t){o.add(t)},t.addRoute=d,t.cleanupOutdatedCaches=function(){self.addEventListener(\"activate\",t=>{const n=e.cacheNames.getPrecacheName();t.waitUntil((async(t,e=\"-precache-\")=>{const n=(await self.caches.keys()).filter(n=>n.includes(e)&&n.includes(self.registration.scope)&&n!==t);return await Promise.all(n.map(t=>self.caches.delete(t))),n})(n).then(t=>{}))})},t.createHandler=function(t=!0){return l().createHandler(t)},t.createHandlerBoundToURL=function(t){return l().createHandlerBoundToURL(t)},t.getCacheKeyForURL=function(t){return l().getCacheKeyForURL(t)},t.matchPrecache=function(t){return l().matchPrecache(t)},t.precache=g,t.precacheAndRoute=function(t,e){g(t),d(e)},t}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core);\n//# sourceMappingURL=workbox-precaching.prod.js.map"},{"path":"/workbox-v5.1.3/workbox-range-requests.dev.js","content":"this.workbox = this.workbox || {};\nthis.workbox.rangeRequests = (function (exports, WorkboxError_js, assert_js, logger_js) {\n    'use strict';\n\n    try {\n      self['workbox:range-requests:5.1.3'] && _();\n    } catch (e) {}\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * @param {Blob} blob A source blob.\n     * @param {number} [start] The offset to use as the start of the\n     * slice.\n     * @param {number} [end] The offset to use as the end of the slice.\n     * @return {Object} An object with `start` and `end` properties, reflecting\n     * the effective boundaries to use given the size of the blob.\n     *\n     * @private\n     */\n\n    function calculateEffectiveBoundaries(blob, start, end) {\n      {\n        assert_js.assert.isInstance(blob, Blob, {\n          moduleName: 'workbox-range-requests',\n          funcName: 'calculateEffectiveBoundaries',\n          paramName: 'blob'\n        });\n      }\n\n      const blobSize = blob.size;\n\n      if (end && end > blobSize || start && start < 0) {\n        throw new WorkboxError_js.WorkboxError('range-not-satisfiable', {\n          size: blobSize,\n          end,\n          start\n        });\n      }\n\n      let effectiveStart;\n      let effectiveEnd;\n\n      if (start !== undefined && end !== undefined) {\n        effectiveStart = start; // Range values are inclusive, so add 1 to the value.\n\n        effectiveEnd = end + 1;\n      } else if (start !== undefined && end === undefined) {\n        effectiveStart = start;\n        effectiveEnd = blobSize;\n      } else if (end !== undefined && start === undefined) {\n        effectiveStart = blobSize - end;\n        effectiveEnd = blobSize;\n      }\n\n      return {\n        start: effectiveStart,\n        end: effectiveEnd\n      };\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * @param {string} rangeHeader A Range: header value.\n     * @return {Object} An object with `start` and `end` properties, reflecting\n     * the parsed value of the Range: header. If either the `start` or `end` are\n     * omitted, then `null` will be returned.\n     *\n     * @private\n     */\n\n    function parseRangeHeader(rangeHeader) {\n      {\n        assert_js.assert.isType(rangeHeader, 'string', {\n          moduleName: 'workbox-range-requests',\n          funcName: 'parseRangeHeader',\n          paramName: 'rangeHeader'\n        });\n      }\n\n      const normalizedRangeHeader = rangeHeader.trim().toLowerCase();\n\n      if (!normalizedRangeHeader.startsWith('bytes=')) {\n        throw new WorkboxError_js.WorkboxError('unit-must-be-bytes', {\n          normalizedRangeHeader\n        });\n      } // Specifying multiple ranges separate by commas is valid syntax, but this\n      // library only attempts to handle a single, contiguous sequence of bytes.\n      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range#Syntax\n\n\n      if (normalizedRangeHeader.includes(',')) {\n        throw new WorkboxError_js.WorkboxError('single-range-only', {\n          normalizedRangeHeader\n        });\n      }\n\n      const rangeParts = /(\\d*)-(\\d*)/.exec(normalizedRangeHeader); // We need either at least one of the start or end values.\n\n      if (!rangeParts || !(rangeParts[1] || rangeParts[2])) {\n        throw new WorkboxError_js.WorkboxError('invalid-range-values', {\n          normalizedRangeHeader\n        });\n      }\n\n      return {\n        start: rangeParts[1] === '' ? undefined : Number(rangeParts[1]),\n        end: rangeParts[2] === '' ? undefined : Number(rangeParts[2])\n      };\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Given a `Request` and `Response` objects as input, this will return a\n     * promise for a new `Response`.\n     *\n     * If the original `Response` already contains partial content (i.e. it has\n     * a status of 206), then this assumes it already fulfills the `Range:`\n     * requirements, and will return it as-is.\n     *\n     * @param {Request} request A request, which should contain a Range:\n     * header.\n     * @param {Response} originalResponse A response.\n     * @return {Promise<Response>} Either a `206 Partial Content` response, with\n     * the response body set to the slice of content specified by the request's\n     * `Range:` header, or a `416 Range Not Satisfiable` response if the\n     * conditions of the `Range:` header can't be met.\n     *\n     * @memberof module:workbox-range-requests\n     */\n\n    async function createPartialResponse(request, originalResponse) {\n      try {\n        if (\"dev\" !== 'production') {\n          assert_js.assert.isInstance(request, Request, {\n            moduleName: 'workbox-range-requests',\n            funcName: 'createPartialResponse',\n            paramName: 'request'\n          });\n          assert_js.assert.isInstance(originalResponse, Response, {\n            moduleName: 'workbox-range-requests',\n            funcName: 'createPartialResponse',\n            paramName: 'originalResponse'\n          });\n        }\n\n        if (originalResponse.status === 206) {\n          // If we already have a 206, then just pass it through as-is;\n          // see https://github.com/GoogleChrome/workbox/issues/1720\n          return originalResponse;\n        }\n\n        const rangeHeader = request.headers.get('range');\n\n        if (!rangeHeader) {\n          throw new WorkboxError_js.WorkboxError('no-range-header');\n        }\n\n        const boundaries = parseRangeHeader(rangeHeader);\n        const originalBlob = await originalResponse.blob();\n        const effectiveBoundaries = calculateEffectiveBoundaries(originalBlob, boundaries.start, boundaries.end);\n        const slicedBlob = originalBlob.slice(effectiveBoundaries.start, effectiveBoundaries.end);\n        const slicedBlobSize = slicedBlob.size;\n        const slicedResponse = new Response(slicedBlob, {\n          // Status code 206 is for a Partial Content response.\n          // See https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/206\n          status: 206,\n          statusText: 'Partial Content',\n          headers: originalResponse.headers\n        });\n        slicedResponse.headers.set('Content-Length', String(slicedBlobSize));\n        slicedResponse.headers.set('Content-Range', `bytes ${effectiveBoundaries.start}-${effectiveBoundaries.end - 1}/` + originalBlob.size);\n        return slicedResponse;\n      } catch (error) {\n        {\n          logger_js.logger.warn(`Unable to construct a partial response; returning a ` + `416 Range Not Satisfiable response instead.`);\n          logger_js.logger.groupCollapsed(`View details here.`);\n          logger_js.logger.log(error);\n          logger_js.logger.log(request);\n          logger_js.logger.log(originalResponse);\n          logger_js.logger.groupEnd();\n        }\n\n        return new Response('', {\n          status: 416,\n          statusText: 'Range Not Satisfiable'\n        });\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * The range request plugin makes it easy for a request with a 'Range' header to\n     * be fulfilled by a cached response.\n     *\n     * It does this by intercepting the `cachedResponseWillBeUsed` plugin callback\n     * and returning the appropriate subset of the cached response body.\n     *\n     * @memberof module:workbox-range-requests\n     */\n\n    class RangeRequestsPlugin {\n      constructor() {\n        /**\n         * @param {Object} options\n         * @param {Request} options.request The original request, which may or may not\n         * contain a Range: header.\n         * @param {Response} options.cachedResponse The complete cached response.\n         * @return {Promise<Response>} If request contains a 'Range' header, then a\n         * new response with status 206 whose body is a subset of `cachedResponse` is\n         * returned. Otherwise, `cachedResponse` is returned as-is.\n         *\n         * @private\n         */\n        this.cachedResponseWillBeUsed = async ({\n          request,\n          cachedResponse\n        }) => {\n          // Only return a sliced response if there's something valid in the cache,\n          // and there's a Range: header in the request.\n          if (cachedResponse && request.headers.has('range')) {\n            return await createPartialResponse(request, cachedResponse);\n          } // If there was no Range: header, or if cachedResponse wasn't valid, just\n          // pass it through as-is.\n\n\n          return cachedResponse;\n        };\n      }\n\n    }\n\n    exports.RangeRequestsPlugin = RangeRequestsPlugin;\n    exports.createPartialResponse = createPartialResponse;\n\n    return exports;\n\n}({}, workbox.core._private, workbox.core._private, workbox.core._private));\n//# sourceMappingURL=workbox-range-requests.dev.js.map"},{"path":"/workbox-v5.1.3/workbox-range-requests.prod.js","content":"this.workbox=this.workbox||{},this.workbox.rangeRequests=function(t,e,n){\"use strict\";try{self[\"workbox:range-requests:5.1.3\"]&&_()}catch(t){}async function r(t,n){try{if(206===n.status)return n;const r=t.headers.get(\"range\");if(!r)throw new e.WorkboxError(\"no-range-header\");const s=function(t){const n=t.trim().toLowerCase();if(!n.startsWith(\"bytes=\"))throw new e.WorkboxError(\"unit-must-be-bytes\",{normalizedRangeHeader:n});if(n.includes(\",\"))throw new e.WorkboxError(\"single-range-only\",{normalizedRangeHeader:n});const r=/(\\d*)-(\\d*)/.exec(n);if(!r||!r[1]&&!r[2])throw new e.WorkboxError(\"invalid-range-values\",{normalizedRangeHeader:n});return{start:\"\"===r[1]?void 0:Number(r[1]),end:\"\"===r[2]?void 0:Number(r[2])}}(r),a=await n.blob(),o=function(t,n,r){const s=t.size;if(r&&r>s||n&&n<0)throw new e.WorkboxError(\"range-not-satisfiable\",{size:s,end:r,start:n});let a,o;return void 0!==n&&void 0!==r?(a=n,o=r+1):void 0!==n&&void 0===r?(a=n,o=s):void 0!==r&&void 0===n&&(a=s-r,o=s),{start:a,end:o}}(a,s.start,s.end),i=a.slice(o.start,o.end),d=i.size,u=new Response(i,{status:206,statusText:\"Partial Content\",headers:n.headers});return u.headers.set(\"Content-Length\",String(d)),u.headers.set(\"Content-Range\",`bytes ${o.start}-${o.end-1}/`+a.size),u}catch(t){return new Response(\"\",{status:416,statusText:\"Range Not Satisfiable\"})}}return t.RangeRequestsPlugin=class{constructor(){this.cachedResponseWillBeUsed=async({request:t,cachedResponse:e})=>e&&t.headers.has(\"range\")?await r(t,e):e}},t.createPartialResponse=r,t}({},workbox.core._private,workbox.core._private);\n//# sourceMappingURL=workbox-range-requests.prod.js.map"},{"path":"/workbox-v5.1.3/workbox-routing.dev.js","content":"this.workbox = this.workbox || {};\nthis.workbox.routing = (function (exports, assert_js, logger_js, WorkboxError_js, getFriendlyURL_js) {\n    'use strict';\n\n    try {\n      self['workbox:routing:5.1.3'] && _();\n    } catch (e) {}\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * The default HTTP method, 'GET', used when there's no specific method\n     * configured for a route.\n     *\n     * @type {string}\n     *\n     * @private\n     */\n\n    const defaultMethod = 'GET';\n    /**\n     * The list of valid HTTP methods associated with requests that could be routed.\n     *\n     * @type {Array<string>}\n     *\n     * @private\n     */\n\n    const validMethods = ['DELETE', 'GET', 'HEAD', 'PATCH', 'POST', 'PUT'];\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * @param {function()|Object} handler Either a function, or an object with a\n     * 'handle' method.\n     * @return {Object} An object with a handle method.\n     *\n     * @private\n     */\n\n    const normalizeHandler = handler => {\n      if (handler && typeof handler === 'object') {\n        {\n          assert_js.assert.hasMethod(handler, 'handle', {\n            moduleName: 'workbox-routing',\n            className: 'Route',\n            funcName: 'constructor',\n            paramName: 'handler'\n          });\n        }\n\n        return handler;\n      } else {\n        {\n          assert_js.assert.isType(handler, 'function', {\n            moduleName: 'workbox-routing',\n            className: 'Route',\n            funcName: 'constructor',\n            paramName: 'handler'\n          });\n        }\n\n        return {\n          handle: handler\n        };\n      }\n    };\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * A `Route` consists of a pair of callback functions, \"match\" and \"handler\".\n     * The \"match\" callback determine if a route should be used to \"handle\" a\n     * request by returning a non-falsy value if it can. The \"handler\" callback\n     * is called when there is a match and should return a Promise that resolves\n     * to a `Response`.\n     *\n     * @memberof module:workbox-routing\n     */\n\n    class Route {\n      /**\n       * Constructor for Route class.\n       *\n       * @param {module:workbox-routing~matchCallback} match\n       * A callback function that determines whether the route matches a given\n       * `fetch` event by returning a non-falsy value.\n       * @param {module:workbox-routing~handlerCallback} handler A callback\n       * function that returns a Promise resolving to a Response.\n       * @param {string} [method='GET'] The HTTP method to match the Route\n       * against.\n       */\n      constructor(match, handler, method = defaultMethod) {\n        {\n          assert_js.assert.isType(match, 'function', {\n            moduleName: 'workbox-routing',\n            className: 'Route',\n            funcName: 'constructor',\n            paramName: 'match'\n          });\n\n          if (method) {\n            assert_js.assert.isOneOf(method, validMethods, {\n              paramName: 'method'\n            });\n          }\n        } // These values are referenced directly by Router so cannot be\n        // altered by minificaton.\n\n\n        this.handler = normalizeHandler(handler);\n        this.match = match;\n        this.method = method;\n      }\n\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * NavigationRoute makes it easy to create a\n     * [Route]{@link module:workbox-routing.Route} that matches for browser\n     * [navigation requests]{@link https://developers.google.com/web/fundamentals/primers/service-workers/high-performance-loading#first_what_are_navigation_requests}.\n     *\n     * It will only match incoming Requests whose\n     * [`mode`]{@link https://fetch.spec.whatwg.org/#concept-request-mode}\n     * is set to `navigate`.\n     *\n     * You can optionally only apply this route to a subset of navigation requests\n     * by using one or both of the `denylist` and `allowlist` parameters.\n     *\n     * @memberof module:workbox-routing\n     * @extends module:workbox-routing.Route\n     */\n\n    class NavigationRoute extends Route {\n      /**\n       * If both `denylist` and `allowlist` are provided, the `denylist` will\n       * take precedence and the request will not match this route.\n       *\n       * The regular expressions in `allowlist` and `denylist`\n       * are matched against the concatenated\n       * [`pathname`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/pathname}\n       * and [`search`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search}\n       * portions of the requested URL.\n       *\n       * @param {module:workbox-routing~handlerCallback} handler A callback\n       * function that returns a Promise resulting in a Response.\n       * @param {Object} options\n       * @param {Array<RegExp>} [options.denylist] If any of these patterns match,\n       * the route will not handle the request (even if a allowlist RegExp matches).\n       * @param {Array<RegExp>} [options.allowlist=[/./]] If any of these patterns\n       * match the URL's pathname and search parameter, the route will handle the\n       * request (assuming the denylist doesn't match).\n       */\n      constructor(handler, {\n        allowlist = [/./],\n        denylist = []\n      } = {}) {\n        {\n          assert_js.assert.isArrayOfClass(allowlist, RegExp, {\n            moduleName: 'workbox-routing',\n            className: 'NavigationRoute',\n            funcName: 'constructor',\n            paramName: 'options.allowlist'\n          });\n          assert_js.assert.isArrayOfClass(denylist, RegExp, {\n            moduleName: 'workbox-routing',\n            className: 'NavigationRoute',\n            funcName: 'constructor',\n            paramName: 'options.denylist'\n          });\n        }\n\n        super(options => this._match(options), handler);\n        this._allowlist = allowlist;\n        this._denylist = denylist;\n      }\n      /**\n       * Routes match handler.\n       *\n       * @param {Object} options\n       * @param {URL} options.url\n       * @param {Request} options.request\n       * @return {boolean}\n       *\n       * @private\n       */\n\n\n      _match({\n        url,\n        request\n      }) {\n        if (request && request.mode !== 'navigate') {\n          return false;\n        }\n\n        const pathnameAndSearch = url.pathname + url.search;\n\n        for (const regExp of this._denylist) {\n          if (regExp.test(pathnameAndSearch)) {\n            {\n              logger_js.logger.log(`The navigation route ${pathnameAndSearch} is not ` + `being used, since the URL matches this denylist pattern: ` + `${regExp}`);\n            }\n\n            return false;\n          }\n        }\n\n        if (this._allowlist.some(regExp => regExp.test(pathnameAndSearch))) {\n          {\n            logger_js.logger.debug(`The navigation route ${pathnameAndSearch} ` + `is being used.`);\n          }\n\n          return true;\n        }\n\n        {\n          logger_js.logger.log(`The navigation route ${pathnameAndSearch} is not ` + `being used, since the URL being navigated to doesn't ` + `match the allowlist.`);\n        }\n\n        return false;\n      }\n\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * RegExpRoute makes it easy to create a regular expression based\n     * [Route]{@link module:workbox-routing.Route}.\n     *\n     * For same-origin requests the RegExp only needs to match part of the URL. For\n     * requests against third-party servers, you must define a RegExp that matches\n     * the start of the URL.\n     *\n     * [See the module docs for info.]{@link https://developers.google.com/web/tools/workbox/modules/workbox-routing}\n     *\n     * @memberof module:workbox-routing\n     * @extends module:workbox-routing.Route\n     */\n\n    class RegExpRoute extends Route {\n      /**\n       * If the regular expression contains\n       * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},\n       * the captured values will be passed to the\n       * [handler's]{@link module:workbox-routing~handlerCallback} `params`\n       * argument.\n       *\n       * @param {RegExp} regExp The regular expression to match against URLs.\n       * @param {module:workbox-routing~handlerCallback} handler A callback\n       * function that returns a Promise resulting in a Response.\n       * @param {string} [method='GET'] The HTTP method to match the Route\n       * against.\n       */\n      constructor(regExp, handler, method) {\n        {\n          assert_js.assert.isInstance(regExp, RegExp, {\n            moduleName: 'workbox-routing',\n            className: 'RegExpRoute',\n            funcName: 'constructor',\n            paramName: 'pattern'\n          });\n        }\n\n        const match = ({\n          url\n        }) => {\n          const result = regExp.exec(url.href); // Return immediately if there's no match.\n\n          if (!result) {\n            return;\n          } // Require that the match start at the first character in the URL string\n          // if it's a cross-origin request.\n          // See https://github.com/GoogleChrome/workbox/issues/281 for the context\n          // behind this behavior.\n\n\n          if (url.origin !== location.origin && result.index !== 0) {\n            {\n              logger_js.logger.debug(`The regular expression '${regExp}' only partially matched ` + `against the cross-origin URL '${url}'. RegExpRoute's will only ` + `handle cross-origin requests if they match the entire URL.`);\n            }\n\n            return;\n          } // If the route matches, but there aren't any capture groups defined, then\n          // this will return [], which is truthy and therefore sufficient to\n          // indicate a match.\n          // If there are capture groups, then it will return their values.\n\n\n          return result.slice(1);\n        };\n\n        super(match, handler, method);\n      }\n\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * The Router can be used to process a FetchEvent through one or more\n     * [Routes]{@link module:workbox-routing.Route} responding  with a Request if\n     * a matching route exists.\n     *\n     * If no route matches a given a request, the Router will use a \"default\"\n     * handler if one is defined.\n     *\n     * Should the matching Route throw an error, the Router will use a \"catch\"\n     * handler if one is defined to gracefully deal with issues and respond with a\n     * Request.\n     *\n     * If a request matches multiple routes, the **earliest** registered route will\n     * be used to respond to the request.\n     *\n     * @memberof module:workbox-routing\n     */\n\n    class Router {\n      /**\n       * Initializes a new Router.\n       */\n      constructor() {\n        this._routes = new Map();\n      }\n      /**\n       * @return {Map<string, Array<module:workbox-routing.Route>>} routes A `Map` of HTTP\n       * method name ('GET', etc.) to an array of all the corresponding `Route`\n       * instances that are registered.\n       */\n\n\n      get routes() {\n        return this._routes;\n      }\n      /**\n       * Adds a fetch event listener to respond to events when a route matches\n       * the event's request.\n       */\n\n\n      addFetchListener() {\n        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n        self.addEventListener('fetch', event => {\n          const {\n            request\n          } = event;\n          const responsePromise = this.handleRequest({\n            request,\n            event\n          });\n\n          if (responsePromise) {\n            event.respondWith(responsePromise);\n          }\n        });\n      }\n      /**\n       * Adds a message event listener for URLs to cache from the window.\n       * This is useful to cache resources loaded on the page prior to when the\n       * service worker started controlling it.\n       *\n       * The format of the message data sent from the window should be as follows.\n       * Where the `urlsToCache` array may consist of URL strings or an array of\n       * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\n       *\n       * ```\n       * {\n       *   type: 'CACHE_URLS',\n       *   payload: {\n       *     urlsToCache: [\n       *       './script1.js',\n       *       './script2.js',\n       *       ['./script3.js', {mode: 'no-cors'}],\n       *     ],\n       *   },\n       * }\n       * ```\n       */\n\n\n      addCacheListener() {\n        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n        self.addEventListener('message', event => {\n          if (event.data && event.data.type === 'CACHE_URLS') {\n            const {\n              payload\n            } = event.data;\n\n            {\n              logger_js.logger.debug(`Caching URLs from the window`, payload.urlsToCache);\n            }\n\n            const requestPromises = Promise.all(payload.urlsToCache.map(entry => {\n              if (typeof entry === 'string') {\n                entry = [entry];\n              }\n\n              const request = new Request(...entry);\n              return this.handleRequest({\n                request\n              }); // TODO(philipwalton): TypeScript errors without this typecast for\n              // some reason (probably a bug). The real type here should work but\n              // doesn't: `Array<Promise<Response> | undefined>`.\n            })); // TypeScript\n\n            event.waitUntil(requestPromises); // If a MessageChannel was used, reply to the message on success.\n\n            if (event.ports && event.ports[0]) {\n              requestPromises.then(() => event.ports[0].postMessage(true));\n            }\n          }\n        });\n      }\n      /**\n       * Apply the routing rules to a FetchEvent object to get a Response from an\n       * appropriate Route's handler.\n       *\n       * @param {Object} options\n       * @param {Request} options.request The request to handle (this is usually\n       *     from a fetch event, but it does not have to be).\n       * @param {FetchEvent} [options.event] The event that triggered the request,\n       *     if applicable.\n       * @return {Promise<Response>|undefined} A promise is returned if a\n       *     registered route can handle the request. If there is no matching\n       *     route and there's no `defaultHandler`, `undefined` is returned.\n       */\n\n\n      handleRequest({\n        request,\n        event\n      }) {\n        {\n          assert_js.assert.isInstance(request, Request, {\n            moduleName: 'workbox-routing',\n            className: 'Router',\n            funcName: 'handleRequest',\n            paramName: 'options.request'\n          });\n        }\n\n        const url = new URL(request.url, location.href);\n\n        if (!url.protocol.startsWith('http')) {\n          {\n            logger_js.logger.debug(`Workbox Router only supports URLs that start with 'http'.`);\n          }\n\n          return;\n        }\n\n        const {\n          params,\n          route\n        } = this.findMatchingRoute({\n          url,\n          request,\n          event\n        });\n        let handler = route && route.handler;\n        const debugMessages = [];\n\n        {\n          if (handler) {\n            debugMessages.push([`Found a route to handle this request:`, route]);\n\n            if (params) {\n              debugMessages.push([`Passing the following params to the route's handler:`, params]);\n            }\n          }\n        } // If we don't have a handler because there was no matching route, then\n        // fall back to defaultHandler if that's defined.\n\n\n        if (!handler && this._defaultHandler) {\n          {\n            debugMessages.push(`Failed to find a matching route. Falling ` + `back to the default handler.`);\n          }\n\n          handler = this._defaultHandler;\n        }\n\n        if (!handler) {\n          {\n            // No handler so Workbox will do nothing. If logs is set of debug\n            // i.e. verbose, we should print out this information.\n            logger_js.logger.debug(`No route found for: ${getFriendlyURL_js.getFriendlyURL(url)}`);\n          }\n\n          return;\n        }\n\n        {\n          // We have a handler, meaning Workbox is going to handle the route.\n          // print the routing details to the console.\n          logger_js.logger.groupCollapsed(`Router is responding to: ${getFriendlyURL_js.getFriendlyURL(url)}`);\n          debugMessages.forEach(msg => {\n            if (Array.isArray(msg)) {\n              logger_js.logger.log(...msg);\n            } else {\n              logger_js.logger.log(msg);\n            }\n          });\n          logger_js.logger.groupEnd();\n        } // Wrap in try and catch in case the handle method throws a synchronous\n        // error. It should still callback to the catch handler.\n\n\n        let responsePromise;\n\n        try {\n          responsePromise = handler.handle({\n            url,\n            request,\n            event,\n            params\n          });\n        } catch (err) {\n          responsePromise = Promise.reject(err);\n        }\n\n        if (responsePromise instanceof Promise && this._catchHandler) {\n          responsePromise = responsePromise.catch(err => {\n            {\n              // Still include URL here as it will be async from the console group\n              // and may not make sense without the URL\n              logger_js.logger.groupCollapsed(`Error thrown when responding to: ` + ` ${getFriendlyURL_js.getFriendlyURL(url)}. Falling back to Catch Handler.`);\n              logger_js.logger.error(`Error thrown by:`, route);\n              logger_js.logger.error(err);\n              logger_js.logger.groupEnd();\n            }\n\n            return this._catchHandler.handle({\n              url,\n              request,\n              event\n            });\n          });\n        }\n\n        return responsePromise;\n      }\n      /**\n       * Checks a request and URL (and optionally an event) against the list of\n       * registered routes, and if there's a match, returns the corresponding\n       * route along with any params generated by the match.\n       *\n       * @param {Object} options\n       * @param {URL} options.url\n       * @param {Request} options.request The request to match.\n       * @param {Event} [options.event] The corresponding event (unless N/A).\n       * @return {Object} An object with `route` and `params` properties.\n       *     They are populated if a matching route was found or `undefined`\n       *     otherwise.\n       */\n\n\n      findMatchingRoute({\n        url,\n        request,\n        event\n      }) {\n        {\n          assert_js.assert.isInstance(url, URL, {\n            moduleName: 'workbox-routing',\n            className: 'Router',\n            funcName: 'findMatchingRoute',\n            paramName: 'options.url'\n          });\n          assert_js.assert.isInstance(request, Request, {\n            moduleName: 'workbox-routing',\n            className: 'Router',\n            funcName: 'findMatchingRoute',\n            paramName: 'options.request'\n          });\n        }\n\n        const routes = this._routes.get(request.method) || [];\n\n        for (const route of routes) {\n          let params;\n          const matchResult = route.match({\n            url,\n            request,\n            event\n          });\n\n          if (matchResult) {\n            // See https://github.com/GoogleChrome/workbox/issues/2079\n            params = matchResult;\n\n            if (Array.isArray(matchResult) && matchResult.length === 0) {\n              // Instead of passing an empty array in as params, use undefined.\n              params = undefined;\n            } else if (matchResult.constructor === Object && Object.keys(matchResult).length === 0) {\n              // Instead of passing an empty object in as params, use undefined.\n              params = undefined;\n            } else if (typeof matchResult === 'boolean') {\n              // For the boolean value true (rather than just something truth-y),\n              // don't set params.\n              // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353\n              params = undefined;\n            } // Return early if have a match.\n\n\n            return {\n              route,\n              params\n            };\n          }\n        } // If no match was found above, return and empty object.\n\n\n        return {};\n      }\n      /**\n       * Define a default `handler` that's called when no routes explicitly\n       * match the incoming request.\n       *\n       * Without a default handler, unmatched requests will go against the\n       * network as if there were no service worker present.\n       *\n       * @param {module:workbox-routing~handlerCallback} handler A callback\n       * function that returns a Promise resulting in a Response.\n       */\n\n\n      setDefaultHandler(handler) {\n        this._defaultHandler = normalizeHandler(handler);\n      }\n      /**\n       * If a Route throws an error while handling a request, this `handler`\n       * will be called and given a chance to provide a response.\n       *\n       * @param {module:workbox-routing~handlerCallback} handler A callback\n       * function that returns a Promise resulting in a Response.\n       */\n\n\n      setCatchHandler(handler) {\n        this._catchHandler = normalizeHandler(handler);\n      }\n      /**\n       * Registers a route with the router.\n       *\n       * @param {module:workbox-routing.Route} route The route to register.\n       */\n\n\n      registerRoute(route) {\n        {\n          assert_js.assert.isType(route, 'object', {\n            moduleName: 'workbox-routing',\n            className: 'Router',\n            funcName: 'registerRoute',\n            paramName: 'route'\n          });\n          assert_js.assert.hasMethod(route, 'match', {\n            moduleName: 'workbox-routing',\n            className: 'Router',\n            funcName: 'registerRoute',\n            paramName: 'route'\n          });\n          assert_js.assert.isType(route.handler, 'object', {\n            moduleName: 'workbox-routing',\n            className: 'Router',\n            funcName: 'registerRoute',\n            paramName: 'route'\n          });\n          assert_js.assert.hasMethod(route.handler, 'handle', {\n            moduleName: 'workbox-routing',\n            className: 'Router',\n            funcName: 'registerRoute',\n            paramName: 'route.handler'\n          });\n          assert_js.assert.isType(route.method, 'string', {\n            moduleName: 'workbox-routing',\n            className: 'Router',\n            funcName: 'registerRoute',\n            paramName: 'route.method'\n          });\n        }\n\n        if (!this._routes.has(route.method)) {\n          this._routes.set(route.method, []);\n        } // Give precedence to all of the earlier routes by adding this additional\n        // route to the end of the array.\n\n\n        this._routes.get(route.method).push(route);\n      }\n      /**\n       * Unregisters a route with the router.\n       *\n       * @param {module:workbox-routing.Route} route The route to unregister.\n       */\n\n\n      unregisterRoute(route) {\n        if (!this._routes.has(route.method)) {\n          throw new WorkboxError_js.WorkboxError('unregister-route-but-not-found-with-method', {\n            method: route.method\n          });\n        }\n\n        const routeIndex = this._routes.get(route.method).indexOf(route);\n\n        if (routeIndex > -1) {\n          this._routes.get(route.method).splice(routeIndex, 1);\n        } else {\n          throw new WorkboxError_js.WorkboxError('unregister-route-route-not-registered');\n        }\n      }\n\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    let defaultRouter;\n    /**\n     * Creates a new, singleton Router instance if one does not exist. If one\n     * does already exist, that instance is returned.\n     *\n     * @private\n     * @return {Router}\n     */\n\n    const getOrCreateDefaultRouter = () => {\n      if (!defaultRouter) {\n        defaultRouter = new Router(); // The helpers that use the default Router assume these listeners exist.\n\n        defaultRouter.addFetchListener();\n        defaultRouter.addCacheListener();\n      }\n\n      return defaultRouter;\n    };\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Easily register a RegExp, string, or function with a caching\n     * strategy to a singleton Router instance.\n     *\n     * This method will generate a Route for you if needed and\n     * call [registerRoute()]{@link module:workbox-routing.Router#registerRoute}.\n     *\n     * @param {RegExp|string|module:workbox-routing.Route~matchCallback|module:workbox-routing.Route} capture\n     * If the capture param is a `Route`, all other arguments will be ignored.\n     * @param {module:workbox-routing~handlerCallback} [handler] A callback\n     * function that returns a Promise resulting in a Response. This parameter\n     * is required if `capture` is not a `Route` object.\n     * @param {string} [method='GET'] The HTTP method to match the Route\n     * against.\n     * @return {module:workbox-routing.Route} The generated `Route`(Useful for\n     * unregistering).\n     *\n     * @memberof module:workbox-routing\n     */\n\n    function registerRoute(capture, handler, method) {\n      let route;\n\n      if (typeof capture === 'string') {\n        const captureUrl = new URL(capture, location.href);\n\n        {\n          if (!(capture.startsWith('/') || capture.startsWith('http'))) {\n            throw new WorkboxError_js.WorkboxError('invalid-string', {\n              moduleName: 'workbox-routing',\n              funcName: 'registerRoute',\n              paramName: 'capture'\n            });\n          } // We want to check if Express-style wildcards are in the pathname only.\n          // TODO: Remove this log message in v4.\n\n\n          const valueToCheck = capture.startsWith('http') ? captureUrl.pathname : capture; // See https://github.com/pillarjs/path-to-regexp#parameters\n\n          const wildcards = '[*:?+]';\n\n          if (new RegExp(`${wildcards}`).exec(valueToCheck)) {\n            logger_js.logger.debug(`The '$capture' parameter contains an Express-style wildcard ` + `character (${wildcards}). Strings are now always interpreted as ` + `exact matches; use a RegExp for partial or wildcard matches.`);\n          }\n        }\n\n        const matchCallback = ({\n          url\n        }) => {\n          {\n            if (url.pathname === captureUrl.pathname && url.origin !== captureUrl.origin) {\n              logger_js.logger.debug(`${capture} only partially matches the cross-origin URL ` + `${url}. This route will only handle cross-origin requests ` + `if they match the entire URL.`);\n            }\n          }\n\n          return url.href === captureUrl.href;\n        }; // If `capture` is a string then `handler` and `method` must be present.\n\n\n        route = new Route(matchCallback, handler, method);\n      } else if (capture instanceof RegExp) {\n        // If `capture` is a `RegExp` then `handler` and `method` must be present.\n        route = new RegExpRoute(capture, handler, method);\n      } else if (typeof capture === 'function') {\n        // If `capture` is a function then `handler` and `method` must be present.\n        route = new Route(capture, handler, method);\n      } else if (capture instanceof Route) {\n        route = capture;\n      } else {\n        throw new WorkboxError_js.WorkboxError('unsupported-route-type', {\n          moduleName: 'workbox-routing',\n          funcName: 'registerRoute',\n          paramName: 'capture'\n        });\n      }\n\n      const defaultRouter = getOrCreateDefaultRouter();\n      defaultRouter.registerRoute(route);\n      return route;\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * If a Route throws an error while handling a request, this `handler`\n     * will be called and given a chance to provide a response.\n     *\n     * @param {module:workbox-routing~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     *\n     * @memberof module:workbox-routing\n     */\n\n    function setCatchHandler(handler) {\n      const defaultRouter = getOrCreateDefaultRouter();\n      defaultRouter.setCatchHandler(handler);\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Define a default `handler` that's called when no routes explicitly\n     * match the incoming request.\n     *\n     * Without a default handler, unmatched requests will go against the\n     * network as if there were no service worker present.\n     *\n     * @param {module:workbox-routing~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     *\n     * @memberof module:workbox-routing\n     */\n\n    function setDefaultHandler(handler) {\n      const defaultRouter = getOrCreateDefaultRouter();\n      defaultRouter.setDefaultHandler(handler);\n    }\n\n    exports.NavigationRoute = NavigationRoute;\n    exports.RegExpRoute = RegExpRoute;\n    exports.Route = Route;\n    exports.Router = Router;\n    exports.registerRoute = registerRoute;\n    exports.setCatchHandler = setCatchHandler;\n    exports.setDefaultHandler = setDefaultHandler;\n\n    return exports;\n\n}({}, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private));\n//# sourceMappingURL=workbox-routing.dev.js.map"},{"path":"/workbox-v5.1.3/workbox-routing.prod.js","content":"this.workbox=this.workbox||{},this.workbox.routing=function(t,e){\"use strict\";try{self[\"workbox:routing:5.1.3\"]&&_()}catch(t){}const s=t=>t&&\"object\"==typeof t?t:{handle:t};class r{constructor(t,e,r=\"GET\"){this.handler=s(e),this.match=t,this.method=r}}class n extends r{constructor(t,e,s){super(({url:e})=>{const s=t.exec(e.href);if(s&&(e.origin===location.origin||0===s.index))return s.slice(1)},e,s)}}class o{constructor(){this.t=new Map}get routes(){return this.t}addFetchListener(){self.addEventListener(\"fetch\",t=>{const{request:e}=t,s=this.handleRequest({request:e,event:t});s&&t.respondWith(s)})}addCacheListener(){self.addEventListener(\"message\",t=>{if(t.data&&\"CACHE_URLS\"===t.data.type){const{payload:e}=t.data,s=Promise.all(e.urlsToCache.map(t=>{\"string\"==typeof t&&(t=[t]);const e=new Request(...t);return this.handleRequest({request:e})}));t.waitUntil(s),t.ports&&t.ports[0]&&s.then(()=>t.ports[0].postMessage(!0))}})}handleRequest({request:t,event:e}){const s=new URL(t.url,location.href);if(!s.protocol.startsWith(\"http\"))return;const{params:r,route:n}=this.findMatchingRoute({url:s,request:t,event:e});let o,i=n&&n.handler;if(!i&&this.s&&(i=this.s),i){try{o=i.handle({url:s,request:t,event:e,params:r})}catch(t){o=Promise.reject(t)}return o instanceof Promise&&this.o&&(o=o.catch(r=>this.o.handle({url:s,request:t,event:e}))),o}}findMatchingRoute({url:t,request:e,event:s}){const r=this.t.get(e.method)||[];for(const n of r){let r;const o=n.match({url:t,request:e,event:s});if(o)return r=o,(Array.isArray(o)&&0===o.length||o.constructor===Object&&0===Object.keys(o).length||\"boolean\"==typeof o)&&(r=void 0),{route:n,params:r}}return{}}setDefaultHandler(t){this.s=s(t)}setCatchHandler(t){this.o=s(t)}registerRoute(t){this.t.has(t.method)||this.t.set(t.method,[]),this.t.get(t.method).push(t)}unregisterRoute(t){if(!this.t.has(t.method))throw new e.WorkboxError(\"unregister-route-but-not-found-with-method\",{method:t.method});const s=this.t.get(t.method).indexOf(t);if(!(s>-1))throw new e.WorkboxError(\"unregister-route-route-not-registered\");this.t.get(t.method).splice(s,1)}}let i;const u=()=>(i||(i=new o,i.addFetchListener(),i.addCacheListener()),i);return t.NavigationRoute=class extends r{constructor(t,{allowlist:e=[/./],denylist:s=[]}={}){super(t=>this.i(t),t),this.u=e,this.h=s}i({url:t,request:e}){if(e&&\"navigate\"!==e.mode)return!1;const s=t.pathname+t.search;for(const t of this.h)if(t.test(s))return!1;return!!this.u.some(t=>t.test(s))}},t.RegExpRoute=n,t.Route=r,t.Router=o,t.registerRoute=function(t,s,o){let i;if(\"string\"==typeof t){const e=new URL(t,location.href);i=new r(({url:t})=>t.href===e.href,s,o)}else if(t instanceof RegExp)i=new n(t,s,o);else if(\"function\"==typeof t)i=new r(t,s,o);else{if(!(t instanceof r))throw new e.WorkboxError(\"unsupported-route-type\",{moduleName:\"workbox-routing\",funcName:\"registerRoute\",paramName:\"capture\"});i=t}return u().registerRoute(i),i},t.setCatchHandler=function(t){u().setCatchHandler(t)},t.setDefaultHandler=function(t){u().setDefaultHandler(t)},t}({},workbox.core._private);\n//# sourceMappingURL=workbox-routing.prod.js.map"},{"path":"/workbox-v5.1.3/workbox-strategies.dev.js","content":"this.workbox = this.workbox || {};\nthis.workbox.strategies = (function (exports, assert_js, cacheNames_js, cacheWrapper_js, fetchWrapper_js, getFriendlyURL_js, logger_js, WorkboxError_js) {\n    'use strict';\n\n    try {\n      self['workbox:strategies:5.1.3'] && _();\n    } catch (e) {}\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const messages = {\n      strategyStart: (strategyName, request) => `Using ${strategyName} to respond to '${getFriendlyURL_js.getFriendlyURL(request.url)}'`,\n      printFinalResponse: response => {\n        if (response) {\n          logger_js.logger.groupCollapsed(`View the final response here.`);\n          logger_js.logger.log(response || '[No response returned]');\n          logger_js.logger.groupEnd();\n        }\n      }\n    };\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * An implementation of a [cache-first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network}\n     * request strategy.\n     *\n     * A cache first strategy is useful for assets that have been revisioned,\n     * such as URLs like `/styles/example.a8f5f1.css`, since they\n     * can be cached for long periods of time.\n     *\n     * If the network request fails, and there is no cache match, this will throw\n     * a `WorkboxError` exception.\n     *\n     * @memberof module:workbox-strategies\n     */\n\n    class CacheFirst {\n      /**\n       * @param {Object} options\n       * @param {string} options.cacheName Cache name to store and retrieve\n       * requests. Defaults to cache names provided by\n       * [workbox-core]{@link module:workbox-core.cacheNames}.\n       * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n       * to use in conjunction with this caching strategy.\n       * @param {Object} options.fetchOptions Values passed along to the\n       * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n       * of all fetch() requests made by this strategy.\n       * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n       */\n      constructor(options = {}) {\n        this._cacheName = cacheNames_js.cacheNames.getRuntimeName(options.cacheName);\n        this._plugins = options.plugins || [];\n        this._fetchOptions = options.fetchOptions;\n        this._matchOptions = options.matchOptions;\n      }\n      /**\n       * This method will perform a request strategy and follows an API that\n       * will work with the\n       * [Workbox Router]{@link module:workbox-routing.Router}.\n       *\n       * @param {Object} options\n       * @param {Request|string} options.request A request to run this strategy for.\n       * @param {Event} [options.event] The event that triggered the request.\n       * @return {Promise<Response>}\n       */\n\n\n      async handle({\n        event,\n        request\n      }) {\n        const logs = [];\n\n        if (typeof request === 'string') {\n          request = new Request(request);\n        }\n\n        {\n          assert_js.assert.isInstance(request, Request, {\n            moduleName: 'workbox-strategies',\n            className: 'CacheFirst',\n            funcName: 'makeRequest',\n            paramName: 'request'\n          });\n        }\n\n        let response = await cacheWrapper_js.cacheWrapper.match({\n          cacheName: this._cacheName,\n          request,\n          event,\n          matchOptions: this._matchOptions,\n          plugins: this._plugins\n        });\n        let error;\n\n        if (!response) {\n          {\n            logs.push(`No response found in the '${this._cacheName}' cache. ` + `Will respond with a network request.`);\n          }\n\n          try {\n            response = await this._getFromNetwork(request, event);\n          } catch (err) {\n            error = err;\n          }\n\n          {\n            if (response) {\n              logs.push(`Got response from network.`);\n            } else {\n              logs.push(`Unable to get a response from the network.`);\n            }\n          }\n        } else {\n          {\n            logs.push(`Found a cached response in the '${this._cacheName}' cache.`);\n          }\n        }\n\n        {\n          logger_js.logger.groupCollapsed(messages.strategyStart('CacheFirst', request));\n\n          for (const log of logs) {\n            logger_js.logger.log(log);\n          }\n\n          messages.printFinalResponse(response);\n          logger_js.logger.groupEnd();\n        }\n\n        if (!response) {\n          throw new WorkboxError_js.WorkboxError('no-response', {\n            url: request.url,\n            error\n          });\n        }\n\n        return response;\n      }\n      /**\n       * Handles the network and cache part of CacheFirst.\n       *\n       * @param {Request} request\n       * @param {Event} [event]\n       * @return {Promise<Response>}\n       *\n       * @private\n       */\n\n\n      async _getFromNetwork(request, event) {\n        const response = await fetchWrapper_js.fetchWrapper.fetch({\n          request,\n          event,\n          fetchOptions: this._fetchOptions,\n          plugins: this._plugins\n        }); // Keep the service worker while we put the request to the cache\n\n        const responseClone = response.clone();\n        const cachePutPromise = cacheWrapper_js.cacheWrapper.put({\n          cacheName: this._cacheName,\n          request,\n          response: responseClone,\n          event,\n          plugins: this._plugins\n        });\n\n        if (event) {\n          try {\n            event.waitUntil(cachePutPromise);\n          } catch (error) {\n            {\n              logger_js.logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache for '${getFriendlyURL_js.getFriendlyURL(request.url)}'.`);\n            }\n          }\n        }\n\n        return response;\n      }\n\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * An implementation of a\n     * [cache-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-only}\n     * request strategy.\n     *\n     * This class is useful if you want to take advantage of any\n     * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\n     *\n     * If there is no cache match, this will throw a `WorkboxError` exception.\n     *\n     * @memberof module:workbox-strategies\n     */\n\n    class CacheOnly {\n      /**\n       * @param {Object} options\n       * @param {string} options.cacheName Cache name to store and retrieve\n       * requests. Defaults to cache names provided by\n       * [workbox-core]{@link module:workbox-core.cacheNames}.\n       * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n       * to use in conjunction with this caching strategy.\n       * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n       */\n      constructor(options = {}) {\n        this._cacheName = cacheNames_js.cacheNames.getRuntimeName(options.cacheName);\n        this._plugins = options.plugins || [];\n        this._matchOptions = options.matchOptions;\n      }\n      /**\n       * This method will perform a request strategy and follows an API that\n       * will work with the\n       * [Workbox Router]{@link module:workbox-routing.Router}.\n       *\n       * @param {Object} options\n       * @param {Request|string} options.request A request to run this strategy for.\n       * @param {Event} [options.event] The event that triggered the request.\n       * @return {Promise<Response>}\n       */\n\n\n      async handle({\n        event,\n        request\n      }) {\n        if (typeof request === 'string') {\n          request = new Request(request);\n        }\n\n        {\n          assert_js.assert.isInstance(request, Request, {\n            moduleName: 'workbox-strategies',\n            className: 'CacheOnly',\n            funcName: 'makeRequest',\n            paramName: 'request'\n          });\n        }\n\n        const response = await cacheWrapper_js.cacheWrapper.match({\n          cacheName: this._cacheName,\n          request,\n          event,\n          matchOptions: this._matchOptions,\n          plugins: this._plugins\n        });\n\n        {\n          logger_js.logger.groupCollapsed(messages.strategyStart('CacheOnly', request));\n\n          if (response) {\n            logger_js.logger.log(`Found a cached response in the '${this._cacheName}'` + ` cache.`);\n            messages.printFinalResponse(response);\n          } else {\n            logger_js.logger.log(`No response found in the '${this._cacheName}' cache.`);\n          }\n\n          logger_js.logger.groupEnd();\n        }\n\n        if (!response) {\n          throw new WorkboxError_js.WorkboxError('no-response', {\n            url: request.url\n          });\n        }\n\n        return response;\n      }\n\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const cacheOkAndOpaquePlugin = {\n      /**\n       * Returns a valid response (to allow caching) if the status is 200 (OK) or\n       * 0 (opaque).\n       *\n       * @param {Object} options\n       * @param {Response} options.response\n       * @return {Response|null}\n       *\n       * @private\n       */\n      cacheWillUpdate: async ({\n        response\n      }) => {\n        if (response.status === 200 || response.status === 0) {\n          return response;\n        }\n\n        return null;\n      }\n    };\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * An implementation of a\n     * [network first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-falling-back-to-cache}\n     * request strategy.\n     *\n     * By default, this strategy will cache responses with a 200 status code as\n     * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n     * Opaque responses are are cross-origin requests where the response doesn't\n     * support [CORS]{@link https://enable-cors.org/}.\n     *\n     * If the network request fails, and there is no cache match, this will throw\n     * a `WorkboxError` exception.\n     *\n     * @memberof module:workbox-strategies\n     */\n\n    class NetworkFirst {\n      /**\n       * @param {Object} options\n       * @param {string} options.cacheName Cache name to store and retrieve\n       * requests. Defaults to cache names provided by\n       * [workbox-core]{@link module:workbox-core.cacheNames}.\n       * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n       * to use in conjunction with this caching strategy.\n       * @param {Object} options.fetchOptions Values passed along to the\n       * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n       * of all fetch() requests made by this strategy.\n       * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n       * @param {number} options.networkTimeoutSeconds If set, any network requests\n       * that fail to respond within the timeout will fallback to the cache.\n       *\n       * This option can be used to combat\n       * \"[lie-fi]{@link https://developers.google.com/web/fundamentals/performance/poor-connectivity/#lie-fi}\"\n       * scenarios.\n       */\n      constructor(options = {}) {\n        this._cacheName = cacheNames_js.cacheNames.getRuntimeName(options.cacheName);\n\n        if (options.plugins) {\n          const isUsingCacheWillUpdate = options.plugins.some(plugin => !!plugin.cacheWillUpdate);\n          this._plugins = isUsingCacheWillUpdate ? options.plugins : [cacheOkAndOpaquePlugin, ...options.plugins];\n        } else {\n          // No plugins passed in, use the default plugin.\n          this._plugins = [cacheOkAndOpaquePlugin];\n        }\n\n        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;\n\n        {\n          if (this._networkTimeoutSeconds) {\n            assert_js.assert.isType(this._networkTimeoutSeconds, 'number', {\n              moduleName: 'workbox-strategies',\n              className: 'NetworkFirst',\n              funcName: 'constructor',\n              paramName: 'networkTimeoutSeconds'\n            });\n          }\n        }\n\n        this._fetchOptions = options.fetchOptions;\n        this._matchOptions = options.matchOptions;\n      }\n      /**\n       * This method will perform a request strategy and follows an API that\n       * will work with the\n       * [Workbox Router]{@link module:workbox-routing.Router}.\n       *\n       * @param {Object} options\n       * @param {Request|string} options.request A request to run this strategy for.\n       * @param {Event} [options.event] The event that triggered the request.\n       * @return {Promise<Response>}\n       */\n\n\n      async handle({\n        event,\n        request\n      }) {\n        const logs = [];\n\n        if (typeof request === 'string') {\n          request = new Request(request);\n        }\n\n        {\n          assert_js.assert.isInstance(request, Request, {\n            moduleName: 'workbox-strategies',\n            className: 'NetworkFirst',\n            funcName: 'handle',\n            paramName: 'makeRequest'\n          });\n        }\n\n        const promises = [];\n        let timeoutId;\n\n        if (this._networkTimeoutSeconds) {\n          const {\n            id,\n            promise\n          } = this._getTimeoutPromise({\n            request,\n            event,\n            logs\n          });\n\n          timeoutId = id;\n          promises.push(promise);\n        }\n\n        const networkPromise = this._getNetworkPromise({\n          timeoutId,\n          request,\n          event,\n          logs\n        });\n\n        promises.push(networkPromise); // Promise.race() will resolve as soon as the first promise resolves.\n\n        let response = await Promise.race(promises); // If Promise.race() resolved with null, it might be due to a network\n        // timeout + a cache miss. If that were to happen, we'd rather wait until\n        // the networkPromise resolves instead of returning null.\n        // Note that it's fine to await an already-resolved promise, so we don't\n        // have to check to see if it's still \"in flight\".\n\n        if (!response) {\n          response = await networkPromise;\n        }\n\n        {\n          logger_js.logger.groupCollapsed(messages.strategyStart('NetworkFirst', request));\n\n          for (const log of logs) {\n            logger_js.logger.log(log);\n          }\n\n          messages.printFinalResponse(response);\n          logger_js.logger.groupEnd();\n        }\n\n        if (!response) {\n          throw new WorkboxError_js.WorkboxError('no-response', {\n            url: request.url\n          });\n        }\n\n        return response;\n      }\n      /**\n       * @param {Object} options\n       * @param {Request} options.request\n       * @param {Array} options.logs A reference to the logs array\n       * @param {Event} [options.event]\n       * @return {Promise<Response>}\n       *\n       * @private\n       */\n\n\n      _getTimeoutPromise({\n        request,\n        logs,\n        event\n      }) {\n        let timeoutId;\n        const timeoutPromise = new Promise(resolve => {\n          const onNetworkTimeout = async () => {\n            {\n              logs.push(`Timing out the network response at ` + `${this._networkTimeoutSeconds} seconds.`);\n            }\n\n            resolve((await this._respondFromCache({\n              request,\n              event\n            })));\n          };\n\n          timeoutId = setTimeout(onNetworkTimeout, this._networkTimeoutSeconds * 1000);\n        });\n        return {\n          promise: timeoutPromise,\n          id: timeoutId\n        };\n      }\n      /**\n       * @param {Object} options\n       * @param {number|undefined} options.timeoutId\n       * @param {Request} options.request\n       * @param {Array} options.logs A reference to the logs Array.\n       * @param {Event} [options.event]\n       * @return {Promise<Response>}\n       *\n       * @private\n       */\n\n\n      async _getNetworkPromise({\n        timeoutId,\n        request,\n        logs,\n        event\n      }) {\n        let error;\n        let response;\n\n        try {\n          response = await fetchWrapper_js.fetchWrapper.fetch({\n            request,\n            event,\n            fetchOptions: this._fetchOptions,\n            plugins: this._plugins\n          });\n        } catch (err) {\n          error = err;\n        }\n\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n\n        {\n          if (response) {\n            logs.push(`Got response from network.`);\n          } else {\n            logs.push(`Unable to get a response from the network. Will respond ` + `with a cached response.`);\n          }\n        }\n\n        if (error || !response) {\n          response = await this._respondFromCache({\n            request,\n            event\n          });\n\n          {\n            if (response) {\n              logs.push(`Found a cached response in the '${this._cacheName}'` + ` cache.`);\n            } else {\n              logs.push(`No response found in the '${this._cacheName}' cache.`);\n            }\n          }\n        } else {\n          // Keep the service worker alive while we put the request in the cache\n          const responseClone = response.clone();\n          const cachePut = cacheWrapper_js.cacheWrapper.put({\n            cacheName: this._cacheName,\n            request,\n            response: responseClone,\n            event,\n            plugins: this._plugins\n          });\n\n          if (event) {\n            try {\n              // The event has been responded to so we can keep the SW alive to\n              // respond to the request\n              event.waitUntil(cachePut);\n            } catch (err) {\n              {\n                logger_js.logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache for '${getFriendlyURL_js.getFriendlyURL(request.url)}'.`);\n              }\n            }\n          }\n        }\n\n        return response;\n      }\n      /**\n       * Used if the network timeouts or fails to make the request.\n       *\n       * @param {Object} options\n       * @param {Request} request The request to match in the cache\n       * @param {Event} [options.event]\n       * @return {Promise<Object>}\n       *\n       * @private\n       */\n\n\n      _respondFromCache({\n        event,\n        request\n      }) {\n        return cacheWrapper_js.cacheWrapper.match({\n          cacheName: this._cacheName,\n          request,\n          event,\n          matchOptions: this._matchOptions,\n          plugins: this._plugins\n        });\n      }\n\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * An implementation of a\n     * [network-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-only}\n     * request strategy.\n     *\n     * This class is useful if you want to take advantage of any\n     * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\n     *\n     * If the network request fails, this will throw a `WorkboxError` exception.\n     *\n     * @memberof module:workbox-strategies\n     */\n\n    class NetworkOnly {\n      /**\n       * @param {Object} options\n       * @param {string} options.cacheName Cache name to store and retrieve\n       * requests. Defaults to cache names provided by\n       * [workbox-core]{@link module:workbox-core.cacheNames}.\n       * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n       * to use in conjunction with this caching strategy.\n       * @param {Object} options.fetchOptions Values passed along to the\n       * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n       * of all fetch() requests made by this strategy.\n       */\n      constructor(options = {}) {\n        this._plugins = options.plugins || [];\n        this._fetchOptions = options.fetchOptions;\n      }\n      /**\n       * This method will perform a request strategy and follows an API that\n       * will work with the\n       * [Workbox Router]{@link module:workbox-routing.Router}.\n       *\n       * @param {Object} options\n       * @param {Request|string} options.request The request to run this strategy for.\n       * @param {Event} [options.event] The event that triggered the request.\n       * @return {Promise<Response>}\n       */\n\n\n      async handle({\n        event,\n        request\n      }) {\n        if (typeof request === 'string') {\n          request = new Request(request);\n        }\n\n        {\n          assert_js.assert.isInstance(request, Request, {\n            moduleName: 'workbox-strategies',\n            className: 'NetworkOnly',\n            funcName: 'handle',\n            paramName: 'request'\n          });\n        }\n\n        let error;\n        let response;\n\n        try {\n          response = await fetchWrapper_js.fetchWrapper.fetch({\n            request,\n            event,\n            fetchOptions: this._fetchOptions,\n            plugins: this._plugins\n          });\n        } catch (err) {\n          error = err;\n        }\n\n        {\n          logger_js.logger.groupCollapsed(messages.strategyStart('NetworkOnly', request));\n\n          if (response) {\n            logger_js.logger.log(`Got response from network.`);\n          } else {\n            logger_js.logger.log(`Unable to get a response from the network.`);\n          }\n\n          messages.printFinalResponse(response);\n          logger_js.logger.groupEnd();\n        }\n\n        if (!response) {\n          throw new WorkboxError_js.WorkboxError('no-response', {\n            url: request.url,\n            error\n          });\n        }\n\n        return response;\n      }\n\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * An implementation of a\n     * [stale-while-revalidate]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate}\n     * request strategy.\n     *\n     * Resources are requested from both the cache and the network in parallel.\n     * The strategy will respond with the cached version if available, otherwise\n     * wait for the network response. The cache is updated with the network response\n     * with each successful request.\n     *\n     * By default, this strategy will cache responses with a 200 status code as\n     * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n     * Opaque responses are cross-origin requests where the response doesn't\n     * support [CORS]{@link https://enable-cors.org/}.\n     *\n     * If the network request fails, and there is no cache match, this will throw\n     * a `WorkboxError` exception.\n     *\n     * @memberof module:workbox-strategies\n     */\n\n    class StaleWhileRevalidate {\n      /**\n       * @param {Object} options\n       * @param {string} options.cacheName Cache name to store and retrieve\n       * requests. Defaults to cache names provided by\n       * [workbox-core]{@link module:workbox-core.cacheNames}.\n       * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n       * to use in conjunction with this caching strategy.\n       * @param {Object} options.fetchOptions Values passed along to the\n       * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n       * of all fetch() requests made by this strategy.\n       * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n       */\n      constructor(options = {}) {\n        this._cacheName = cacheNames_js.cacheNames.getRuntimeName(options.cacheName);\n        this._plugins = options.plugins || [];\n\n        if (options.plugins) {\n          const isUsingCacheWillUpdate = options.plugins.some(plugin => !!plugin.cacheWillUpdate);\n          this._plugins = isUsingCacheWillUpdate ? options.plugins : [cacheOkAndOpaquePlugin, ...options.plugins];\n        } else {\n          // No plugins passed in, use the default plugin.\n          this._plugins = [cacheOkAndOpaquePlugin];\n        }\n\n        this._fetchOptions = options.fetchOptions;\n        this._matchOptions = options.matchOptions;\n      }\n      /**\n       * This method will perform a request strategy and follows an API that\n       * will work with the\n       * [Workbox Router]{@link module:workbox-routing.Router}.\n       *\n       * @param {Object} options\n       * @param {Request|string} options.request A request to run this strategy for.\n       * @param {Event} [options.event] The event that triggered the request.\n       * @return {Promise<Response>}\n       */\n\n\n      async handle({\n        event,\n        request\n      }) {\n        const logs = [];\n\n        if (typeof request === 'string') {\n          request = new Request(request);\n        }\n\n        {\n          assert_js.assert.isInstance(request, Request, {\n            moduleName: 'workbox-strategies',\n            className: 'StaleWhileRevalidate',\n            funcName: 'handle',\n            paramName: 'request'\n          });\n        }\n\n        const fetchAndCachePromise = this._getFromNetwork({\n          request,\n          event\n        });\n\n        let response = await cacheWrapper_js.cacheWrapper.match({\n          cacheName: this._cacheName,\n          request,\n          event,\n          matchOptions: this._matchOptions,\n          plugins: this._plugins\n        });\n        let error;\n\n        if (response) {\n          {\n            logs.push(`Found a cached response in the '${this._cacheName}'` + ` cache. Will update with the network response in the background.`);\n          }\n\n          if (event) {\n            try {\n              event.waitUntil(fetchAndCachePromise);\n            } catch (error) {\n              {\n                logger_js.logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache for '${getFriendlyURL_js.getFriendlyURL(request.url)}'.`);\n              }\n            }\n          }\n        } else {\n          {\n            logs.push(`No response found in the '${this._cacheName}' cache. ` + `Will wait for the network response.`);\n          }\n\n          try {\n            response = await fetchAndCachePromise;\n          } catch (err) {\n            error = err;\n          }\n        }\n\n        {\n          logger_js.logger.groupCollapsed(messages.strategyStart('StaleWhileRevalidate', request));\n\n          for (const log of logs) {\n            logger_js.logger.log(log);\n          }\n\n          messages.printFinalResponse(response);\n          logger_js.logger.groupEnd();\n        }\n\n        if (!response) {\n          throw new WorkboxError_js.WorkboxError('no-response', {\n            url: request.url,\n            error\n          });\n        }\n\n        return response;\n      }\n      /**\n       * @param {Object} options\n       * @param {Request} options.request\n       * @param {Event} [options.event]\n       * @return {Promise<Response>}\n       *\n       * @private\n       */\n\n\n      async _getFromNetwork({\n        request,\n        event\n      }) {\n        const response = await fetchWrapper_js.fetchWrapper.fetch({\n          request,\n          event,\n          fetchOptions: this._fetchOptions,\n          plugins: this._plugins\n        });\n        const cachePutPromise = cacheWrapper_js.cacheWrapper.put({\n          cacheName: this._cacheName,\n          request,\n          response: response.clone(),\n          event,\n          plugins: this._plugins\n        });\n\n        if (event) {\n          try {\n            event.waitUntil(cachePutPromise);\n          } catch (error) {\n            {\n              logger_js.logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache for '${getFriendlyURL_js.getFriendlyURL(request.url)}'.`);\n            }\n          }\n        }\n\n        return response;\n      }\n\n    }\n\n    exports.CacheFirst = CacheFirst;\n    exports.CacheOnly = CacheOnly;\n    exports.NetworkFirst = NetworkFirst;\n    exports.NetworkOnly = NetworkOnly;\n    exports.StaleWhileRevalidate = StaleWhileRevalidate;\n\n    return exports;\n\n}({}, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private));\n//# sourceMappingURL=workbox-strategies.dev.js.map"},{"path":"/workbox-v5.1.3/workbox-strategies.prod.js","content":"this.workbox=this.workbox||{},this.workbox.strategies=function(t,e,s,i,n){\"use strict\";try{self[\"workbox:strategies:5.1.3\"]&&_()}catch(t){}const r={cacheWillUpdate:async({response:t})=>200===t.status||0===t.status?t:null};return t.CacheFirst=class{constructor(t={}){this.t=e.cacheNames.getRuntimeName(t.cacheName),this.s=t.plugins||[],this.i=t.fetchOptions,this.h=t.matchOptions}async handle({event:t,request:e}){\"string\"==typeof e&&(e=new Request(e));let i,r=await s.cacheWrapper.match({cacheName:this.t,request:e,event:t,matchOptions:this.h,plugins:this.s});if(!r)try{r=await this.o(e,t)}catch(t){i=t}if(!r)throw new n.WorkboxError(\"no-response\",{url:e.url,error:i});return r}async o(t,e){const n=await i.fetchWrapper.fetch({request:t,event:e,fetchOptions:this.i,plugins:this.s}),r=n.clone(),h=s.cacheWrapper.put({cacheName:this.t,request:t,response:r,event:e,plugins:this.s});if(e)try{e.waitUntil(h)}catch(t){}return n}},t.CacheOnly=class{constructor(t={}){this.t=e.cacheNames.getRuntimeName(t.cacheName),this.s=t.plugins||[],this.h=t.matchOptions}async handle({event:t,request:e}){\"string\"==typeof e&&(e=new Request(e));const i=await s.cacheWrapper.match({cacheName:this.t,request:e,event:t,matchOptions:this.h,plugins:this.s});if(!i)throw new n.WorkboxError(\"no-response\",{url:e.url});return i}},t.NetworkFirst=class{constructor(t={}){if(this.t=e.cacheNames.getRuntimeName(t.cacheName),t.plugins){const e=t.plugins.some(t=>!!t.cacheWillUpdate);this.s=e?t.plugins:[r,...t.plugins]}else this.s=[r];this.u=t.networkTimeoutSeconds||0,this.i=t.fetchOptions,this.h=t.matchOptions}async handle({event:t,request:e}){const s=[];\"string\"==typeof e&&(e=new Request(e));const i=[];let r;if(this.u){const{id:n,promise:h}=this.l({request:e,event:t,logs:s});r=n,i.push(h)}const h=this.p({timeoutId:r,request:e,event:t,logs:s});i.push(h);let o=await Promise.race(i);if(o||(o=await h),!o)throw new n.WorkboxError(\"no-response\",{url:e.url});return o}l({request:t,logs:e,event:s}){let i;return{promise:new Promise(e=>{i=setTimeout(async()=>{e(await this.q({request:t,event:s}))},1e3*this.u)}),id:i}}async p({timeoutId:t,request:e,logs:n,event:r}){let h,o;try{o=await i.fetchWrapper.fetch({request:e,event:r,fetchOptions:this.i,plugins:this.s})}catch(t){h=t}if(t&&clearTimeout(t),h||!o)o=await this.q({request:e,event:r});else{const t=o.clone(),i=s.cacheWrapper.put({cacheName:this.t,request:e,response:t,event:r,plugins:this.s});if(r)try{r.waitUntil(i)}catch(t){}}return o}q({event:t,request:e}){return s.cacheWrapper.match({cacheName:this.t,request:e,event:t,matchOptions:this.h,plugins:this.s})}},t.NetworkOnly=class{constructor(t={}){this.s=t.plugins||[],this.i=t.fetchOptions}async handle({event:t,request:e}){let s,r;\"string\"==typeof e&&(e=new Request(e));try{r=await i.fetchWrapper.fetch({request:e,event:t,fetchOptions:this.i,plugins:this.s})}catch(t){s=t}if(!r)throw new n.WorkboxError(\"no-response\",{url:e.url,error:s});return r}},t.StaleWhileRevalidate=class{constructor(t={}){if(this.t=e.cacheNames.getRuntimeName(t.cacheName),this.s=t.plugins||[],t.plugins){const e=t.plugins.some(t=>!!t.cacheWillUpdate);this.s=e?t.plugins:[r,...t.plugins]}else this.s=[r];this.i=t.fetchOptions,this.h=t.matchOptions}async handle({event:t,request:e}){\"string\"==typeof e&&(e=new Request(e));const i=this.o({request:e,event:t});let r,h=await s.cacheWrapper.match({cacheName:this.t,request:e,event:t,matchOptions:this.h,plugins:this.s});if(h){if(t)try{t.waitUntil(i)}catch(r){}}else try{h=await i}catch(t){r=t}if(!h)throw new n.WorkboxError(\"no-response\",{url:e.url,error:r});return h}async o({request:t,event:e}){const n=await i.fetchWrapper.fetch({request:t,event:e,fetchOptions:this.i,plugins:this.s}),r=s.cacheWrapper.put({cacheName:this.t,request:t,response:n.clone(),event:e,plugins:this.s});if(e)try{e.waitUntil(r)}catch(t){}return n}},t}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private);\n//# sourceMappingURL=workbox-strategies.prod.js.map"},{"path":"/workbox-v5.1.3/workbox-streams.dev.js","content":"this.workbox = this.workbox || {};\nthis.workbox.streams = (function (exports, logger_js, assert_js, Deferred_js, canConstructReadableStream_js) {\n    'use strict';\n\n    try {\n      self['workbox:streams:5.1.3'] && _();\n    } catch (e) {}\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Takes either a Response, a ReadableStream, or a\n     * [BodyInit](https://fetch.spec.whatwg.org/#bodyinit) and returns the\n     * ReadableStreamReader object associated with it.\n     *\n     * @param {module:workbox-streams.StreamSource} source\n     * @return {ReadableStreamReader}\n     * @private\n     */\n\n    function _getReaderFromSource(source) {\n      if (source instanceof Response) {\n        return source.body.getReader();\n      }\n\n      if (source instanceof ReadableStream) {\n        return source.getReader();\n      }\n\n      return new Response(source).body.getReader();\n    }\n    /**\n     * Takes multiple source Promises, each of which could resolve to a Response, a\n     * ReadableStream, or a [BodyInit](https://fetch.spec.whatwg.org/#bodyinit).\n     *\n     * Returns an object exposing a ReadableStream with each individual stream's\n     * data returned in sequence, along with a Promise which signals when the\n     * stream is finished (useful for passing to a FetchEvent's waitUntil()).\n     *\n     * @param {Array<Promise<module:workbox-streams.StreamSource>>} sourcePromises\n     * @return {Object<{done: Promise, stream: ReadableStream}>}\n     *\n     * @memberof module:workbox-streams\n     */\n\n\n    function concatenate(sourcePromises) {\n      {\n        assert_js.assert.isArray(sourcePromises, {\n          moduleName: 'workbox-streams',\n          funcName: 'concatenate',\n          paramName: 'sourcePromises'\n        });\n      }\n\n      const readerPromises = sourcePromises.map(sourcePromise => {\n        return Promise.resolve(sourcePromise).then(source => {\n          return _getReaderFromSource(source);\n        });\n      });\n      const streamDeferred = new Deferred_js.Deferred();\n      let i = 0;\n      const logMessages = [];\n      const stream = new ReadableStream({\n        pull(controller) {\n          return readerPromises[i].then(reader => reader.read()).then(result => {\n            if (result.done) {\n              {\n                logMessages.push(['Reached the end of source:', sourcePromises[i]]);\n              }\n\n              i++;\n\n              if (i >= readerPromises.length) {\n                // Log all the messages in the group at once in a single group.\n                {\n                  logger_js.logger.groupCollapsed(`Concatenating ${readerPromises.length} sources.`);\n\n                  for (const message of logMessages) {\n                    if (Array.isArray(message)) {\n                      logger_js.logger.log(...message);\n                    } else {\n                      logger_js.logger.log(message);\n                    }\n                  }\n\n                  logger_js.logger.log('Finished reading all sources.');\n                  logger_js.logger.groupEnd();\n                }\n\n                controller.close();\n                streamDeferred.resolve();\n                return;\n              } // The `pull` method is defined because we're inside it.\n\n\n              return this.pull(controller);\n            } else {\n              controller.enqueue(result.value);\n            }\n          }).catch(error => {\n            {\n              logger_js.logger.error('An error occurred:', error);\n            }\n\n            streamDeferred.reject(error);\n            throw error;\n          });\n        },\n\n        cancel() {\n          {\n            logger_js.logger.warn('The ReadableStream was cancelled.');\n          }\n\n          streamDeferred.resolve();\n        }\n\n      });\n      return {\n        done: streamDeferred.promise,\n        stream\n      };\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * This is a utility method that determines whether the current browser supports\n     * the features required to create streamed responses. Currently, it checks if\n     * [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/ReadableStream)\n     * is available.\n     *\n     * @private\n     * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n     * `'text/html'` will be used by default.\n     * @return {boolean} `true`, if the current browser meets the requirements for\n     * streaming responses, and `false` otherwise.\n     *\n     * @memberof module:workbox-streams\n     */\n\n    function createHeaders(headersInit = {}) {\n      // See https://github.com/GoogleChrome/workbox/issues/1461\n      const headers = new Headers(headersInit);\n\n      if (!headers.has('content-type')) {\n        headers.set('content-type', 'text/html');\n      }\n\n      return headers;\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Takes multiple source Promises, each of which could resolve to a Response, a\n     * ReadableStream, or a [BodyInit](https://fetch.spec.whatwg.org/#bodyinit),\n     * along with a\n     * [HeadersInit](https://fetch.spec.whatwg.org/#typedefdef-headersinit).\n     *\n     * Returns an object exposing a Response whose body consists of each individual\n     * stream's data returned in sequence, along with a Promise which signals when\n     * the stream is finished (useful for passing to a FetchEvent's waitUntil()).\n     *\n     * @param {Array<Promise<module:workbox-streams.StreamSource>>} sourcePromises\n     * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n     * `'text/html'` will be used by default.\n     * @return {Object<{done: Promise, response: Response}>}\n     *\n     * @memberof module:workbox-streams\n     */\n\n    function concatenateToResponse(sourcePromises, headersInit) {\n      const {\n        done,\n        stream\n      } = concatenate(sourcePromises);\n      const headers = createHeaders(headersInit);\n      const response = new Response(stream, {\n        headers\n      });\n      return {\n        done,\n        response\n      };\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * This is a utility method that determines whether the current browser supports\n     * the features required to create streamed responses. Currently, it checks if\n     * [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/ReadableStream)\n     * can be created.\n     *\n     * @return {boolean} `true`, if the current browser meets the requirements for\n     * streaming responses, and `false` otherwise.\n     *\n     * @memberof module:workbox-streams\n     */\n\n    function isSupported() {\n      return canConstructReadableStream_js.canConstructReadableStream();\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * A shortcut to create a strategy that could be dropped-in to Workbox's router.\n     *\n     * On browsers that do not support constructing new `ReadableStream`s, this\n     * strategy will automatically wait for all the `sourceFunctions` to complete,\n     * and create a final response that concatenates their values together.\n     *\n     * @param {Array<function({event, request, url, params})>} sourceFunctions\n     * An array of functions similar to {@link module:workbox-routing~handlerCallback}\n     * but that instead return a {@link module:workbox-streams.StreamSource} (or a\n     * Promise which resolves to one).\n     * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n     * `'text/html'` will be used by default.\n     * @return {module:workbox-routing~handlerCallback}\n     * @memberof module:workbox-streams\n     */\n\n    function strategy(sourceFunctions, headersInit) {\n      return async ({\n        event,\n        request,\n        url,\n        params\n      }) => {\n        const sourcePromises = sourceFunctions.map(fn => {\n          // Ensure the return value of the function is always a promise.\n          return Promise.resolve(fn({\n            event,\n            request,\n            url,\n            params\n          }));\n        });\n\n        if (isSupported()) {\n          const {\n            done,\n            response\n          } = concatenateToResponse(sourcePromises, headersInit);\n\n          if (event) {\n            event.waitUntil(done);\n          }\n\n          return response;\n        }\n\n        {\n          logger_js.logger.log(`The current browser doesn't support creating response ` + `streams. Falling back to non-streaming response instead.`);\n        } // Fallback to waiting for everything to finish, and concatenating the\n        // responses.\n\n\n        const blobPartsPromises = sourcePromises.map(async sourcePromise => {\n          const source = await sourcePromise;\n\n          if (source instanceof Response) {\n            return source.blob();\n          } else {\n            // Technically, a `StreamSource` object can include any valid\n            // `BodyInit` type, including `FormData` and `URLSearchParams`, which\n            // cannot be passed to the Blob constructor directly, so we have to\n            // convert them to actual Blobs first.\n            return new Response(source).blob();\n          }\n        });\n        const blobParts = await Promise.all(blobPartsPromises);\n        const headers = createHeaders(headersInit); // Constructing a new Response from a Blob source is well-supported.\n        // So is constructing a new Blob from multiple source Blobs or strings.\n\n        return new Response(new Blob(blobParts), {\n          headers\n        });\n      };\n    }\n\n    exports.concatenate = concatenate;\n    exports.concatenateToResponse = concatenateToResponse;\n    exports.isSupported = isSupported;\n    exports.strategy = strategy;\n\n    return exports;\n\n}({}, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private));\n//# sourceMappingURL=workbox-streams.dev.js.map"},{"path":"/workbox-v5.1.3/workbox-streams.prod.js","content":"this.workbox=this.workbox||{},this.workbox.streams=function(e,n,t){\"use strict\";try{self[\"workbox:streams:5.1.3\"]&&_()}catch(e){}function s(e){const t=e.map(e=>Promise.resolve(e).then(e=>function(e){return e instanceof Response?e.body.getReader():e instanceof ReadableStream?e.getReader():new Response(e).body.getReader()}(e))),s=new n.Deferred;let r=0;const o=new ReadableStream({pull(e){return t[r].then(e=>e.read()).then(n=>{if(n.done)return r++,r>=t.length?(e.close(),void s.resolve()):this.pull(e);e.enqueue(n.value)}).catch(e=>{throw s.reject(e),e})},cancel(){s.resolve()}});return{done:s.promise,stream:o}}function r(e={}){const n=new Headers(e);return n.has(\"content-type\")||n.set(\"content-type\",\"text/html\"),n}function o(e,n){const{done:t,stream:o}=s(e),c=r(n);return{done:t,response:new Response(o,{headers:c})}}function c(){return t.canConstructReadableStream()}return e.concatenate=s,e.concatenateToResponse=o,e.isSupported=c,e.strategy=function(e,n){return async({event:t,request:s,url:a,params:u})=>{const i=e.map(e=>Promise.resolve(e({event:t,request:s,url:a,params:u})));if(c()){const{done:e,response:s}=o(i,n);return t&&t.waitUntil(e),s}const f=i.map(async e=>{const n=await e;return n instanceof Response?n.blob():new Response(n).blob()}),p=await Promise.all(f),w=r(n);return new Response(new Blob(p),{headers:w})}},e}({},workbox.core._private,workbox.core._private);\n//# sourceMappingURL=workbox-streams.prod.js.map"},{"path":"/workbox-v5.1.3/workbox-sw.js","content":"!function(){\"use strict\";try{self[\"workbox:sw:5.1.3\"]&&_()}catch(t){}const t={backgroundSync:\"background-sync\",broadcastUpdate:\"broadcast-update\",cacheableResponse:\"cacheable-response\",core:\"core\",expiration:\"expiration\",googleAnalytics:\"offline-ga\",navigationPreload:\"navigation-preload\",precaching:\"precaching\",rangeRequests:\"range-requests\",routing:\"routing\",strategies:\"strategies\",streams:\"streams\"};self.workbox=new class{constructor(){return this.v={},this.t={debug:\"localhost\"===self.location.hostname,modulePathPrefix:null,modulePathCb:null},this.s=this.t.debug?\"dev\":\"prod\",this.o=!1,new Proxy(this,{get(e,s){if(e[s])return e[s];const o=t[s];return o&&e.loadModule(`workbox-${o}`),e[s]}})}setConfig(t={}){if(this.o)throw new Error(\"Config must be set before accessing workbox.* modules\");Object.assign(this.t,t),this.s=this.t.debug?\"dev\":\"prod\"}loadModule(t){const e=this.i(t);try{importScripts(e),this.o=!0}catch(s){throw console.error(`Unable to import module '${t}' from '${e}'.`),s}}i(t){if(this.t.modulePathCb)return this.t.modulePathCb(t,this.t.debug);let e=[\"https://storage.googleapis.com/workbox-cdn/releases/5.1.3\"];const s=`${t}.${this.s}.js`,o=this.t.modulePathPrefix;return o&&(e=o.split(\"/\"),\"\"===e[e.length-1]&&e.splice(e.length-1,1)),e.push(s),e.join(\"/\")}}}();\n//# sourceMappingURL=workbox-sw.js.map"},{"path":"/workbox-v5.1.3/workbox-window.dev.umd.js","content":"(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = global || self, factory(global.workbox = {}));\n}(this, (function (exports) { 'use strict';\n\n    try {\n      self['workbox:window:5.1.3'] && _();\n    } catch (e) {}\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Sends a data object to a service worker via `postMessage` and resolves with\n     * a response (if any).\n     *\n     * A response can be set in a message handler in the service worker by\n     * calling `event.ports[0].postMessage(...)`, which will resolve the promise\n     * returned by `messageSW()`. If no response is set, the promise will not\n     * resolve.\n     *\n     * @param {ServiceWorker} sw The service worker to send the message to.\n     * @param {Object} data An object to send to the service worker.\n     * @return {Promise<Object|undefined>}\n     * @memberof module:workbox-window\n     */\n\n    function messageSW(sw, data) {\n      return new Promise(function (resolve) {\n        var messageChannel = new MessageChannel();\n\n        messageChannel.port1.onmessage = function (event) {\n          resolve(event.data);\n        };\n\n        sw.postMessage(data, [messageChannel.port2]);\n      });\n    }\n\n    function _defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    function _createClass(Constructor, protoProps, staticProps) {\n      if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) _defineProperties(Constructor, staticProps);\n      return Constructor;\n    }\n\n    function _inheritsLoose(subClass, superClass) {\n      subClass.prototype = Object.create(superClass.prototype);\n      subClass.prototype.constructor = subClass;\n      subClass.__proto__ = superClass;\n    }\n\n    try {\n      self['workbox:core:5.1.3'] && _();\n    } catch (e) {}\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * The Deferred class composes Promises in a way that allows for them to be\n     * resolved or rejected from outside the constructor. In most cases promises\n     * should be used directly, but Deferreds can be necessary when the logic to\n     * resolve a promise must be separate.\n     *\n     * @private\n     */\n\n    var Deferred =\n    /**\n     * Creates a promise and exposes its resolve and reject functions as methods.\n     */\n    function Deferred() {\n      var _this = this;\n\n      this.promise = new Promise(function (resolve, reject) {\n        _this.resolve = resolve;\n        _this.reject = reject;\n      });\n    };\n\n    /*\n      Copyright 2019 Google LLC\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * A helper function that prevents a promise from being flagged as unused.\n     *\n     * @private\n     **/\n\n    function dontWaitFor(promise) {\n      // Effective no-op.\n      promise.then(function () {});\n    }\n\n    /*\n      Copyright 2019 Google LLC\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    var logger =  function () {\n      // Don't overwrite this value if it's already set.\n      // See https://github.com/GoogleChrome/workbox/pull/2284#issuecomment-560470923\n      if (!('__WB_DISABLE_DEV_LOGS' in self)) {\n        self.__WB_DISABLE_DEV_LOGS = false;\n      }\n\n      var inGroup = false;\n      var methodToColorMap = {\n        debug: \"#7f8c8d\",\n        log: \"#2ecc71\",\n        warn: \"#f39c12\",\n        error: \"#c0392b\",\n        groupCollapsed: \"#3498db\",\n        groupEnd: null\n      };\n\n      var print = function print(method, args) {\n        var _console2;\n\n        if (self.__WB_DISABLE_DEV_LOGS) {\n          return;\n        }\n\n        if (method === 'groupCollapsed') {\n          // Safari doesn't print all console.groupCollapsed() arguments:\n          // https://bugs.webkit.org/show_bug.cgi?id=182754\n          if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n            var _console;\n\n            (_console = console)[method].apply(_console, args);\n\n            return;\n          }\n        }\n\n        var styles = [\"background: \" + methodToColorMap[method], \"border-radius: 0.5em\", \"color: white\", \"font-weight: bold\", \"padding: 2px 0.5em\"]; // When in a group, the workbox prefix is not displayed.\n\n        var logPrefix = inGroup ? [] : ['%cworkbox', styles.join(';')];\n\n        (_console2 = console)[method].apply(_console2, logPrefix.concat(args));\n\n        if (method === 'groupCollapsed') {\n          inGroup = true;\n        }\n\n        if (method === 'groupEnd') {\n          inGroup = false;\n        }\n      };\n\n      var api = {};\n      var loggerMethods = Object.keys(methodToColorMap);\n\n      var _loop = function _loop() {\n        var key = _loggerMethods[_i];\n        var method = key;\n\n        api[method] = function () {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          print(method, args);\n        };\n      };\n\n      for (var _i = 0, _loggerMethods = loggerMethods; _i < _loggerMethods.length; _i++) {\n        _loop();\n      }\n\n      return api;\n    }();\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n\n    /**\n     * A minimal `EventTarget` shim.\n     * This is necessary because not all browsers support constructable\n     * `EventTarget`, so using a real `EventTarget` will error.\n     * @private\n     */\n    var WorkboxEventTarget = /*#__PURE__*/function () {\n      function WorkboxEventTarget() {\n        this._eventListenerRegistry = new Map();\n      }\n      /**\n       * @param {string} type\n       * @param {Function} listener\n       * @private\n       */\n\n\n      var _proto = WorkboxEventTarget.prototype;\n\n      _proto.addEventListener = function addEventListener(type, listener) {\n        var foo = this._getEventListenersByType(type);\n\n        foo.add(listener);\n      }\n      /**\n       * @param {string} type\n       * @param {Function} listener\n       * @private\n       */\n      ;\n\n      _proto.removeEventListener = function removeEventListener(type, listener) {\n        this._getEventListenersByType(type).delete(listener);\n      }\n      /**\n       * @param {Object} event\n       * @private\n       */\n      ;\n\n      _proto.dispatchEvent = function dispatchEvent(event) {\n        event.target = this;\n\n        var listeners = this._getEventListenersByType(event.type);\n\n        for (var _iterator = listeners, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n          var _ref;\n\n          if (_isArray) {\n            if (_i >= _iterator.length) break;\n            _ref = _iterator[_i++];\n          } else {\n            _i = _iterator.next();\n            if (_i.done) break;\n            _ref = _i.value;\n          }\n\n          var listener = _ref;\n          listener(event);\n        }\n      }\n      /**\n       * Returns a Set of listeners associated with the passed event type.\n       * If no handlers have been registered, an empty Set is returned.\n       *\n       * @param {string} type The event type.\n       * @return {Set<ListenerCallback>} An array of handler functions.\n       * @private\n       */\n      ;\n\n      _proto._getEventListenersByType = function _getEventListenersByType(type) {\n        if (!this._eventListenerRegistry.has(type)) {\n          this._eventListenerRegistry.set(type, new Set());\n        }\n\n        return this._eventListenerRegistry.get(type);\n      };\n\n      return WorkboxEventTarget;\n    }();\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Returns true if two URLs have the same `.href` property. The URLS can be\n     * relative, and if they are the current location href is used to resolve URLs.\n     *\n     * @private\n     * @param {string} url1\n     * @param {string} url2\n     * @return {boolean}\n     */\n\n    function urlsMatch(url1, url2) {\n      var _location = location,\n          href = _location.href;\n      return new URL(url1, href).href === new URL(url2, href).href;\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * A minimal `Event` subclass shim.\n     * This doesn't *actually* subclass `Event` because not all browsers support\n     * constructable `EventTarget`, and using a real `Event` will error.\n     * @private\n     */\n\n    var WorkboxEvent = function WorkboxEvent(type, props) {\n      this.type = type;\n      Object.assign(this, props);\n    };\n\n    // `skipWaiting()` wasn't called. This 200 amount wasn't scientifically\n    // chosen, but it seems to avoid false positives in my testing.\n\n    function _await(value, then, direct) {\n      if (direct) {\n        return then ? then(value) : value;\n      }\n\n      if (!value || !value.then) {\n        value = Promise.resolve(value);\n      }\n\n      return then ? value.then(then) : value;\n    }\n\n    var WAITING_TIMEOUT_DURATION = 200; // The amount of time after a registration that we can reasonably conclude\n    // that the registration didn't trigger an update.\n\n    function _async(f) {\n      return function () {\n        for (var args = [], i = 0; i < arguments.length; i++) {\n          args[i] = arguments[i];\n        }\n\n        try {\n          return Promise.resolve(f.apply(this, args));\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      };\n    }\n\n    var REGISTRATION_TIMEOUT_DURATION = 60000;\n    /**\n     * A class to aid in handling service worker registration, updates, and\n     * reacting to service worker lifecycle events.\n     *\n     * @fires [message]{@link module:workbox-window.Workbox#message}\n     * @fires [installed]{@link module:workbox-window.Workbox#installed}\n     * @fires [waiting]{@link module:workbox-window.Workbox#waiting}\n     * @fires [controlling]{@link module:workbox-window.Workbox#controlling}\n     * @fires [activated]{@link module:workbox-window.Workbox#activated}\n     * @fires [redundant]{@link module:workbox-window.Workbox#redundant}\n     * @fires [externalinstalled]{@link module:workbox-window.Workbox#externalinstalled}\n     * @fires [externalwaiting]{@link module:workbox-window.Workbox#externalwaiting}\n     * @fires [externalactivated]{@link module:workbox-window.Workbox#externalactivated}\n     * @memberof module:workbox-window\n     */\n\n    function _empty() {}\n\n    var Workbox = /*#__PURE__*/function (_WorkboxEventTarget) {\n      _inheritsLoose(Workbox, _WorkboxEventTarget);\n\n      /**\n       * Creates a new Workbox instance with a script URL and service worker\n       * options. The script URL and options are the same as those used when\n       * calling `navigator.serviceWorker.register(scriptURL, options)`. See:\n       * https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register\n       *\n       * @param {string} scriptURL The service worker script associated with this\n       *     instance.\n       * @param {Object} [registerOptions] The service worker options associated\n       *     with this instance.\n       */\n      function Workbox(scriptURL, registerOptions) {\n        var _this;\n\n        if (registerOptions === void 0) {\n          registerOptions = {};\n        }\n\n        _this = _WorkboxEventTarget.call(this) || this;\n        _this._registerOptions = {};\n        _this._updateFoundCount = 0; // Deferreds we can resolve later.\n\n        _this._swDeferred = new Deferred();\n        _this._activeDeferred = new Deferred();\n        _this._controllingDeferred = new Deferred();\n        _this._registrationTime = 0;\n        _this._ownSWs = new Set();\n        /**\n         * @private\n         */\n\n        _this._onUpdateFound = function () {\n          // `this._registration` will never be `undefined` after an update is found.\n          var registration = _this._registration;\n          var installingSW = registration.installing; // If the script URL passed to `navigator.serviceWorker.register()` is\n          // different from the current controlling SW's script URL, we know any\n          // successful registration calls will trigger an `updatefound` event.\n          // But if the registered script URL is the same as the current controlling\n          // SW's script URL, we'll only get an `updatefound` event if the file\n          // changed since it was last registered. This can be a problem if the user\n          // opens up the same page in a different tab, and that page registers\n          // a SW that triggers an update. It's a problem because this page has no\n          // good way of knowing whether the `updatefound` event came from the SW\n          // script it registered or from a registration attempt made by a newer\n          // version of the page running in another tab.\n          // To minimize the possibility of a false positive, we use the logic here:\n\n          var updateLikelyTriggeredExternally = // Since we enforce only calling `register()` once, and since we don't\n          // add the `updatefound` event listener until the `register()` call, if\n          // `_updateFoundCount` is > 0 then it means this method has already\n          // been called, thus this SW must be external\n          _this._updateFoundCount > 0 || // If the script URL of the installing SW is different from this\n          // instance's script URL, we know it's definitely not from our\n          // registration.\n          !urlsMatch(installingSW.scriptURL, _this._scriptURL) || // If all of the above are false, then we use a time-based heuristic:\n          // Any `updatefound` event that occurs long after our registration is\n          // assumed to be external.\n          performance.now() > _this._registrationTime + REGISTRATION_TIMEOUT_DURATION ? // If any of the above are not true, we assume the update was\n          // triggered by this instance.\n          true : false;\n\n          if (updateLikelyTriggeredExternally) {\n            _this._externalSW = installingSW;\n            registration.removeEventListener('updatefound', _this._onUpdateFound);\n          } else {\n            // If the update was not triggered externally we know the installing\n            // SW is the one we registered, so we set it.\n            _this._sw = installingSW;\n\n            _this._ownSWs.add(installingSW);\n\n            _this._swDeferred.resolve(installingSW); // The `installing` state isn't something we have a dedicated\n            // callback for, but we do log messages for it in development.\n\n\n            {\n              if (navigator.serviceWorker.controller) {\n                logger.log('Updated service worker found. Installing now...');\n              } else {\n                logger.log('Service worker is installing...');\n              }\n            }\n          } // Increment the `updatefound` count, so future invocations of this\n          // method can be sure they were triggered externally.\n\n\n          ++_this._updateFoundCount; // Add a `statechange` listener regardless of whether this update was\n          // triggered externally, since we have callbacks for both.\n\n          installingSW.addEventListener('statechange', _this._onStateChange);\n        };\n        /**\n         * @private\n         * @param {Event} originalEvent\n         */\n\n\n        _this._onStateChange = function (originalEvent) {\n          // `this._registration` will never be `undefined` after an update is found.\n          var registration = _this._registration;\n          var sw = originalEvent.target;\n          var state = sw.state;\n          var isExternal = sw === _this._externalSW;\n          var eventPrefix = isExternal ? 'external' : '';\n          var eventProps = {\n            sw: sw,\n            originalEvent: originalEvent\n          };\n\n          if (!isExternal && _this._isUpdate) {\n            eventProps.isUpdate = true;\n          }\n\n          _this.dispatchEvent(new WorkboxEvent(eventPrefix + state, eventProps));\n\n          if (state === 'installed') {\n            // This timeout is used to ignore cases where the service worker calls\n            // `skipWaiting()` in the install event, thus moving it directly in the\n            // activating state. (Since all service workers *must* go through the\n            // waiting phase, the only way to detect `skipWaiting()` called in the\n            // install event is to observe that the time spent in the waiting phase\n            // is very short.)\n            // NOTE: we don't need separate timeouts for the own and external SWs\n            // since they can't go through these phases at the same time.\n            _this._waitingTimeout = self.setTimeout(function () {\n              // Ensure the SW is still waiting (it may now be redundant).\n              if (state === 'installed' && registration.waiting === sw) {\n                _this.dispatchEvent(new WorkboxEvent(eventPrefix + 'waiting', eventProps));\n\n                {\n                  if (isExternal) {\n                    logger.warn('An external service worker has installed but is ' + 'waiting for this client to close before activating...');\n                  } else {\n                    logger.warn('The service worker has installed but is waiting ' + 'for existing clients to close before activating...');\n                  }\n                }\n              }\n            }, WAITING_TIMEOUT_DURATION);\n          } else if (state === 'activating') {\n            clearTimeout(_this._waitingTimeout);\n\n            if (!isExternal) {\n              _this._activeDeferred.resolve(sw);\n            }\n          }\n\n          {\n            switch (state) {\n              case 'installed':\n                if (isExternal) {\n                  logger.warn('An external service worker has installed. ' + 'You may want to suggest users reload this page.');\n                } else {\n                  logger.log('Registered service worker installed.');\n                }\n\n                break;\n\n              case 'activated':\n                if (isExternal) {\n                  logger.warn('An external service worker has activated.');\n                } else {\n                  logger.log('Registered service worker activated.');\n\n                  if (sw !== navigator.serviceWorker.controller) {\n                    logger.warn('The registered service worker is active but ' + 'not yet controlling the page. Reload or run ' + '`clients.claim()` in the service worker.');\n                  }\n                }\n\n                break;\n\n              case 'redundant':\n                if (sw === _this._compatibleControllingSW) {\n                  logger.log('Previously controlling service worker now redundant!');\n                } else if (!isExternal) {\n                  logger.log('Registered service worker now redundant!');\n                }\n\n                break;\n            }\n          }\n        };\n        /**\n         * @private\n         * @param {Event} originalEvent\n         */\n\n\n        _this._onControllerChange = function (originalEvent) {\n          var sw = _this._sw;\n\n          if (sw === navigator.serviceWorker.controller) {\n            _this.dispatchEvent(new WorkboxEvent('controlling', {\n              sw: sw,\n              originalEvent: originalEvent,\n              isUpdate: _this._isUpdate\n            }));\n\n            {\n              logger.log('Registered service worker now controlling this page.');\n            }\n\n            _this._controllingDeferred.resolve(sw);\n          }\n        };\n        /**\n         * @private\n         * @param {Event} originalEvent\n         */\n\n\n        _this._onMessage = _async(function (originalEvent) {\n          var data = originalEvent.data,\n              source = originalEvent.source; // Wait until there's an \"own\" service worker. This is used to buffer\n          // `message` events that may be received prior to calling `register()`.\n\n          return _await(_this.getSW(), function () {\n            if (_this._ownSWs.has(source)) {\n              _this.dispatchEvent(new WorkboxEvent('message', {\n                data: data,\n                sw: source,\n                originalEvent: originalEvent\n              }));\n            }\n          }); // If the service worker that sent the message is in the list of own\n          // service workers for this instance, dispatch a `message` event.\n          // NOTE: we check for all previously owned service workers rather than\n          // just the current one because some messages (e.g. cache updates) use\n          // a timeout when sent and may be delayed long enough for a service worker\n          // update to be found.\n        });\n        _this._scriptURL = scriptURL;\n        _this._registerOptions = registerOptions; // Add a message listener immediately since messages received during\n        // page load are buffered only until the DOMContentLoaded event:\n        // https://github.com/GoogleChrome/workbox/issues/2202\n\n        navigator.serviceWorker.addEventListener('message', _this._onMessage);\n        return _this;\n      }\n      /**\n       * Registers a service worker for this instances script URL and service\n       * worker options. By default this method delays registration until after\n       * the window has loaded.\n       *\n       * @param {Object} [options]\n       * @param {Function} [options.immediate=false] Setting this to true will\n       *     register the service worker immediately, even if the window has\n       *     not loaded (not recommended).\n       */\n\n\n      var _proto = Workbox.prototype;\n\n      _proto.register = function register(_temp) {\n        var _ref = _temp === void 0 ? {} : _temp,\n            _ref$immediate = _ref.immediate,\n            immediate = _ref$immediate === void 0 ? false : _ref$immediate;\n\n        try {\n          var _this3 = this;\n\n          if (\"dev\" !== 'production') {\n            if (_this3._registrationTime) {\n              logger.error('Cannot re-register a Workbox instance after it has ' + 'been registered. Create a new instance instead.');\n              return;\n            }\n          }\n\n          return _invoke(function () {\n            if (!immediate && document.readyState !== 'complete') {\n              return _awaitIgnored(new Promise(function (res) {\n                return window.addEventListener('load', res);\n              }));\n            }\n          }, function () {\n            // Set this flag to true if any service worker was controlling the page\n            // at registration time.\n            _this3._isUpdate = Boolean(navigator.serviceWorker.controller); // Before registering, attempt to determine if a SW is already controlling\n            // the page, and if that SW script (and version, if specified) matches this\n            // instance's script.\n\n            _this3._compatibleControllingSW = _this3._getControllingSWIfCompatible();\n            return _await(_this3._registerScript(), function (_this2$_registerScrip) {\n              _this3._registration = _this2$_registerScrip;\n\n              // If we have a compatible controller, store the controller as the \"own\"\n              // SW, resolve active/controlling deferreds and add necessary listeners.\n              if (_this3._compatibleControllingSW) {\n                _this3._sw = _this3._compatibleControllingSW;\n\n                _this3._activeDeferred.resolve(_this3._compatibleControllingSW);\n\n                _this3._controllingDeferred.resolve(_this3._compatibleControllingSW);\n\n                _this3._compatibleControllingSW.addEventListener('statechange', _this3._onStateChange, {\n                  once: true\n                });\n              } // If there's a waiting service worker with a matching URL before the\n              // `updatefound` event fires, it likely means that this site is open\n              // in another tab, or the user refreshed the page (and thus the previous\n              // page wasn't fully unloaded before this page started loading).\n              // https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#waiting\n\n\n              var waitingSW = _this3._registration.waiting;\n\n              if (waitingSW && urlsMatch(waitingSW.scriptURL, _this3._scriptURL)) {\n                // Store the waiting SW as the \"own\" Sw, even if it means overwriting\n                // a compatible controller.\n                _this3._sw = waitingSW; // Run this in the next microtask, so any code that adds an event\n                // listener after awaiting `register()` will get this event.\n\n                dontWaitFor(Promise.resolve().then(function () {\n                  _this3.dispatchEvent(new WorkboxEvent('waiting', {\n                    sw: waitingSW,\n                    wasWaitingBeforeRegister: true\n                  }));\n\n                  if (\"dev\" !== 'production') {\n                    logger.warn('A service worker was already waiting to activate ' + 'before this script was registered...');\n                  }\n                }));\n              } // If an \"own\" SW is already set, resolve the deferred.\n\n\n              if (_this3._sw) {\n                _this3._swDeferred.resolve(_this3._sw);\n\n                _this3._ownSWs.add(_this3._sw);\n              }\n\n              if (\"dev\" !== 'production') {\n                logger.log('Successfully registered service worker.', _this3._scriptURL);\n\n                if (navigator.serviceWorker.controller) {\n                  if (_this3._compatibleControllingSW) {\n                    logger.debug('A service worker with the same script URL ' + 'is already controlling this page.');\n                  } else {\n                    logger.debug('A service worker with a different script URL is ' + 'currently controlling the page. The browser is now fetching ' + 'the new script now...');\n                  }\n                }\n\n                var currentPageIsOutOfScope = function currentPageIsOutOfScope() {\n                  var scopeURL = new URL(_this3._registerOptions.scope || _this3._scriptURL, document.baseURI);\n                  var scopeURLBasePath = new URL('./', scopeURL.href).pathname;\n                  return !location.pathname.startsWith(scopeURLBasePath);\n                };\n\n                if (currentPageIsOutOfScope()) {\n                  logger.warn('The current page is not in scope for the registered ' + 'service worker. Was this a mistake?');\n                }\n              }\n\n              _this3._registration.addEventListener('updatefound', _this3._onUpdateFound);\n\n              navigator.serviceWorker.addEventListener('controllerchange', _this3._onControllerChange, {\n                once: true\n              });\n              return _this3._registration;\n            });\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n      /**\n       * Checks for updates of the registered service worker.\n       */\n      ;\n\n      _proto.update = function update() {\n        try {\n          var _this5 = this;\n\n          if (!_this5._registration) {\n            if (\"dev\" !== 'production') {\n              logger.error('Cannot update a Workbox instance without ' + 'being registered. Register the Workbox instance first.');\n            }\n\n            return;\n          } // Try to update registration\n\n\n          return _awaitIgnored(_this5._registration.update());\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n      /**\n       * Resolves to the service worker registered by this instance as soon as it\n       * is active. If a service worker was already controlling at registration\n       * time then it will resolve to that if the script URLs (and optionally\n       * script versions) match, otherwise it will wait until an update is found\n       * and activates.\n       *\n       * @return {Promise<ServiceWorker>}\n       */\n      ;\n\n      /**\n       * Resolves with a reference to a service worker that matches the script URL\n       * of this instance, as soon as it's available.\n       *\n       * If, at registration time, there's already an active or waiting service\n       * worker with a matching script URL, it will be used (with the waiting\n       * service worker taking precedence over the active service worker if both\n       * match, since the waiting service worker would have been registered more\n       * recently).\n       * If there's no matching active or waiting service worker at registration\n       * time then the promise will not resolve until an update is found and starts\n       * installing, at which point the installing service worker is used.\n       *\n       * @return {Promise<ServiceWorker>}\n       */\n      _proto.getSW = function getSW() {\n        try {\n          var _this7 = this;\n\n          // If `this._sw` is set, resolve with that as we want `getSW()` to\n          // return the correct (new) service worker if an update is found.\n          return _this7._sw !== undefined ? _this7._sw : _this7._swDeferred.promise;\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n      /**\n       * Sends the passed data object to the service worker registered by this\n       * instance (via [`getSW()`]{@link module:workbox-window.Workbox#getSW}) and resolves\n       * with a response (if any).\n       *\n       * A response can be set in a message handler in the service worker by\n       * calling `event.ports[0].postMessage(...)`, which will resolve the promise\n       * returned by `messageSW()`. If no response is set, the promise will never\n       * resolve.\n       *\n       * @param {Object} data An object to send to the service worker\n       * @return {Promise<Object>}\n       */\n      ;\n\n      _proto.messageSW = function messageSW$1(data) {\n        try {\n          var _this9 = this;\n\n          return _await(_this9.getSW(), function (sw) {\n            return messageSW(sw, data);\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n      /**\n       * Checks for a service worker already controlling the page and returns\n       * it if its script URL matches.\n       *\n       * @private\n       * @return {ServiceWorker|undefined}\n       */\n      ;\n\n      _proto._getControllingSWIfCompatible = function _getControllingSWIfCompatible() {\n        var controller = navigator.serviceWorker.controller;\n\n        if (controller && urlsMatch(controller.scriptURL, this._scriptURL)) {\n          return controller;\n        } else {\n          return undefined;\n        }\n      }\n      /**\n       * Registers a service worker for this instances script URL and register\n       * options and tracks the time registration was complete.\n       *\n       * @private\n       */\n      ;\n\n      _proto._registerScript = function _registerScript() {\n        try {\n          var _this11 = this;\n\n          return _catch(function () {\n            return _await(navigator.serviceWorker.register(_this11._scriptURL, _this11._registerOptions), function (reg) {\n              // Keep track of when registration happened, so it can be used in the\n              // `this._onUpdateFound` heuristic. Also use the presence of this\n              // property as a way to see if `.register()` has been called.\n              _this11._registrationTime = performance.now();\n              return reg;\n            });\n          }, function (error) {\n            if (\"dev\" !== 'production') {\n              logger.error(error);\n            } // Re-throw the error.\n\n\n            throw error;\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      };\n\n      _createClass(Workbox, [{\n        key: \"active\",\n        get: function get() {\n          return this._activeDeferred.promise;\n        }\n        /**\n         * Resolves to the service worker registered by this instance as soon as it\n         * is controlling the page. If a service worker was already controlling at\n         * registration time then it will resolve to that if the script URLs (and\n         * optionally script versions) match, otherwise it will wait until an update\n         * is found and starts controlling the page.\n         * Note: the first time a service worker is installed it will active but\n         * not start controlling the page unless `clients.claim()` is called in the\n         * service worker.\n         *\n         * @return {Promise<ServiceWorker>}\n         */\n\n      }, {\n        key: \"controlling\",\n        get: function get() {\n          return this._controllingDeferred.promise;\n        }\n      }]);\n\n      return Workbox;\n    }(WorkboxEventTarget);\n\n    function _awaitIgnored(value, direct) {\n      if (!direct) {\n        return value && value.then ? value.then(_empty) : Promise.resolve();\n      }\n    } // The jsdoc comments below outline the events this instance may dispatch:\n    // -----------------------------------------------------------------------\n\n    /**\n     * The `message` event is dispatched any time a `postMessage` is received.\n     *\n     * @event module:workbox-window.Workbox#message\n     * @type {WorkboxEvent}\n     * @property {*} data The `data` property from the original `message` event.\n     * @property {Event} originalEvent The original [`message`]{@link https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent}\n     *     event.\n     * @property {string} type `message`.\n     * @property {Workbox} target The `Workbox` instance.\n     */\n\n    /**\n     * The `installed` event is dispatched if the state of a\n     * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n     * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n     * changes to `installed`.\n     *\n     * Then can happen either the very first time a service worker is installed,\n     * or after an update to the current service worker is found. In the case\n     * of an update being found, the event's `isUpdate` property will be `true`.\n     *\n     * @event module:workbox-window.Workbox#installed\n     * @type {WorkboxEvent}\n     * @property {ServiceWorker} sw The service worker instance.\n     * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n     *     event.\n     * @property {boolean|undefined} isUpdate True if a service worker was already\n     *     controlling when this `Workbox` instance called `register()`.\n     * @property {string} type `installed`.\n     * @property {Workbox} target The `Workbox` instance.\n     */\n\n    /**\n     * The `waiting` event is dispatched if the state of a\n     * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n     * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n     * changes to `installed` and then doesn't immediately change to `activating`.\n     * It may also be dispatched if a service worker with the same\n     * [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}\n     * was already waiting when the [`register()`]{@link module:workbox-window.Workbox#register}\n     * method was called.\n     *\n     * @event module:workbox-window.Workbox#waiting\n     * @type {WorkboxEvent}\n     * @property {ServiceWorker} sw The service worker instance.\n     * @property {Event|undefined} originalEvent The original\n     *    [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n     *     event, or `undefined` in the case where the service worker was waiting\n     *     to before `.register()` was called.\n     * @property {boolean|undefined} isUpdate True if a service worker was already\n     *     controlling when this `Workbox` instance called `register()`.\n     * @property {boolean|undefined} wasWaitingBeforeRegister True if a service worker with\n     *     a matching `scriptURL` was already waiting when this `Workbox`\n     *     instance called `register()`.\n     * @property {string} type `waiting`.\n     * @property {Workbox} target The `Workbox` instance.\n     */\n\n    /**\n     * The `controlling` event is dispatched if a\n     * [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}\n     * fires on the service worker [container]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer}\n     * and the [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}\n     * of the new [controller]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/controller}\n     * matches the `scriptURL` of the `Workbox` instance's\n     * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}.\n     *\n     * @event module:workbox-window.Workbox#controlling\n     * @type {WorkboxEvent}\n     * @property {ServiceWorker} sw The service worker instance.\n     * @property {Event} originalEvent The original [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}\n     *     event.\n     * @property {boolean|undefined} isUpdate True if a service worker was already\n     *     controlling when this service worker was registered.\n     * @property {string} type `controlling`.\n     * @property {Workbox} target The `Workbox` instance.\n     */\n\n    /**\n     * The `activated` event is dispatched if the state of a\n     * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n     * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n     * changes to `activated`.\n     *\n     * @event module:workbox-window.Workbox#activated\n     * @type {WorkboxEvent}\n     * @property {ServiceWorker} sw The service worker instance.\n     * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n     *     event.\n     * @property {boolean|undefined} isUpdate True if a service worker was already\n     *     controlling when this `Workbox` instance called `register()`.\n     * @property {string} type `activated`.\n     * @property {Workbox} target The `Workbox` instance.\n     */\n\n    /**\n     * The `redundant` event is dispatched if the state of a\n     * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n     * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n     * changes to `redundant`.\n     *\n     * @event module:workbox-window.Workbox#redundant\n     * @type {WorkboxEvent}\n     * @property {ServiceWorker} sw The service worker instance.\n     * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n     *     event.\n     * @property {boolean|undefined} isUpdate True if a service worker was already\n     *     controlling when this `Workbox` instance called `register()`.\n     * @property {string} type `redundant`.\n     * @property {Workbox} target The `Workbox` instance.\n     */\n\n    /**\n     * The `externalinstalled` event is dispatched if the state of an\n     * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}\n     * changes to `installed`.\n     *\n     * @event module:workbox-window.Workbox#externalinstalled\n     * @type {WorkboxEvent}\n     * @property {ServiceWorker} sw The service worker instance.\n     * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n     *     event.\n     * @property {string} type `externalinstalled`.\n     * @property {Workbox} target The `Workbox` instance.\n     */\n\n    /**\n     * The `externalwaiting` event is dispatched if the state of an\n     * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}\n     * changes to `waiting`.\n     *\n     * @event module:workbox-window.Workbox#externalwaiting\n     * @type {WorkboxEvent}\n     * @property {ServiceWorker} sw The service worker instance.\n     * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n     *     event.\n     * @property {string} type `externalwaiting`.\n     * @property {Workbox} target The `Workbox` instance.\n     */\n\n    /**\n     * The `externalactivated` event is dispatched if the state of an\n     * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}\n     * changes to `activated`.\n     *\n     * @event module:workbox-window.Workbox#externalactivated\n     * @type {WorkboxEvent}\n     * @property {ServiceWorker} sw The service worker instance.\n     * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n     *     event.\n     * @property {string} type `externalactivated`.\n     * @property {Workbox} target The `Workbox` instance.\n     */\n\n\n    function _invoke(body, then) {\n      var result = body();\n\n      if (result && result.then) {\n        return result.then(then);\n      }\n\n      return then(result);\n    }\n\n    function _catch(body, recover) {\n      try {\n        var result = body();\n      } catch (e) {\n        return recover(e);\n      }\n\n      if (result && result.then) {\n        return result.then(void 0, recover);\n      }\n\n      return result;\n    }\n\n    exports.Workbox = Workbox;\n    exports.messageSW = messageSW;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=workbox-window.dev.umd.js.map"},{"path":"/workbox-v5.1.3/workbox-window.prod.umd.js","content":"!function(n,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?t(exports):\"function\"==typeof define&&define.amd?define([\"exports\"],t):t((n=n||self).workbox={})}(this,(function(n){\"use strict\";try{self[\"workbox:window:5.1.3\"]&&_()}catch(n){}function t(n,t){return new Promise((function(r){var e=new MessageChannel;e.port1.onmessage=function(n){r(n.data)},n.postMessage(t,[e.port2])}))}function r(n,t){for(var r=0;r<t.length;r++){var e=t[r];e.enumerable=e.enumerable||!1,e.configurable=!0,\"value\"in e&&(e.writable=!0),Object.defineProperty(n,e.key,e)}}try{self[\"workbox:core:5.1.3\"]&&_()}catch(n){}var e=function(){var n=this;this.promise=new Promise((function(t,r){n.resolve=t,n.reject=r}))};function i(n,t){var r=location.href;return new URL(n,r).href===new URL(t,r).href}var o=function(n,t){this.type=n,Object.assign(this,t)};function u(n,t,r){return r?t?t(n):n:(n&&n.then||(n=Promise.resolve(n)),t?n.then(t):n)}function c(){}var a=function(n){var c,a;function s(t,r){var c,a;return void 0===r&&(r={}),(c=n.call(this)||this).t={},c.i=0,c.o=new e,c.u=new e,c.s=new e,c.v=0,c.h=new Set,c.l=function(){var n=c.g,t=n.installing;c.i>0||!i(t.scriptURL,c.m)||performance.now()>c.v+6e4?(c.p=t,n.removeEventListener(\"updatefound\",c.l)):(c.P=t,c.h.add(t),c.o.resolve(t)),++c.i,t.addEventListener(\"statechange\",c.j)},c.j=function(n){var t=c.g,r=n.target,e=r.state,i=r===c.p,u=i?\"external\":\"\",a={sw:r,originalEvent:n};!i&&c.k&&(a.isUpdate=!0),c.dispatchEvent(new o(u+e,a)),\"installed\"===e?c.O=self.setTimeout((function(){\"installed\"===e&&t.waiting===r&&c.dispatchEvent(new o(u+\"waiting\",a))}),200):\"activating\"===e&&(clearTimeout(c.O),i||c.u.resolve(r))},c._=function(n){var t=c.P;t===navigator.serviceWorker.controller&&(c.dispatchEvent(new o(\"controlling\",{sw:t,originalEvent:n,isUpdate:c.k})),c.s.resolve(t))},c.M=(a=function(n){var t=n.data,r=n.source;return u(c.getSW(),(function(){c.h.has(r)&&c.dispatchEvent(new o(\"message\",{data:t,sw:r,originalEvent:n}))}))},function(){for(var n=[],t=0;t<arguments.length;t++)n[t]=arguments[t];try{return Promise.resolve(a.apply(this,n))}catch(n){return Promise.reject(n)}}),c.m=t,c.t=r,navigator.serviceWorker.addEventListener(\"message\",c.M),c}a=n,(c=s).prototype=Object.create(a.prototype),c.prototype.constructor=c,c.__proto__=a;var v,h,l,w=s.prototype;return w.register=function(n){var t=(void 0===n?{}:n).immediate,r=void 0!==t&&t;try{var e=this;return function(n,t){var r=n();if(r&&r.then)return r.then(t);return t(r)}((function(){if(!r&&\"complete\"!==document.readyState)return f(new Promise((function(n){return window.addEventListener(\"load\",n)})))}),(function(){return e.k=Boolean(navigator.serviceWorker.controller),e.R=e.S(),u(e.U(),(function(n){e.g=n,e.R&&(e.P=e.R,e.u.resolve(e.R),e.s.resolve(e.R),e.R.addEventListener(\"statechange\",e.j,{once:!0}));var t=e.g.waiting;return t&&i(t.scriptURL,e.m)&&(e.P=t,Promise.resolve().then((function(){e.dispatchEvent(new o(\"waiting\",{sw:t,wasWaitingBeforeRegister:!0}))})).then((function(){}))),e.P&&(e.o.resolve(e.P),e.h.add(e.P)),e.g.addEventListener(\"updatefound\",e.l),navigator.serviceWorker.addEventListener(\"controllerchange\",e._,{once:!0}),e.g}))}))}catch(n){return Promise.reject(n)}},w.update=function(){try{return this.g?f(this.g.update()):void 0}catch(n){return Promise.reject(n)}},w.getSW=function(){try{return void 0!==this.P?this.P:this.o.promise}catch(n){return Promise.reject(n)}},w.messageSW=function(n){try{return u(this.getSW(),(function(r){return t(r,n)}))}catch(n){return Promise.reject(n)}},w.S=function(){var n=navigator.serviceWorker.controller;return n&&i(n.scriptURL,this.m)?n:void 0},w.U=function(){try{var n=this;return function(n,t){try{var r=n()}catch(n){return t(n)}if(r&&r.then)return r.then(void 0,t);return r}((function(){return u(navigator.serviceWorker.register(n.m,n.t),(function(t){return n.v=performance.now(),t}))}),(function(n){throw n}))}catch(n){return Promise.reject(n)}},v=s,(h=[{key:\"active\",get:function(){return this.u.promise}},{key:\"controlling\",get:function(){return this.s.promise}}])&&r(v.prototype,h),l&&r(v,l),s}(function(){function n(){this.B=new Map}var t=n.prototype;return t.addEventListener=function(n,t){this.L(n).add(t)},t.removeEventListener=function(n,t){this.L(n).delete(t)},t.dispatchEvent=function(n){n.target=this;var t=this.L(n.type),r=Array.isArray(t),e=0;for(t=r?t:t[Symbol.iterator]();;){var i;if(r){if(e>=t.length)break;i=t[e++]}else{if((e=t.next()).done)break;i=e.value}i(n)}},t.L=function(n){return this.B.has(n)||this.B.set(n,new Set),this.B.get(n)},n}());function f(n,t){if(!t)return n&&n.then?n.then(c):Promise.resolve()}n.Workbox=a,n.messageSW=t,Object.defineProperty(n,\"__esModule\",{value:!0})}));\n//# sourceMappingURL=workbox-window.prod.umd.js.map"}]
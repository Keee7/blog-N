this.workbox=this.workbox||{},this.workbox.precaching=function(e,t,r,a,s,c,o,n,i,l,h){"use strict";try{self["workbox:precaching:7.0.0"]&&_()}catch(e){}function u(e){if(!e)throw new s.WorkboxError("add-to-cache-list-unexpected-type",{entry:e});if("string"==typeof e){const t=new URL(e,location.href);return{cacheKey:t.href,url:t.href}}const{revision:t,url:r}=e;if(!r)throw new s.WorkboxError("add-to-cache-list-unexpected-type",{entry:e});if(!t){const e=new URL(r,location.href);return{cacheKey:e.href,url:e.href}}const a=new URL(r,location.href),c=new URL(r,location.href);return a.searchParams.set("__WB_REVISION__",t),{cacheKey:a.href,url:c.href}}class g{constructor(){this.updatedURLs=[],this.notUpdatedURLs=[],this.handlerWillStart=async({request:e,state:t})=>{t&&(t.originalRequest=e)},this.cachedResponseWillBeUsed=async({event:e,state:t,cachedResponse:r})=>{if("install"===e.type&&t&&t.originalRequest&&t.originalRequest instanceof Request){const e=t.originalRequest.url;r?this.notUpdatedURLs.push(e):this.updatedURLs.push(e)}return r}}}class d{constructor({precacheController:e}){this.cacheKeyWillBeUsed=async({request:e,params:t})=>{const r=(null==t?void 0:t.cacheKey)||this._precacheController.getCacheKeyForURL(e.url);return r?new Request(r,{headers:e.headers}):e},this._precacheController=e}}function p(e){const t=e.length;t>0&&(a.logger.groupCollapsed(`During precaching cleanup, ${t} cached request${1===t?" was":"s were"} deleted.`),((e,t)=>{a.logger.groupCollapsed(e);for(const e of t)a.logger.log(e);a.logger.groupEnd()})("Deleted Cache Requests",e),a.logger.groupEnd())}function f(e,t){if(0!==t.length){a.logger.groupCollapsed(e);for(const e of t)a.logger.log(e);a.logger.groupEnd()}}class y extends i.Strategy{constructor(e={}){e.cacheName=r.cacheNames.getPrecacheName(e.cacheName),super(e),this._fallbackToNetwork=!1!==e.fallbackToNetwork,this.plugins.push(y.copyRedirectedCacheableResponsesPlugin)}async _handle(e,t){const r=await t.cacheMatch(e);return r||(t.event&&"install"===t.event.type?await this._handleInstall(e,t):await this._handleFetch(e,t))}async _handleFetch(e,t){let r;const c=t.params||{};if(!this._fallbackToNetwork)throw new s.WorkboxError("missing-precache-entry",{cacheName:this.cacheName,url:e.url});{a.logger.warn(`The precached response for ${n.getFriendlyURL(e.url)} in ${this.cacheName} was not found. Falling back to the network.`);const s=c.integrity,o=e.integrity,i=!o||o===s;if(r=await t.fetch(new Request(e,{integrity:"no-cors"!==e.mode?o||s:void 0})),s&&i&&"no-cors"!==e.mode){this._useDefaultCacheabilityPluginIfNeeded();await t.cachePut(e,r.clone())&&a.logger.log(`A response for ${n.getFriendlyURL(e.url)} was used to "repair" the precache.`)}}{const s=c.cacheKey||await t.getCacheKey(e,"read");a.logger.groupCollapsed("Precaching is responding to: "+n.getFriendlyURL(e.url)),a.logger.log(`Serving the precached url: ${n.getFriendlyURL(s instanceof Request?s.url:s)}`),a.logger.groupCollapsed("View request details here."),a.logger.log(e),a.logger.groupEnd(),a.logger.groupCollapsed("View response details here."),a.logger.log(r),a.logger.groupEnd(),a.logger.groupEnd()}return r}async _handleInstall(e,t){this._useDefaultCacheabilityPluginIfNeeded();const r=await t.fetch(e);if(!await t.cachePut(e,r.clone()))throw new s.WorkboxError("bad-precaching-response",{url:e.url,status:r.status});return r}_useDefaultCacheabilityPluginIfNeeded(){let e=null,t=0;for(const[r,a]of this.plugins.entries())a!==y.copyRedirectedCacheableResponsesPlugin&&(a===y.defaultPrecacheCacheabilityPlugin&&(e=r),a.cacheWillUpdate&&t++);0===t?this.plugins.push(y.defaultPrecacheCacheabilityPlugin):t>1&&null!==e&&this.plugins.splice(e,1)}}y.defaultPrecacheCacheabilityPlugin={cacheWillUpdate:async({response:e})=>!e||e.status>=400?null:e},y.copyRedirectedCacheableResponsesPlugin={cacheWillUpdate:async({response:e})=>e.redirected?await o.copyResponse(e):e};class w{constructor({cacheName:e,plugins:t=[],fallbackToNetwork:a=!0}={}){this._urlsToCacheKeys=new Map,this._urlsToCacheModes=new Map,this._cacheKeysToIntegrities=new Map,this._strategy=new y({cacheName:r.cacheNames.getPrecacheName(e),plugins:[...t,new d({precacheController:this})],fallbackToNetwork:a}),this.install=this.install.bind(this),this.activate=this.activate.bind(this)}get strategy(){return this._strategy}precache(e){this.addToCacheList(e),this._installAndActiveListenersAdded||(self.addEventListener("install",this.install),self.addEventListener("activate",this.activate),this._installAndActiveListenersAdded=!0)}addToCacheList(e){t.assert.isArray(e,{moduleName:"workbox-precaching",className:"PrecacheController",funcName:"addToCacheList",paramName:"entries"});const r=[];for(const t of e){"string"==typeof t?r.push(t):t&&void 0===t.revision&&r.push(t.url);const{cacheKey:e,url:c}=u(t),o="string"!=typeof t&&t.revision?"reload":"default";if(this._urlsToCacheKeys.has(c)&&this._urlsToCacheKeys.get(c)!==e)throw new s.WorkboxError("add-to-cache-list-conflicting-entries",{firstEntry:this._urlsToCacheKeys.get(c),secondEntry:e});if("string"!=typeof t&&t.integrity){if(this._cacheKeysToIntegrities.has(e)&&this._cacheKeysToIntegrities.get(e)!==t.integrity)throw new s.WorkboxError("add-to-cache-list-conflicting-integrities",{url:c});this._cacheKeysToIntegrities.set(e,t.integrity)}if(this._urlsToCacheKeys.set(c,e),this._urlsToCacheModes.set(c,o),r.length>0){const e=`Workbox is precaching URLs without revision info: ${r.join(", ")}\nThis is generally NOT safe. Learn more at https://bit.ly/wb-precache`;a.logger.warn(e)}}}install(e){return c.waitUntil(e,(async()=>{const t=new g;this.strategy.plugins.push(t);for(const[t,r]of this._urlsToCacheKeys){const a=this._cacheKeysToIntegrities.get(r),s=this._urlsToCacheModes.get(t),c=new Request(t,{integrity:a,cache:s,credentials:"same-origin"});await Promise.all(this.strategy.handleAll({params:{cacheKey:r},request:c,event:e}))}const{updatedURLs:r,notUpdatedURLs:s}=t;return function(e,t){const r=e.length,s=t.length;if(r||s){let c=`Precaching ${r} file${1===r?"":"s"}.`;s>0&&(c+=` ${s} file${1===s?" is":"s are"} already cached.`),a.logger.groupCollapsed(c),f("View newly precached URLs.",e),f("View previously precached URLs.",t),a.logger.groupEnd()}}(r,s),{updatedURLs:r,notUpdatedURLs:s}}))}activate(e){return c.waitUntil(e,(async()=>{const e=await self.caches.open(this.strategy.cacheName),t=await e.keys(),r=new Set(this._urlsToCacheKeys.values()),a=[];for(const s of t)r.has(s.url)||(await e.delete(s),a.push(s.url));return p(a),{deletedURLs:a}}))}getURLsToCacheKeys(){return this._urlsToCacheKeys}getCachedURLs(){return[...this._urlsToCacheKeys.keys()]}getCacheKeyForURL(e){const t=new URL(e,location.href);return this._urlsToCacheKeys.get(t.href)}getIntegrityForCacheKey(e){return this._cacheKeysToIntegrities.get(e)}async matchPrecache(e){const t=e instanceof Request?e.url:e,r=this.getCacheKeyForURL(t);if(r){return(await self.caches.open(this.strategy.cacheName)).match(r)}}createHandlerBoundToURL(e){const t=this.getCacheKeyForURL(e);if(!t)throw new s.WorkboxError("non-precached-url",{url:e});return r=>(r.request=new Request(e),r.params=Object.assign({cacheKey:t},r.params),this.strategy.handle(r))}}let R;const C=()=>(R||(R=new w),R);class U extends h.Route{constructor(e,t){super((({request:r})=>{const s=e.getURLsToCacheKeys();for(const a of function*(e,{ignoreURLParametersMatching:t=[/^utm_/,/^fbclid$/],directoryIndex:r="index.html",cleanURLs:a=!0,urlManipulation:s}={}){const c=new URL(e,location.href);c.hash="",yield c.href;const o=function(e,t=[]){for(const r of[...e.searchParams.keys()])t.some((e=>e.test(r)))&&e.searchParams.delete(r);return e}(c,t);if(yield o.href,r&&o.pathname.endsWith("/")){const e=new URL(o.href);e.pathname+=r,yield e.href}if(a){const e=new URL(o.href);e.pathname+=".html",yield e.href}if(s){const e=s({url:c});for(const t of e)yield t.href}}(r.url,t)){const t=s.get(a);if(t){return{cacheKey:t,integrity:e.getIntegrityForCacheKey(t)}}}a.logger.debug("Precaching did not find a match for "+n.getFriendlyURL(r.url))}),e.strategy)}}function m(e){const t=C(),r=new U(t,e);l.registerRoute(r)}function L(e){C().precache(e)}return e.PrecacheController=w,e.PrecacheFallbackPlugin=class{constructor({fallbackURL:e,precacheController:t}){this.handlerDidError=()=>this._precacheController.matchPrecache(this._fallbackURL),this._fallbackURL=e,this._precacheController=t||C()}},e.PrecacheRoute=U,e.PrecacheStrategy=y,e.addPlugins=function(e){C().strategy.plugins.push(...e)},e.addRoute=m,e.cleanupOutdatedCaches=function(){self.addEventListener("activate",(e=>{const t=r.cacheNames.getPrecacheName();e.waitUntil((async(e,t="-precache-")=>{const r=(await self.caches.keys()).filter((r=>r.includes(t)&&r.includes(self.registration.scope)&&r!==e));return await Promise.all(r.map((e=>self.caches.delete(e)))),r})(t).then((e=>{e.length>0&&a.logger.log("The following out-of-date precaches were cleaned up automatically:",e)})))}))},e.createHandlerBoundToURL=function(e){return C().createHandlerBoundToURL(e)},e.getCacheKeyForURL=function(e){return C().getCacheKeyForURL(e)},e.matchPrecache=function(e){return C().matchPrecache(e)},e.precache=L,e.precacheAndRoute=function(e,t){L(e),m(t)},e}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core,workbox.core._private,workbox.strategies,workbox.routing,workbox.routing);
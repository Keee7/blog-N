this.workbox=this.workbox||{},this.workbox.expiration=function(e,t,a,r,n,s,i,o){"use strict";function c(){return c=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var r in a)Object.prototype.hasOwnProperty.call(a,r)&&(e[r]=a[r])}return e},c.apply(this,arguments)}const m=(e,t)=>t.some((t=>e instanceof t));let u,d;const h=new WeakMap,p=new WeakMap,l=new WeakMap,g=new WeakMap,x=new WeakMap;let f={get(e,t,a){if(e instanceof IDBTransaction){if("done"===t)return p.get(e);if("objectStoreNames"===t)return e.objectStoreNames||l.get(e);if("store"===t)return a.objectStoreNames[1]?void 0:a.objectStore(a.objectStoreNames[0])}return N(e[t])},set:(e,t,a)=>(e[t]=a,!0),has:(e,t)=>e instanceof IDBTransaction&&("done"===t||"store"===t)||t in e};function w(e){return e!==IDBDatabase.prototype.transaction||"objectStoreNames"in IDBTransaction.prototype?(d||(d=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])).includes(e)?function(...t){return e.apply(E(this),t),N(h.get(this))}:function(...t){return N(e.apply(E(this),t))}:function(t,...a){const r=e.call(E(this),t,...a);return l.set(r,t.sort?t.sort():[t]),N(r)}}function b(e){return"function"==typeof e?w(e):(e instanceof IDBTransaction&&function(e){if(p.has(e))return;const t=new Promise(((t,a)=>{const r=()=>{e.removeEventListener("complete",n),e.removeEventListener("error",s),e.removeEventListener("abort",s)},n=()=>{t(),r()},s=()=>{a(e.error||new DOMException("AbortError","AbortError")),r()};e.addEventListener("complete",n),e.addEventListener("error",s),e.addEventListener("abort",s)}));p.set(e,t)}(e),m(e,u||(u=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction]))?new Proxy(e,f):e)}function N(e){if(e instanceof IDBRequest)return function(e){const t=new Promise(((t,a)=>{const r=()=>{e.removeEventListener("success",n),e.removeEventListener("error",s)},n=()=>{t(N(e.result)),r()},s=()=>{a(e.error),r()};e.addEventListener("success",n),e.addEventListener("error",s)}));return t.then((t=>{t instanceof IDBCursor&&h.set(t,e)})).catch((()=>{})),x.set(t,e),t}(e);if(g.has(e))return g.get(e);const t=b(e);return t!==e&&(g.set(e,t),x.set(t,e)),t}const E=e=>x.get(e);const D=["get","getKey","getAll","getAllKeys","count"],y=["put","add","delete","clear"],v=new Map;function k(e,t){if(!(e instanceof IDBDatabase)||t in e||"string"!=typeof t)return;if(v.get(t))return v.get(t);const a=t.replace(/FromIndex$/,""),r=t!==a,n=y.includes(a);if(!(a in(r?IDBIndex:IDBObjectStore).prototype)||!n&&!D.includes(a))return;const s=async function(e,...t){const s=this.transaction(e,n?"readwrite":"readonly");let i=s.store;return r&&(i=i.index(t.shift())),(await Promise.all([i[a](...t),n&&s.done]))[0]};return v.set(t,s),s}f=(e=>c({},e,{get:(t,a,r)=>k(t,a)||e.get(t,a,r),has:(t,a)=>!!k(t,a)||e.has(t,a)}))(f);try{self["workbox:expiration:7.0.0"]&&_()}catch(e){}const S="cache-entries",A=e=>{const t=new URL(e,location.href);return t.hash="",t.href};class I{constructor(e){this._db=null,this._cacheName=e}_upgradeDb(e){const t=e.createObjectStore(S,{keyPath:"id"});t.createIndex("cacheName","cacheName",{unique:!1}),t.createIndex("timestamp","timestamp",{unique:!1})}_upgradeDbAndDeleteOldDbs(e){this._upgradeDb(e),this._cacheName&&function(e,{blocked:t}={}){const a=indexedDB.deleteDatabase(e);t&&a.addEventListener("blocked",(()=>t())),N(a).then((()=>{}))}(this._cacheName)}async setTimestamp(e,t){const a={url:e=A(e),timestamp:t,cacheName:this._cacheName,id:this._getId(e)},r=(await this.getDb()).transaction(S,"readwrite",{durability:"relaxed"});await r.store.put(a),await r.done}async getTimestamp(e){const t=await this.getDb(),a=await t.get(S,this._getId(e));return null==a?void 0:a.timestamp}async expireEntries(e,t){const a=await this.getDb();let r=await a.transaction(S).store.index("timestamp").openCursor(null,"prev");const n=[];let s=0;for(;r;){const a=r.value;a.cacheName===this._cacheName&&(e&&a.timestamp<e||t&&s>=t?n.push(r.value):s++),r=await r.continue()}const i=[];for(const e of n)await a.delete(S,e.id),i.push(e.url);return i}_getId(e){return this._cacheName+"|"+A(e)}async getDb(){return this._db||(this._db=await function(e,t,{blocked:a,upgrade:r,blocking:n,terminated:s}={}){const i=indexedDB.open(e,t),o=N(i);return r&&i.addEventListener("upgradeneeded",(e=>{r(N(i.result),e.oldVersion,e.newVersion,N(i.transaction))})),a&&i.addEventListener("blocked",(()=>a())),o.then((e=>{s&&e.addEventListener("close",(()=>s())),n&&e.addEventListener("versionchange",(()=>n()))})).catch((()=>{})),o}("workbox-expiration",1,{upgrade:this._upgradeDbAndDeleteOldDbs.bind(this)})),this._db}}class T{constructor(e,a={}){if(this._isRunning=!1,this._rerunRequested=!1,t.assert.isType(e,"string",{moduleName:"workbox-expiration",className:"CacheExpiration",funcName:"constructor",paramName:"cacheName"}),!a.maxEntries&&!a.maxAgeSeconds)throw new n.WorkboxError("max-entries-or-age-required",{moduleName:"workbox-expiration",className:"CacheExpiration",funcName:"constructor"});a.maxEntries&&t.assert.isType(a.maxEntries,"number",{moduleName:"workbox-expiration",className:"CacheExpiration",funcName:"constructor",paramName:"config.maxEntries"}),a.maxAgeSeconds&&t.assert.isType(a.maxAgeSeconds,"number",{moduleName:"workbox-expiration",className:"CacheExpiration",funcName:"constructor",paramName:"config.maxAgeSeconds"}),this._maxEntries=a.maxEntries,this._maxAgeSeconds=a.maxAgeSeconds,this._matchOptions=a.matchOptions,this._cacheName=e,this._timestampModel=new I(e)}async expireEntries(){if(this._isRunning)return void(this._rerunRequested=!0);this._isRunning=!0;const e=this._maxAgeSeconds?Date.now()-1e3*this._maxAgeSeconds:0,t=await this._timestampModel.expireEntries(e,this._maxEntries),n=await self.caches.open(this._cacheName);for(const e of t)await n.delete(e,this._matchOptions);t.length>0?(r.logger.groupCollapsed(`Expired ${t.length} `+(1===t.length?"entry":"entries")+" and removed "+(1===t.length?"it":"them")+" from the "+`'${this._cacheName}' cache.`),r.logger.log(`Expired the following ${1===t.length?"URL":"URLs"}:`),t.forEach((e=>r.logger.log(`    ${e}`))),r.logger.groupEnd()):r.logger.debug("Cache expiration ran and found no entries to remove."),this._isRunning=!1,this._rerunRequested&&(this._rerunRequested=!1,a.dontWaitFor(this.expireEntries()))}async updateTimestamp(e){t.assert.isType(e,"string",{moduleName:"workbox-expiration",className:"CacheExpiration",funcName:"updateTimestamp",paramName:"url"}),await this._timestampModel.setTimestamp(e,Date.now())}async isURLExpired(e){if(this._maxAgeSeconds){const t=await this._timestampModel.getTimestamp(e),a=Date.now()-1e3*this._maxAgeSeconds;return void 0===t||t<a}throw new n.WorkboxError("expired-test-without-max-age",{methodName:"isURLExpired",paramName:"maxAgeSeconds"})}async delete(){this._rerunRequested=!1,await this._timestampModel.expireEntries(1/0)}}return e.CacheExpiration=T,e.ExpirationPlugin=class{constructor(e={}){if(this.cachedResponseWillBeUsed=async({event:e,request:t,cacheName:n,cachedResponse:s})=>{if(!s)return null;const o=this._isResponseDateFresh(s),c=this._getCacheExpiration(n);a.dontWaitFor(c.expireEntries());const m=c.updateTimestamp(t.url);if(e)try{e.waitUntil(m)}catch(t){"request"in e&&r.logger.warn(`Unable to ensure service worker stays alive when updating cache entry for '${i.getFriendlyURL(e.request.url)}'.`)}return o?s:null},this.cacheDidUpdate=async({cacheName:e,request:a})=>{t.assert.isType(e,"string",{moduleName:"workbox-expiration",className:"Plugin",funcName:"cacheDidUpdate",paramName:"cacheName"}),t.assert.isInstance(a,Request,{moduleName:"workbox-expiration",className:"Plugin",funcName:"cacheDidUpdate",paramName:"request"});const r=this._getCacheExpiration(e);await r.updateTimestamp(a.url),await r.expireEntries()},!e.maxEntries&&!e.maxAgeSeconds)throw new n.WorkboxError("max-entries-or-age-required",{moduleName:"workbox-expiration",className:"Plugin",funcName:"constructor"});e.maxEntries&&t.assert.isType(e.maxEntries,"number",{moduleName:"workbox-expiration",className:"Plugin",funcName:"constructor",paramName:"config.maxEntries"}),e.maxAgeSeconds&&t.assert.isType(e.maxAgeSeconds,"number",{moduleName:"workbox-expiration",className:"Plugin",funcName:"constructor",paramName:"config.maxAgeSeconds"}),this._config=e,this._maxAgeSeconds=e.maxAgeSeconds,this._cacheExpirations=new Map,e.purgeOnQuotaError&&o.registerQuotaErrorCallback((()=>this.deleteCacheAndMetadata()))}_getCacheExpiration(e){if(e===s.cacheNames.getRuntimeName())throw new n.WorkboxError("expire-custom-caches-only");let t=this._cacheExpirations.get(e);return t||(t=new T(e,this._config),this._cacheExpirations.set(e,t)),t}_isResponseDateFresh(e){if(!this._maxAgeSeconds)return!0;const t=this._getDateHeaderTimestamp(e);if(null===t)return!0;return t>=Date.now()-1e3*this._maxAgeSeconds}_getDateHeaderTimestamp(e){if(!e.headers.has("date"))return null;const t=e.headers.get("date"),a=new Date(t).getTime();return isNaN(a)?null:a}async deleteCacheAndMetadata(){for(const[e,t]of this._cacheExpirations)await self.caches.delete(e),await t.delete();this._cacheExpirations=new Map}},e}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core);